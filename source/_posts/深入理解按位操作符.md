---
title: 深入理解按位操作符
categories:
  - 算法
tags:
  - 算法
abbrlink: 3953655a
date: 2019-03-15 14:57:43
---

<div class="excerpt">
    按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。
</div>

<!-- more -->

## 概述

按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。

下面介绍各种操作符时，也会提供一些比较经典的例子，来看看它们是如何巧妙地解决问题的吧。

## 正文

### 二进制

> 本文假设你知道计算机中用二进制数来存储，计算数字，并且熟悉二进制数的表示方法。

讲解位操作符之前，先简单讲一下真值、原码、反码和补码。

#### 真值

我们表示自然数包括正数，负数和0，下面是1和-1的二进制表示：

```
+ 00000001 # +1
- 00000001 # -1
```

8位二进制数能表示的真值范围是[-2^8, +2^8]。

#### 原码

但是计算机只能存储0和1，不能存储正负，所以一个数的最高位存放符号，正数为0，负数为1，用后面七位来表示真值的绝对值：

```
0 0000001 # +1
1 0000001 # -1
```

由于`10000000`表示为 -0 ,这个没有意义，所以这个数字被用来表示 -128，所以负数就比整数多一个。

由于最高位被用来表示符号了，现在能表示的范围是[-2^7,+2^7-1]，即[-128,+127]。

#### 反码

反码的表示方法是：正数不变，负数是在其原码的基础上，符号位不变，其余位取反：

```
0 0000001 # +1
1 1111110 # -1
```

反码的表示范围和原码一样，是[-2^7,+2^7-1]，即[-128,+127]。

#### 补码

补码的作用主要是为了简化运算，将减法变为加法而发明的数学表示法，其表示方法是：正数不变，负数是在其反码的基础上+1：

```
0 0000001 # +1
1 1111111 # -1
```

#### 最后

```
[+1] = [0 0000001]原 = [0 0000001]反 = [0 0000001]补

[-1] = [1 0000001]原 = [1 1111110]反 = [1 1111111]补
```

### 按位操作符

从概念上讲，按位操作符遵循下面规则：

1. 操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。

   例如, 以下具有32位以上的整数将转换为32位整数：

   ```
   转换前: 11100110111110100000000000000110000000000001
   转换后:             10100000000000000110000000000001
   ```

2. 第一个操作数的每个比特位与第二个操作数的相应比特位匹配：第一位对应第一位，第二位对应第二位，以此类推。
3. 位运算符应用到每对比特位，结果是新的比特值。

下面开始讲解各种位操作符。

注意：

> 前面提到操作会被转换成32位整数，但下面为了简化，将使用8位整数来演示运算过程。

#### 一、与（AND）

对每一对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。与操作的真值表如下：

|  a   |  b   | a AND b |
| :--: | :--: | :-----: |
|  0   |  0   |    0    |
|  0   |  1   |    0    |
|  1   |  0   |    0    |
|  1   |  1   |    1    |

下面展示`11 & 14`的运算过程：

```
11(base 10) = 00001011(base 2)
14(base 10) = 00001110(base 2)
------------------------------
11 & 14     = 00001010(base 2) = 10(base10)
```

注意：

- 任何数和 0 进行 AND 都为0：`x & 0 = 0`。
- 任何数和 -1 进行 AND 都为自身：`x & -1 = x`。

#### 二、或（OR）

对每一对比特位执行或（OR）操作。只有 a 或者 b 中至少有一位是 1 时， `a` OR `b` 才为 1。或操作的真值表：

| a    | b    | a OR b |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

下面展示`11 | 14`的运算过程：

```
11(base 10) = 00001011(base 2)
14(base 10) = 00001110(base 2)
------------------------------
11 | 14     = 00001111(base 2) = 15(base10)
```

注意：

- 任何数和 0 进行 OR 都为自身：`x | 0 = x`。
- 任何数和 -1 进行 OR 都为 -1：`x | -1 = -1`。

#### 三、异或（XOR）

对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，`a` XOR `b` 的结果为 1。异或操作真值表：

|  a   |  b   | a XOR b |
| :--: | :--: | :-----: |
|  0   |  0   |    0    |
|  0   |  1   |    1    |
|  1   |  0   |    1    |
|  1   |  1   |    0    |

下面展示`11 ^ 14`的运算过程：

```
11(base 10) = 00001011(base 2)
14(base 10) = 00001110(base 2)
-----------------------------
11 ^ 14     = 00000101(base 2) = 5(base10)
```

注意：

- 任何数和 0 进行 XOR 都为自身：`x ^ 0 = x`。
- 任何数和 -1 进行 OR 都为 ~x：`x | -1 = ~x`。

#### 四、非（~a）

对每一个比特位执行非（NOT）操作。NOT `a` 结果为 a 的反转（即反码）。非操作的真值表：

|  a   | NOT a |
| :--: | :---: |
|  0   |   1   |
|  1   |   0   |

下面展示`~11`的运算过程：
```
 11 = [00001011‬]原 = [00001011‬]反 = [‭00001011]补 # 正数的反码和补码都不变
 ---------------------------------------------
 [‭00001011]补 = [11110100]按位取反
-------------------------------———————————————
~11 =  [11110100]补 = [11110011]反 = [10001100]原 = -12
```


#### 五、左移（Left shift）

#### 六、有符号右移

#### 七、无符号右移

## 参考资料

- [原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
- [真值，原码，反码，补码和移码 释义](https://blog.csdn.net/oscar999/article/details/8928789)
- [聊聊JavaScript中的二进制数](https://yanhaijing.com/javascript/2016/07/20/binary-in-js/)
- [按位操作符 ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)