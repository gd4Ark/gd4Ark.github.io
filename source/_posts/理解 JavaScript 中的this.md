---
title: 理解 JavaScript 中的 this
date: 2019-1-16 17:21:24
categories:
 	- 前端
tags: 
	- 前端
---

## 前言

理解`this`是我们要深入理解 JavaScript 中必不可少的一个步骤，同时只有理解了 `this`，你才能更加清晰地写出与自己预期一致的 JavaScript 代码。

本文是这系列的第三篇，往期文章：

1. [理解 JavaScript 中的作用域](https://juejin.im/post/5c386bd96fb9a04a03796f93)
2. [理解 JavaScript 中的闭包](https://juejin.im/post/5c3893bc6fb9a049d37f530f)

## 什么是 this

### 消除误解

在解释什么是`this`之前，需要先纠正大部分人对`this`的误解，常见的误解有：

1. 指向函数自身。
2. 指向它所在的作用域。

> 关于为何会误解的原因这里不多讲，这里只给出结论，有兴趣可以自行查询资料。

`this` 在任何情况下都不指向函数的词法作用域。你不能使用 `this` 来引用一个词法作用域内部的东西。

### this 到底是什么

排除了一些错误理解之后，我们来看看 `this`到底是一种什么样的机制。

`this`是在运行时（`runtime`）进行绑定的，**而不是在编写时绑定的**，它的上下文（对象）取决于函数调用时的各种条件。`this`的绑定和函数声明的位置没有任何关系，**只取决于函数的调用方式**。

当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。**`this `就是记录的其中一个属性**，会在函数执行的过程中用到。（PS:所以`this`并不等价于执行上下文）

## this 全面解析

前面 我们排除了一些对于 `this`的错误理解并且明白了每个函数的`this`是在调用时被绑定的，完全取决于函数的调用位置。

### 调用位置

通常来说，寻找调用位置就是寻找“函数被调用的位置“，其中最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。

下面我们来看看到底什么是调用栈和调用位置：

```javascript
function foo(){
    // 当前调用栈是：foo
    // 因此，当前调用位置是全局作用域
    console.log("foo");
    bar(); // <-- bar的调用位置
}
function bar(){
    // 当前调用栈是foo -> bar
    console.log("bar");
}
foo(); // <-- foo 的调用位置
```

> 你可以把调用栈想象成一个函数调用链， 就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。 另一个查看调用栈的方法是使用浏览器的调试工具。 绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。

### 绑定规则

在找到调用位置后，则需要判定代码属于下面四种绑定规则中的哪一种，然后才能对`this`进行绑定。
**注意:** `this`绑定的是上下文**对象**,**并不是函数自身也不是函数的词法作用域**

#### 默认绑定

这是最常见的函数调用类型：**独立函数调用**：

> 对函数直接使用而不带任何修饰的函数引用进行调用，简单点一个函数直接是`func()`这样调用，不同于通过对象属性调用例如`obj.func()`，也没有通过new关键字`new Function()`，也没有通过`apply`、`bind`、`call`强制改变`this`指向。
>
> 当被用作独立函数调用时（不论这个函数在哪被调用，不管全局还是其他函数内），`this`默认指向到`Window`。（**注意：在严格模式下`this`不再默认指向全局，而是`undefined**`）。

#### **隐式绑定**

如果被调用函数是某个对象下的属性（方法），那就是**隐式绑定**：

> 函数被某个对象拥有或者包含，也就是函数被作为对象的属性所引用，例如`obj.func()`，此时`this`会绑定到该对象上。

**隐式丢失**：

隐式丢失是一个最常见`this`绑定问题，