<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023 年度总结</title>
      <link href="//post/2023-summary.html"/>
      <url>//post/2023-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年无疑是我最摆烂的一年，竟然整整一年没有更新过博客，所以上一篇文章还停留在<a href="https://4ark.me/post/2022-summary.html">《2022 年度总结》</a>。</p><p>着实惭愧，是因为我今年变懒了吗？是也不是，但可以说今年是我参加工作以来，变化最大的一年。</p><h2 id="一段奇妙的经历"><a href="#一段奇妙的经历" class="headerlink" title="一段奇妙的经历"></a>一段奇妙的经历</h2><p>年后复工不久，我所在的项目组就被解散了，团队成员接连离职，一时间变得很迷茫，不知道该何去何从。</p><p>那段时间心态有点蚌埠住，这打乱了我的计划，导致晚上经常失眠，所以下班后，索性也不去想太多、开摆！</p><p>长期以来，我发现每当自己在工作中面对具有挑战性的工作或能从中得到满足感时，便会激发学习和写作的动力。反之，如果在工作缺乏挑战性和无趣，就会陷入消极的摆烂状态。对于这种现象，我称之为：「动力反馈循环」。</p><p>这种现象既有好的一面也有不好的一面，但它确实让我摆烂了一段时间。</p><p>但在某天，事情发生了变化，机缘巧合下，我为帮助一位朋友解决他所面临的问题，用相近一个小时写了个插件。出乎意料的是，这个插件竟然在接下来的数个月里为我带来了远超日常工资的额外收入。</p><p>这个插件技术含量并不高，对任何程序员来说都是易如反掌的事情，但对普通人来说，它能让成本降低无数倍，所以他们拥有强烈的付费意愿，最终一传十、十传百，很快，我的微信好友从 200 人不到变成 1000+。</p><p>我承认这完全是靠运气，并不意味着我拥有多厉害的商业洞察力，更无法保证能够复刻商业模式，一切皆运气。</p><p>我知道这只是一项短暂的副业，不具有持续性。因此，当收入开始下滑时，我便决定将插件出售。</p><p>在这过程中，最大的收获肯定是金钱，我从来没有想象过，赚钱竟然如此容易。</p><p>请原谅我这种没见过世面的人借用并改编一下罗格那句话：「睡觉睡到自然醒， 收钱收到手抽筋」。</p><p>但除此之外，我还收获了什么呢？我认为，首先要明白了一个<del>鸡汤</del>道理：</p><blockquote><p>成功的关键也许不是英明的决策，运气也起着关键作用。然而，这种运气并非完全偶然，它是你日常积累的结果。为了在机遇到来时能够比别人更快地抓住它，关键仍在于持续的付出和努力。</p></blockquote><p>我以前也开发过类似的插件，但未曾考虑过收费。以往，能够获得满足感的事情就是别人的答谢以及小额红包，这是我第一次尝试盈利，没想到效果出奇地好。当你要考虑对产品进行收费时，不妨先问一下自己是否愿意付费。</p><p>还有不必一开始追求完美，试想一小时不到写出来的插件肯定很粗糙，甚至是半自动的，但并不妨碍它正常工作。正如 <a href="https://lutaonan.com/blog/my-extension-sold-1k-yuan/#%E6%80%BB%E7%BB%93">Randy</a> 所说：自动化可以做也必须做，但不是从 day one 就开始做。</p><p>在没有摸清楚客户的习惯前，就贸然通过现有思维去解决问题，哪怕做得再多，方向错了，也许都是徒劳。</p><p>举个例子，如果我们要搞个下单或会员功能，可能大家都会想着弄个小程序或网站，让客户自己来操作。然而事实上客户并不买单，你要相信并理解，哪怕现在都 2024 年了，还真有人用不来这些东西。客户作为衣食父母，有时你要兼容他们，在这些客户的思维里，远不如直接微信转账给你来得方便，而不是一个冷冰冰的小程序。</p><p>所以上面那句「收钱收到手抽筋」可不是开玩笑的。想想看，如果每天有几百人微信转账给你，但每笔就几块钱…</p><p>当然即便是这样的局面，也是有方法可以在不改变客户习惯的前提去实现自动化的，而此时做自动化才是真正有价值的，但已经不是一开始想象的那样客户通过小程序充值云云这种思路，所以关键点仍是让客户能够接受。</p><p>以上是我觉得除了金钱以外，更为宝贵的经验，它可以让我在下一次做出更多正确的选择，少踩一些坑。</p><h2 id="送自己的礼物"><a href="#送自己的礼物" class="headerlink" title="送自己的礼物"></a>送自己的礼物</h2><p>今年，我给自己送了两份礼物。首先，在年初，我决定换一台电脑。在综合考虑了 M1 Pro 和 M2 Pro 之后，我最终选择了 M1 Pro，配置为 16GB RAM + 512GB 存储，通过 PDD 的百亿补贴以 10500 元的价格入手，香的嘞。一年的使用下来，它的性能完全满足我的需求，从未出现过卡顿，是我今年最满意的购物之一。</p><p>第二个礼物是我心动很久的小牛 U+B 电动车，虽然花 6、7k 买一台代步的电动车似乎过于奢侈，但实际使用后，其实非常值得。每天骑它上下班，不仅让我的心情变得格外愉快，还拓大了我的生活半径，生活幸福感拉满。</p><h2 id="迈入新篇章"><a href="#迈入新篇章" class="headerlink" title="迈入新篇章"></a>迈入新篇章</h2><p>是的，今年我完成了一件人生大事——我成家了！虽然按照中国男人普遍结婚年龄，我这个年纪结婚似乎稍早了些，但每个人的情况都是不同的。对于我而言，现在正是承担家庭责任的最佳时机。并且我和她已经走到了第七个年头（嗯，从初恋走到结婚，稳如老狗），其实我们的关系早已超越了恋人的层面，即便没有领证，我们就已经生活得如同一对老夫妻。</p><p>结婚是比较烧钱的，尽管广东这边的婚礼相对全国其他地区来说开销小一些，但仍然把我的积蓄花光。对于我这种社恐人来说，并不热衷于摆酒席，但迫于传统观念，也就不得不循规蹈矩，整体下来的感受就是：累，很累。</p><h2 id="思想的转换"><a href="#思想的转换" class="headerlink" title="思想的转换"></a>思想的转换</h2><p>今年我感觉自己变了不少。以前跟朋友聊天，一旦意见不合，我心里就不是滋味，有时候还得辩到底，好像非赢过他们不可。但现在回头看，那样其实挺没意思的，也挺幼稚。我为啥非得那样呢？其实就是想让别人觉得我对。但现实是，每个人都是在自己的小世界里长大的，看问题的角度自然不同。我之前在 V2EX 上看到不顺眼的观点，直接拉黑，现在想想，那其实挺狭隘的。人的看法是会变的，今天我不同意的人和观点，或许哪天就能给我带来新的启发。所以，现在我不再那么轻易拉黑别人了，毕竟，谁知道明天他们会不会说出让我眼前一亮的话呢？</p><p>就像以前，很多事情发生了我都会气得不行，但慢慢地，随着岁月添皱，我开始意识到事情没那么简单，也许并不像我当初想的那样。所以现在，遇到曾让我难以忍受的事，我学会了保持冷静，用一颗平和的心去看待。</p><p>但我也在想，这会不会是变相的犬儒？是不是我开始对事情不那么上心了，或者这只是逃避的一种方式？想了想，明白即使要冷静面对，也不能丢了追求正义的心。犬儒可能让人变得冷漠，但我还是希望，在看清世界的复杂后，依旧能带着热情去做一些改变。认识到世界不是非黑即白，不意味着我们就不追求更好。</p><p>还有对于写博客这件事情，虽然确实是我今年变懒了，但更大的原因，每当我想写一点什么，内心深处总会有一个声音告诉自己，也许你只是在胡说八道，索性就不写了。当然，这种想法并不好，我希望 2024 年能克服它。毕竟，我早就认为写博客主要是为了给将来的自己看，同时能够给别人一些帮助，所以我要继续坚持下去。</p><h2 id="工作上的感悟"><a href="#工作上的感悟" class="headerlink" title="工作上的感悟"></a>工作上的感悟</h2><p>前面提到，今年年初我曾经陷入一段时间的摆烂状态，但这种状态并没有持续太久。尽管今年的工作并不在我的计划之中，但也可以说是意外地收获了一些经验。让我先交代一下，在我初入职场时有幸加入到某公司的前端基建团队，致力于提升开发效率等方面的工作。这段经历对我后来的每一份工作都产生了深远的影响。然而，由于我一直没有真正参与产品线的开发，我的视野在很大程度上局限于提升效率这个领域，而没有形成更全面的产品思维。因为当时我的用户主要是开发同事，难免会受到开发角度的限制。虽然我在技术上能够优雅地解决问题，效率也很高，但所做出的东西往往对用户不够友好。这一问题在我自己开发的几个小项目中尤为明显。</p><p>因此，后来我选择了一份负责 2C 项目的岗位，真正地接触用户。在这个过程中，我学到了很多东西。例如，以前我并不具备像素眼，但随着被设计师盯着改样式的次数增加，我开始具备了这个能力。我也学会了站在用户的角度去思考功能的实现。然而，2C 项目往往版本迭代非常紧凑，我们不得不在优雅的代码实现和功能实现之间做出取舍。虽然在参与这个项目的过程中，我也努力解决了一些团队协作和开发效率上的问题，但要理解，很多时候同事们可能会固步自封，习惯了现状。在一个公司范围内推广新的方案，但如果没有领导的支持，是非常艰难的。</p><p>然而，今年我们所在的项目组被解散了。虽然我原本的计划没有完全实现，但我却重新承担了前端团队基建的工作。时隔数年，我再次投入到这个领域，让我在原本思考如何优雅实现的基础上，学会了更多关于如何设计的知识。因此，我认为这次经历是因祸得福。在从事产品线工作两年后，我发现我更喜欢做这类基础设施的工作。</p><p>最后，我想分享一个小插曲。在年底公司评优时，决策层在我和另一位候选人之间，选择了那位能为公司带来更多资金收益的同事。虽然我内心有些小失望，但我能理解这个决策。同时，我认为我仍然有机会继续从事我喜欢且擅长的工作，而且我的产出也得到了领导的认可，这对我来说是不亚于公司层面的认可。</p><h2 id="2024-年"><a href="#2024-年" class="headerlink" title="2024 年"></a>2024 年</h2><p>简而言之，今年是我变化很大的一年，但好的习惯却没有坚持下来，希望在来年能够重新拾起来。</p><p>最终，祝新年快乐！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 年度总结</title>
      <link href="//post/2022-summary.html"/>
      <url>//post/2022-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇总结在去年 12 月份底拖到现在，后面做了一个不大不小的手术，过年期间连床都不想下，就一直拖到了现在，最近已经恢复得七七八八，于是趁 1 月份还未结束，抓紧时间把它赶出来。</p><p>2022 年已经结束，感觉这一年过得特别漫长。这是疫情席卷全球的第三年，而且仍然是大事频出的一年。如果让我总结 2022，我认为有几句话是值得永远铭记的。与《人民日报》所选出的 12 句中没有提及苦难的话不同，我认为以下几句话才是正确的集体记忆：</p><p>第一句是「这个世界不要俺了」，我自认为不是一个政治冷感的人，但是我几乎不参与网上讨论，只是每当有重大的社会事件发生时，都很难不去关注。</p><p>第二句话是「我们是最后一代」，与之对应的是「他的软肋是他儿子」，让我不禁想起黄子华曾在《秋前算账》说过这么一句话：如果大家都不生孩子，暴政必亡！但我们知道这是不可能的，人类是大自然的动物，繁衍是人类的天性，即使在最困难的时候，人类也没有放弃生育。很多人都把希望寄托在下一代，但我认为，如果自己都做不到的事情，凭什么觉得自己的孩子能做到呢？无论是否丁克，我们都应该表示尊重和理解。</p><p>第三句话是「请抑制灵魂对自由的渴望」，有句话说过：不自由毋宁死。但实际上，能做到这一点的人并不多。大多数人都愿意为了安全和方便而放弃一些自由，只要不触及生而为人的底线。大多数人也都默认了这一点，只是当这句话从他们口中说出来时，让人感到无比心寒。</p><p>回顾 2021 年的总结，我的愿望只有一个——“好好活着”。这看上去似乎是一个非常简单的愿望，但对于某些人来说，能够活着就是最大的奢望。疫情已经放开，希望 2023 年一切都会回到正轨，我相信念念不忘，必有回响。</p><h2 id="收获和成长"><a href="#收获和成长" class="headerlink" title="收获和成长"></a>收获和成长</h2><p><strong>技术层面：</strong></p><ol><li>通过阅读开源代码解决心中疑惑，「源码面前，了无秘密」。</li><li>通过阅读 ECMAScript 规范使 JavaScript 水平更上一层楼。</li><li>通过开发油猴插件提高日常繁琐任务的效率。</li></ol><p><strong>个人影响力：</strong></p><ol><li>成为自己日常使用的工具的 Contributor。</li><li>办了一份技术周刊，扩大了幸运表面积（Luck Surface Area）。</li></ol><p>在今年年初，突发奇想办了一个周刊，不过持续了 14 周就没有下文了，主要原因是那时候有点忙，因为维护一个周刊，要么需要阅读大量的文章，要么需要有深度的思考，并且一周一次，需要占据很多时间，因此一旦忙起来就很容易断更，一旦断更，就很难再恢复之前的热情，不过总体来说，我认为维护一个周刊对自身是很有帮助，因此今年会重新上路，但形式不再局限与之前那样，打算写一些较有深度的长文或系列文章。</p><h2 id="年度盘点"><a href="#年度盘点" class="headerlink" title="年度盘点"></a>年度盘点</h2><h3 id="最喜欢的书"><a href="#最喜欢的书" class="headerlink" title="最喜欢的书"></a>最喜欢的书</h3><p>今年看过的书依旧不多，其中比较喜欢的这几本：</p><ul><li><strong>《翦商》</strong>，一部夏商周启示录，喜欢阅读历史的看官可不要错过了。</li><li><strong>《精通正则表达式》</strong>，无论看多少文档都比不上这本书给你带来的对于正则的领悟。</li><li><strong>《编程语言的设计与实现》</strong>，Ruby 作者向你展示创建编程语言的乐趣。</li></ul><h3 id="最喜欢的音乐"><a href="#最喜欢的音乐" class="headerlink" title="最喜欢的音乐"></a>最喜欢的音乐</h3><p>今年一如既往喜欢听我逼哥的《梵高先生》，有一天我听到了<a href="https://www.youtube.com/watch?v=725WGspTJqI&ab_channel=infinite3321">义乌隔壁酒吧</a>的版本，直接猛男落泪！</p><ul><li><strong>《梵高先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/572mdcKFCEMVgtSELmoIuU?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《处处吻》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/7scQnPn4YQGV8ZgtDNcdu5?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《可惜我是水瓶座》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/1sWUT5hSawhEctQEQrVQdn?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><h2 id="2023？"><a href="#2023？" class="headerlink" title="2023？"></a>2023？</h2><p>今年希望在技术上有所精进，还需要拓展一下技术以外的视野，比如多从产品角度思考问题。</p><p>想要实现的东西：</p><ul><li>自动格式化 wxml 文件的 prettier plugin</li></ul><p>当然，好好活着是最重要的，希望今年一切都会好起来！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们如何从 Wxml2Canvas 迁移到 Painter</title>
      <link href="//post/how-to-migrate-wxml2canvas-to-painter.html"/>
      <url>//post/how-to-migrate-wxml2canvas-to-painter.html</url>
      
        <content type="html"><![CDATA[<h2 id="路漫漫其修远兮"><a href="#路漫漫其修远兮" class="headerlink" title="路漫漫其修远兮"></a>路漫漫其修远兮</h2><p>糖纸苦 Wxml2Canvas 久矣！</p><p>长期以来，糖纸项目使用 <a href="https://github.com/wg-front/wxml2canvas">Wxml2Canvas</a> 库来生成分享海报。这个库的功能就是将 Wxml 转换成 Canvas，并最终生成一张图片。但是，这个库非常不稳定，经常会出现各种奇怪的 BUG，只能说勉强能用。如果你想了解 Wxml2Canvas 给我们带来的痛苦，可以阅读这篇文章：<a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a>。</p><p>因此，我们一直希望能找到一个更好的替代方案。在社区搜索后，我们发现 <a href="https://github.com/Kujiale-Mobile/Painter">Painter</a> 非常不错。然而，它与 Wxml2Canvas 的使用方式有很大的差异，我们的项目中有二十多个地方使用了 Wxml2Canvas，所以迁移起来并不容易。但 2022 即将结束，我们希望能在最后时刻做点事情来让自己找回一丝慰藉，所以才有了这篇文章。</p><p>让我们来看看这两个库的使用方式有什么不同：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212270056681.png?imageMogr2/format/webp" alt="image-20221227005600071" style="zoom: 50%;" /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212270056939.png?imageMogr2/format/webp" alt="image-20221227005620310" style="zoom:50%;" /><p>Wxml2Canvas 使用方式相对直观，使用 Wxml 和 Wxss 实现，而 Painter 则使用 JSON 配置。如果要将项目迁移到 Painter，就需要手写大量的 JSON 配置，这需要相当多的工作量。</p><h2 id="吾将上下而求索"><a href="#吾将上下而求索" class="headerlink" title="吾将上下而求索"></a>吾将上下而求索</h2><p>俗话说得好：<strong>只要思想不滑坡，办法总比困难多！</strong></p><p>那么，有没有一种方法可以让我们迁移到 Painter，同时又不用重写 JSON 配置呢？</p><p>让我们从不同的角度思考一下：Wxml2Canvas 可以直接将 Wxml 画到 Canvas 上，那么是否也可以将其转换成 JSON 配置呢？这样，我们就可以复用现有的 Wxml 代码，减少迁移的成本。</p><p>大致流程如下：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212272228830.png?imageMogr2/format/webp" alt="image-20221227222820467" style="zoom:50%;" /><p>总之，我们需要一个转换器来将 Wxml 转换为符合 Painter 使用的 JSON 配置，我愿称之为 Wxml2Json。</p><p>说干就干，我们可以直接照搬 Wxml2Canvas 的做法。首先获取最外层容器的尺寸，用来定义分享海报的宽高。然后，通过 wx.createSelectorQuery().selectAll() 获取所有需要绘制的节点和样式信息。接着，根据不同的节点类型设置对应的属性，最终输出一份 JSON 配置供 Painter 使用。</p><p>其核心方法是 <code>getWxml</code>，大致实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getWxml</span>(<span class="params">&#123;container, className&#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getNodes = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    query</span><br><span class="line">      .selectAll(className)</span><br><span class="line">      .fields(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">dataset</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">size</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">rect</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">computedStyle</span>: COMPOUTED_ELEMENT_STYLE,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="built_in">this</span>.formatNodes(res))</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      .exec()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getContainer = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    query</span><br><span class="line">      .select(container)</span><br><span class="line">      .fields(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">dataset</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">size</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">rect</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      .exec()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([getContainer, getNodes])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>formatNodes</code> 方法的职责就是根据需要绘制的节点类型进行格式转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">formatNodes</span>(<span class="params">nodes</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">    .map(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;dataset = &#123;&#125;&#125; = node</span><br><span class="line"></span><br><span class="line">      node = &#123;...node, ...dataset&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> n = _.pick(node, [<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;url&#x27;</span>])</span><br><span class="line"></span><br><span class="line">      n.css = <span class="built_in">this</span>.getCssByType(node)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function"><span class="params">s</span> =&gt;</span> s &amp;&amp; s.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个转换器，我们的迁移工作只需要将 <code>new Wxml2Canvas</code> 替换成 <code>new Wxml2Json</code> ，然后将数据传入 Painter 中即可。因此，一天内完成所有 Wxml2Canvas 迁移到 Painter 的工作将不再是个梦。</p><h2 id="山重水复疑无路"><a href="#山重水复疑无路" class="headerlink" title="山重水复疑无路"></a>山重水复疑无路</h2><p>缝合结束，不出意外的话马上要出意外了，虽然大部分机型都表示情绪稳定，但成功路上注定不会一马平川。</p><p>果不其然，让全网「沸腾」的鸿蒙首当其冲，如下图所示：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212280057359.png?imageMogr2/format/webp" alt="image-20221228005732730" style="zoom: 20%; text-align: left; margin:0;" /></p><p>然后，测试小姐姐的 iPhone 12 也毫不甘落下风，上来就憋了个大招：微信闪退。</p><p>以上这两个页面都有一个共同点，就是生成的分享海报尺寸非常大，比如说这个：1170 × 17259。</p><p>我去线上看了一下，发现同一个页面上  Wxml2Canvas  却是稳定的，那这个 Painter 为什么这么拉胯？</p><p>开始找茬，分析两者的实现，终于发现了一些端倪：首先是  <code>wx.canvasToTempFilePath</code> 的参数不同：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212282240876.png?imageMogr2/format/webp" alt="image-20221228223957183" style="zoom:50%;" /><p>翻看 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html">wx.canvasToTempFilePath</a> 文档，其中 <code>x</code>、<code>y</code> 默认值都是 0，问题不大。</p><p>主要问题在于 <code>width</code> 和 <code>height</code>，我们先来看看 <code>wx.canvasToTempFilePath</code> 这几个参数的作用：</p><ul><li>width，画布的宽度</li><li>height，画布的高度</li><li>destWidth，输出图片的宽度，默认值是 width × dpr</li><li>destHeight，输出图片的高度，默认值是 height × dpr</li></ul><p>然后再梳理一下这两个库中的参数值是多少：</p><ul><li>Wxml2Canvas<ul><li>width：与外层容器的宽度、 canvas 宽度一致</li><li>height：与外层容器的高度、 canvas 高度一致</li><li>destWidth，width × dpr</li><li>destHeight，height × dpr</li></ul></li><li>Painter<ul><li>width：外层容器的宽度 * dpr、 canvas 宽度一致</li><li>height：外层容器的宽度 * dpr、 canvas 高度一致</li><li>destWidth，与 canvas 宽度一致</li><li>destHeight， 与 canvas 高度一致</li></ul></li></ul><p>答案呼之欲出了，我来解释一下：</p><ol><li>Painter 会将所有需要绘制的节点尺寸乘以设备的 dpr。假设我们要生成一张 375 x 800 的海报，其中包含一张 100 x 100 的图片，在当前设备的 dpr 为 3 的情况下，Painter 会创建一张 1125 x 2400 的画布，在画布上绘制一张 300 x 300 的图片。最终在保存图片时，输出的图片尺寸与画布大小完全一致。</li><li>Wxml2Canvas 在绘制时是创建一张 375 x 800 的画布，并在画布上绘制一张 100 x 100 的图片，但是在最终保存图片时，输出的图片尺寸是画布大小乘以 dpr。</li></ol><p>看上去 Painter 的做法似乎并无不妥，因为画布大小和最终成品是 1:1 的；反观 Wxml2Canvas 却是 1:3，难道这样导出的图片不会影响清晰度吗？我们直接来做个实验，分别用 Painter 和 Wxml2Canvas 生成同一张分享海报，对比两张图片的不同，结果发现导出的图片无论尺寸还是文件大小都是一模一样的，如图所示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212291816047.png?imageMogr2/format/webp" alt="image-20221229181609765"></p><h2 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h2><p>既然如此，我们就可以直接将 Wxml2Canvas 的方案移植到 Painter，最终发现这样能 work：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212291328173.png?imageMogr2/format/webp" alt="image-20221229132803803" style="zoom:50%;" /><p>总而言之，尽管两者最终生成的成品尺寸是一样的，但是 Painter 设置的画布尺寸比 Wxml2Canvas 大了三倍，这样会使用更多的内存，而且微信官方文档也提到：设置过大的宽高会导致 Crash 的问题。</p><p>经过这一番操作，鸿蒙和 iPhone 12 也终于服帖了。然而，又有新的问题出现了。当某个页面生成并保存图片后，在滑动该页面时会明显感觉卡顿，对比一下 fps（帧率）的变化，确实离谱。<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032334581.png?imageMogr2/format/webp" alt="image-20230103233431180" style="zoom:100%;" /></p><p>这种卡顿是肉眼可见的，猜测可能是因为内存泄露造成。在真机上调试分析了一下内存占用情况，未进行生成海报时，CPU 占用率为 2%，内存占用为 872 MB：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032351510.png?imageMogr2/format/webp" alt="image-20230103235024011"></p><p>当生成海报时，CPU 占用率快速飙升到 22%，内存占用 895 MB：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032355858.png?imageMogr2/format/webp" alt="image-20230103235506588"></p><p>随后发现内存占用并没有下降，直到我们离开了当前页面时，占用率才有所下降。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032358207.png?imageMogr2/format/webp" alt="image-20230103235744395"></p><p>既然如此，可以在生成海报之后立即对分享卡片的内存进行回收，最简单的方式就是使用 <code>wx:if</code> 控制。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;share-card </span><br><span class="line"><span class="addition">+ wx:if=&quot;&#123;&#123;showShareCard&#125;&#125;&quot;</span></span><br><span class="line">  id=&#x27;share-card&#x27;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>最后来晒晒战绩，迁移后生成时间缩短近 50%：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212300914569.png?imageMogr2/format/webp" style="zoom:50%;" /><p>综上所述，Wxml2Canvas 在稳定性和可维护性方面都有所欠缺，但也有值得 Painter 借鉴的地方。例如，Wxml2Canvas 的使用方式更直观，不需要设置过大的画布尺寸，从而避免了 Crash 的风险。因此，将两者缝合起来，以最小的成本提高糖纸生成分享海报的效率和稳定性，何乐而不为？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于二舅的一些感悟</title>
      <link href="//post/live-sentiment.html"/>
      <url>//post/live-sentiment.html</url>
      
        <content type="html"><![CDATA[<p>最近二舅的视频炒得沸沸扬扬，看完视频后的我和大部分人的反应一样，觉得非常感动。</p><p>但随后我又不禁陷入沉思，如果换成是我，我会怎么做？</p><p>思索片刻，无非两条路，第一：结束自己的生命，但如果这么做，除了你的家人，还有谁为你感到伤心呢？</p><p>君不见，这段时间在微信群流传不少跳楼的视频，大家看完后有什么反应？惊叹一声，继续埋头做自己的事。</p><p>有谁会去深究他们背后的不幸呢，也许这个人就是另一个二舅，只是他选择走上这一条。</p><p>但我们没有反应，这是为什么呢？我们会认为，面对苦难，我们更应该像二舅这样积极乐观，而不是选择放弃。</p><p>是的，但这么多不幸的人，除了少部分选择结束自己的生命，其他人，哪个不是和二舅一样？</p><p>他们选择活下去，也只能是以积极乐观的态度面对生活，否则早就走上那条路了，所以麻烦搞清楚，这是一种无可奈何，试问换成你经受着一切，让你侄子拍个视频，让广大网友来敬佩你、在弹幕里疯狂刷「二舅」，你愿意吗？</p><p>二舅的不幸，是个人的不幸，更是时代的不幸，纵观他的人生，就是一部新中国史。</p><p>如同《活着》里面的福贵，他活着，也仅仅是活着，我们不会去赞扬他的乐观态度，我们更应该感到悲哀，为里面的福贵悲哀，也为这个时代悲哀，但记住永远不要相信这些苦难都是值得的，苦难就是苦难，苦难不会带来成功，苦难不值得追求，磨练意志只是因为苦难无法躲开。</p><p>王小波说：“人是一种会骗自己的动物，我们吃了很多无益的苦，虚掷了不少年华，所以有人就想说，这种经历是崇高的。”</p><p>二舅这个视频的意义是什么？难道让大家看看作者的二舅是如何坚强，就能治好我们所谓的精神内耗？</p><p>视频中暴露了一些真正应该被解决的问题，大家有重视吗？为什么二舅的残疾证一直办不下来，是我们相关部门为了磨炼二舅经受苦难的能力吗？二舅是否有低保？一个 68 岁的老人拉着另一个 88 岁的老人干活很正常吗？在我们社会中，还有多少个这样的二舅？</p><p>一个普通老百姓通过视频诉说自己的苦难，熬一碗鸡汤给自己喝，那也是因为二舅只能认命了呀，有什么办法？</p><p>可是官方凑热闹的时候是否应该反省一下，二舅的苦难，有多少是因为您造成的？您是不是想说：你们老百姓没办法，我们也觉得没办法呀，大家忍忍就过去了是吧？</p><p>反驳一下作者的话，人生比「把一手烂牌打成好牌」更重要的是，先搞清楚到底是谁在发牌，否则人家一直给你发烂牌，你即便打两辈子都打不完，反观人家周公子天生好牌，想怎么打就怎么打，这公平吗？</p><p>话说回来，上一次 B 站的视频炒得沸沸扬扬还是《后浪》，还记得当时豪情万丈、生长在这里实在是太幸福啦，我们有选择的权利！也才两年时间，画风就变成了像二舅这样平平淡淡凄凄惨惨切切才是真，这是同一批人吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一次 yarn 命令死循环说起</title>
      <link href="//post/yarn-cwd-issue.html"/>
      <url>//post/yarn-cwd-issue.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有个想法，希望在一个 yarn workspace 项目中实现任意一个子包中安装依赖时，都执行一些类似于初始化、同步配置的动作。</p><p>然而在操作过程中遇到了一个关于 <code>yarn --cwd</code> 有趣的问题，特地记录下来，希望能对后来者有所帮助。</p><h2 id="遇到什么问题呢"><a href="#遇到什么问题呢" class="headerlink" title="遇到什么问题呢"></a>遇到什么问题呢</h2><p>先交代一下我们项目的基本情况，它是一个通过 yarn workspace 管理的 monorepo 项目，使用的是 yarn v1.22.11 版本，目录结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monorepo</span><br><span class="line">├── package.json</span><br><span class="line">├── app-a</span><br><span class="line">│   └── package.json</span><br><span class="line">├── app-b</span><br><span class="line">│   └── package.json</span><br><span class="line">└── config</span><br><span class="line">    └── package.json</span><br></pre></td></tr></table></figure><p>其中 <code>app-a</code> 和 <code>app-b</code> 都使用了 <code>config</code> 这个共享包：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;@monorepo/config&quot;</span>: <span class="string">&quot;../config&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在根目录的 <code>package.json</code> 中的 <code>preinstall</code> 钩子做一些初始化操作：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;./bin/init.sh&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们在根目录执行 <code>yarn</code> 或者 <code>yarn add &lt;pkg-name&gt;</code>，都会触发 <code>preinstall</code> 这个钩子，但在 <code>app-a</code> 中执行 <code>yarn</code>是不会触发根目录的 <code>preinstall</code> 钩子的。</p><p>因此，我们需要分别在每个子包上都加上这行，也即在每个子包安装依赖时都执行一下根目录的 <code>preinstall</code> 命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，奇怪的事情就发生了，当我在 <code>app-a</code> 中执行 <code>yarn</code> 的时候，它停留在安装 <code>@monorepo/config</code> 的阶段，同时我的电脑明显变得卡顿，于是打开 <code>htop</code> 一看，好家伙，满屏都是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4ark   40987  26.3  0.5 409250368  78624   ??  R  8:36下午   0:00.09 /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/yarn --cwd ../ preinstall</span><br></pre></td></tr></table></figure><p>CPU 占用率直接达到 100%，吓得我赶紧 kill 掉这些进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep preinstall | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>惊吓过后，来分析一下原因，很显然这段命令陷入了死循环，导致越来越多进程，于是尝试在每个子包中都手动执行一遍 <code>yarn --cwd ../ preinstall</code> 后，发现一切正常，那问题出在哪呢？</p><p>于是我再执行了一遍 <code>yarn</code>，并且用以下命令将进程信息复制出来，以便分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | pbcopy</span><br></pre></td></tr></table></figure><p>随后验证我刚刚的猜测，的确是这个命令在不断触发自己，导致死循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UID   PID  PPID   C STIME   TTY     TIME CMD</span><br><span class="line">501 50399 50379   0  8:50下午 ??   0:00.10 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50400 50399   0  8:50下午 ??   0:00.11 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50401 50400   0  8:50下午 ??   0:00.11 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50402 50401   0  8:50下午 ??   0:00.12 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br></pre></td></tr></table></figure><p>由于三个分包执行的命令都一样，不清楚是不是由于某个分包引起，于是修改一下命令以便区分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;echo app-a &amp;&amp; yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后发现问题是出现在 <code>config</code> 这个子包，于是我把这个子包的 <code>preinstall</code> 命令去掉，果然没有这个问题了，非常奇怪。</p><p>难道是 <code>--cwd ../</code> 这个路径有问题？验证一下，把命令改成这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;pwd &amp;&amp; yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 <code>pwd</code> 输出是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/4ark/projects/monorepo/app-a/node_modules/@monorepo/config</span><br></pre></td></tr></table></figure><p>从这里的输出我们发现了两个问题，第一个问题是：</p><ul><li>yarn workspace 共享包的 <code>preinstall</code> 被执行的时候，其实已经被拷贝到 <code>app-a</code> 的 <code>node_modules</code> 中，而不是在当前目录，因此 <code>--cwd ../</code> 并不指向项目根目录。</li></ul><p>这一点比较好理解，毕竟 <code>config</code> 作为一个依赖包，确实应该被拷贝到应用的 <code>node_modules</code> 。</p><p>而第二个问题就不太理解了，为什么明明设置了 <code>--cwd ../</code>，却依然在当前目录执行呢？按照预期 cwd 的指向应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/4ark/projects/monorepo/app-a/node_modules/@monorepo</span><br></pre></td></tr></table></figure><p>难道是我对 cwd 参数的理解有偏差？看一下 yarn 的文档中对 cwd 描述：</p><blockquote><p>Specifies a current working directory, instead of the default <code>./</code>. Use this flag to perform an operation in a working directory that is not the current one.</p><p>This can make scripts nicer by avoiding the need to <code>cd</code> into a folder and then <code>cd</code> back out.</p></blockquote><p>从文档的描述来看，cwd 的作用不就是代替 <code>cd</code> 吗，但现在的结果看来 <code>yarn --cwd ../ preinstall</code> 并不等价于 <code>cd ../ &amp;&amp; yarn preinstall</code> 。</p><p>这就不得不让人疑惑 cwd 的定位方式了，在网上搜寻一番没找到相关的讨论，那只能自己动手丰衣足食，直接从 yarn 源码中寻找答案。</p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p>前面我们说到，我们使用的是 yarn v1.22.11，在 yarn 的 GitHub 仓库中发现 v1 版本的最新版本停留在 v1.23.0-0，那我们就从这个版本的源码来进行分析，首先克隆代码到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/yarnpkg/yarn</span><br></pre></td></tr></table></figure><p>然后安装依赖并运行起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn &amp;&amp; yarn watch</span><br></pre></td></tr></table></figure><p>这时候它就会自动监听代码修改然后重新编译，我们查看 <code>package.json</code> 发现 yarn 的 bin 主要是调用 <code> ./bin/yarn.js</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;yarn&quot;</span>: <span class="string">&quot;./bin/yarn.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;yarnpkg&quot;</span>: <span class="string">&quot;./bin/yarn.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>也就是我们直接执行 <code>bin/yarn.js</code> 的效果就如同执行 <code>yarn</code>，试一下查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; /Users/4ark/projects/yarn/bin/yarn -v</span><br><span class="line">1.23.0-0</span><br></pre></td></tr></table></figure><p>PS：当然你也可以在项目目录下使用 <code>npm link</code> 把它挂载到本地中。</p><p>接下就是一番调试，终于定位到可以回答我们疑问的代码，<a href="https://github.dev/yarnpkg/yarn/blob/6db39cf0ff684ce4e7de29669046afb8103fce3d/src/cli/index.js#L37-L51">在这里</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findProjectRoot</span>(<span class="params">base: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> dir = base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(path.join(dir, constants.NODE_PACKAGE_JSON))) &#123;</span><br><span class="line">      <span class="keyword">return</span> dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev = dir;</span><br><span class="line">    dir = path.dirname(dir);</span><br><span class="line">  &#125; <span class="keyword">while</span> (dir !== prev);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cwd = command.shouldRunInCurrentCwd ? commander.cwd : findProjectRoot(commander.cwd);</span><br></pre></td></tr></table></figure><p>可以看到 cwd 的定位方式是从当前目录寻找是否存在 <code>package.json</code>，若存在，则返回此目录，否则将目录经过 <code>path.dirname</code> 处理一遍，继续寻找，直到寻找到最外层。</p><p>那么这里最关键的是 <code>path.dirname</code> 的返回值，我们先看一下文档对于它的描述：</p><blockquote><p>The <code>path.dirname()</code> method returns the directory name of a <code>path</code>, similar to the Unix <code>dirname</code> command. Trailing directory separators are ignored,</p></blockquote><p>就是返回一个路径中的目录部分，作用与 unix 下的 dirname 命令一致，通常是这么使用的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; dirname /4ark/app/index.js</span><br><span class="line">/4ark/app</span><br><span class="line"></span><br><span class="line">&gt; dirname /4ark/app/packages/index.js</span><br><span class="line">/4ark/app/packages</span><br></pre></td></tr></table></figure><p>是不是会肤浅地认为它的作用就是返回一个路径的上一级目录？如果传入的是一个绝对路径，确实可以这么肤浅地认为，然而当传入的是一个相对路径时，情况就不一样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; dirname ../app/index.js</span><br><span class="line">../app</span><br><span class="line"></span><br><span class="line">&gt; dirname ../../</span><br><span class="line">../</span><br><span class="line"></span><br><span class="line">&gt; dirname ../</span><br><span class="line">问: 会返回什么呢？</span><br></pre></td></tr></table></figure><p>答案是：<code>.</code>，也就是当前目录。</p><p>那这里就能回答我们之前的问题，为什么在 <code>node_module/@monorepo/config</code> 中使用 <code>yarn --cwd ../ preinstall</code> 却在当前目录执行，因为它的上一级 <code>node_modules/@monorepo</code> 不存在 <code>package.json</code>，所以经过 <code>dirname ../</code> 处理后 cwd 的指向就是当前目录。</p><p>如果对 node.js 中 <code>path.dirname</code> 的实现方式感兴趣，可以看这里 <a href="https://github.com/jinder/path/blob/master/path.js#L538-L554">path.js#L538-L554</a>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>摸清楚原因后，那解决这个问题也不是难事，只要我们把相对路径改成绝对路径，是不是就能解决这个问题了？</p><p>思考一下，其实 <code>yarn --cwd ../ preinstall</code>，把 <code>../</code> 改成绝对路径行不行呢？比如在本文的场景，<code>../</code> 其实就是项目的根目录，那我们完全可以通过别的方式获取到项目的根目录，比如 在 git 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse --show-toplevel</span><br></pre></td></tr></table></figure><p>所以，我们把命令改成这样，问题就迎刃而解了：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- yarn --cwd ../ preinstall</span></span><br><span class="line"><span class="addition">+ yarn --cwd $(git rev-parse --show-toplevel) preinstall</span></span><br></pre></td></tr></table></figure><p>那就不得不提一下，其实在 yarn v2 中新增了一个 <code>--top-level</code>  属性，它的作用刚好就是为了解决这个问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实我们再回过头来想，在本文的例子中，根本不需要在 <code>config</code> 目录中添加 <code>preinstall</code> 这个钩子，因为它作为共享包，每次修改都必然要在其它使用这个包的地方，重新安装一次，所以只要确保这些地方会执行 <code>preinstall</code> 就可以了，那也就意味着不会出现本文遇到的问题。</p><p>不过，多踩坑也不是坏事，只要搞清楚背后的原因，问题也就不是问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第14期：暂停更新说明、自动化测试的未来趋势</title>
      <link href="//post/weekly-14.html"/>
      <url>//post/weekly-14.html</url>
      
        <content type="html"><![CDATA[<h2 id="暂停更新"><a href="#暂停更新" class="headerlink" title="暂停更新"></a>暂停更新</h2><p>因为最近在做一个 Side Project，所以本周刊已经有一段时间没更新了，毕竟一个人的时间精力是非常有限的，无法同时把两件事情做好，思前想后，决定先暂时停止周刊，等后面时间充裕起来，再恢复周刊，请见谅。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="为什么会有「她」和「祂」"><a href="#为什么会有「她」和「祂」" class="headerlink" title="为什么会有「她」和「祂」"></a>为什么会有「她」和「祂」</h3><p>在 V2EX 看到一个帖子<a href="https://v2ex.com/t/857418">《汉字不分性别的“他”》</a>，不禁疑惑为何要将「他」分为「它、他、她、牠、祂」呢？</p><p>首先为什么会出现「她」呢，其实「她」的开始是从清朝的刘半农才开始使用的，在以前「她」一直是「姐」的异体字，而在 1934 年的女性杂志《妇女共鸣》中，就曾在一篇<a href="http://www.cuhk.edu.hk/ics/21c/media/articles/c136-201207034.pdf">启事</a>指出：「本刊同仁，以人字旁代男子、女字旁代女子，牛字旁代物件，含有侮辱女子非人之意」，所以拒绝用「她」字。但尽管当时饱受批评，如今「她」还是成为流行的女性专用代词。</p><p>而「祂」的出现则是西方宗教在华传教时，用作对上帝、耶稣等的第三人称代名词，不过在我们生活中已经很少能够见到了。</p><p>延伸阅读：<a href="https://www.arianalife.com/tc/topics-tc/lgbt-tc/x%E4%B9%9Fand-ta-the-gradual-rise-of-gender-neutral-pronouns-in-chinese-tc/">《「他」、「X也」，还是「Ta」：非二元性別代词有哪些？》</a></p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><p>分享两篇非常不错的文章，分别提供 Bash 和 HTML 很多有用的技巧，这里就不全文摘抄了，有兴趣可以点击进原文查看。</p><h3 id="5-个现代-Bash-语法"><a href="#5-个现代-Bash-语法" class="headerlink" title="5 个现代 Bash 语法"></a><a href="https://levelup.gitconnected.com/5-bash-syntax-for-going-beyond-traditional-shell-scripting-6904d3e71af6">5 个现代 Bash 语法</a></h3><h4 id="处理输入比-Python-和-Node-js-更加简单"><a href="#处理输入比-Python-和-Node-js-更加简单" class="headerlink" title="处理输入比 Python 和 Node.js 更加简单"></a>处理输入比 Python 和 Node.js 更加简单</h4><p>在 Bash 中，你可以通过以下代码来获取用户输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name: &quot;</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">&gt; ./test.sh</span><br><span class="line">Enter your name: 4Ark</span><br><span class="line">Hello, 4Ark</span><br></pre></td></tr></table></figure><h3 id="10-个罕为人知但非常有用的-HTML-提示。"><a href="#10-个罕为人知但非常有用的-HTML-提示。" class="headerlink" title="10 个罕为人知但非常有用的 HTML 提示。"></a><a href="https://dev.to/babib/7-shocking-html-tips-you-probably-dont-know-about-ggd">10 个罕为人知但非常有用的 HTML 提示。</a></h3><h4 id="打开摄像机"><a href="#打开摄像机" class="headerlink" title="打开摄像机"></a>打开摄像机</h4><p>我们可以通过 input 的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/capture">capture</a> 属性来打开摄像机，它具有两个属性值：</p><ol><li>user：前摄像头</li><li>environment：后摄像头</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;user&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="自动化测试的未来趋势"><a href="#自动化测试的未来趋势" class="headerlink" title="自动化测试的未来趋势"></a><a href="https://insights.thoughtworks.cn/automated-testing-trends/">自动化测试的未来趋势</a></h3><p>这篇文章主要讲述自动化测试的发展以及未来趋势，从最早期的录制回放技术开始，逐步发展成DOM对象识别与分层自动化，而如今火热的 AI 技术会给自动化测试带来哪些突破呢？</p><p>其实在业界中已经有基于 AI 技术的自动化测试技术：</p><ol><li>自愈（Self-Healing）技术</li><li>机器学习（Machine Learning）技术</li></ol><p><strong>自愈技术</strong>一般指的是：一种自我修复的管理机制。<br>举个例子，假设我们通过 <a href="https://www.cypress.io/">Cypress</a> 等框架进行 E2E 测试时，都是通过 CSS 选择器等方式获取元素，从而做进一步的测试，而当我们的内部实现发生变化时（这里指的就是元素发生变化），测试用例会失败，我们需要手动修改测试用例。<br>而自愈技术可以通过比较页面前后的差异，来自动修复测试用例中的 CSS 选择器，并在结束时更新测试用例到代码中。<br>自愈技术在业界较好的实践是 <a href="https://healenium.io/">Healenium</a>。</p><p>然而传统的基于元素定位器等方式，面临着一些问题：</p><ul><li>仍然需要人工获取定位方式；</li><li>如果是通过 Canvas 绘制出来的对象，如何识别元素 (如Flutter Web)。</li></ul><p>于是就有了<strong>机器学习</strong>来解决这个问题，它可以通过图像识别和处理等技术来生成测试用例，比如直接根据某个按钮的截图来定位这个按钮，现在在业界较好的实践是 <a href="https://airtest.netease.com/">Airtest</a>。</p><p>自动化测试未来趋势不仅仅是这两种，还有如智能化探索性测试，智能遍历测试以及智能验证等。关于智能遍历所用到的技术，大家可以参考DQN的介绍。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.babelabc.com/">巴别英语 - 英语听力口语在线学习</a>：刷TED演讲和美剧佳作练听力, 带单句步进重复、灵活中英字幕设置等专为英语学习设计的功能, 让学英语变得容易、有趣、高效。</li></ul><ul><li><a href="https://monkeylearn.com/word-cloud">Free Word Cloud Generator</a>：构建你的词云，按相关性和频率对结果进行排序，探索更高级的文本分析工具。</li></ul><ul><li><a href="http://www.jsnice.org/">JS NICE</a>：一个 JavaScript 反混淆的在线工具。</li></ul><ul><li><a href="https://slashy.app/">Slashy</a>：一个可以创建 Notion 自定义命令的增强工具，非常不错。</li></ul><ul><li><a href="https://type-scale.com/">Type Scale</a>：一个可视化的字体大小调节工具，可以预览 CSS 字体在不同 rem 上表现。</li></ul><ul><li><a href="https://evanhahn.github.io/ffmpeg-buddy/">ffmpeg-buddy</a>：一个 ffmpeg 参数生成工具。</li></ul><ul><li><a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">NGINX 配置</a>：一个 nginx 配置生成工具。</li></ul><ul><li><a href="https://www.compose.ai/">Compose AI</a>：一个帮助写作的 AI 工具，目前仅适用于英语，缺点就是太贵。</li></ul><ul><li><a href="https://getcssscan.com/">CSS Scan</a>：一个可直接在网页内获取任意元素 CSS 样式的工具。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第13期：一些图像 AI 模型、冒名顶替综合症</title>
      <link href="//post/weekly-13.html"/>
      <url>//post/weekly-13.html</url>
      
        <content type="html"><![CDATA[<h2 id="本周轮子"><a href="#本周轮子" class="headerlink" title="本周轮子"></a>本周轮子</h2><p>本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项目都会接入这个工具，它的用途主要是统一管理项目中的 Git Hooks 脚本，不熟悉该工具的同学也不要紧，下面我们先来简单介绍一下 husky，它到底解决了什么问题，我们为什么需要使用 husky。</p><p>本周轮子：<a href="https://4ark.me/post/weekly-npm-packages-02.html">《每周轮子之 husky：统一规范团队 Git Hooks》</a></p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="AI-画画"><a href="#AI-画画" class="headerlink" title="AI 画画"></a>AI 画画</h3><p>上周和菜头在公众号分享了一篇文章<a href="https://mp.weixin.qq.com/s/abcMo8pxi9Gnu40m8DIFhg">《新玩具，新瘾头》</a>，里面介绍了一个谷歌的 AI 图像生成程序 <a href="https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/Disco_Diffusion.ipynb">Disco Diffusion</a>，它可以根据描述场景的关键词渲染出对应的图像，真的非常惊艳，有兴趣可以玩一下。</p><p>从文中借一张图来展示下效果：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312334384.png" alt="图片"></p><h3 id="文本生成图片"><a href="#文本生成图片" class="headerlink" title="文本生成图片"></a>文本生成图片</h3><p>这是谷歌的一个 AI 模型 <a href="https://imagen.research.google/">Imagen</a>，可以根据输入文字生成写实的图片，下面这个弹吉他的猫就是它生成的：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312247639.jpeg" alt="img"/><h3 id="Edge-的-AI-图像增强功能"><a href="#Edge-的-AI-图像增强功能" class="headerlink" title="Edge 的 AI 图像增强功能"></a><a href="https://blogs.bing.com/search-quality-insights/may-2022/Turing-Image-Super-Resolution">Edge 的 AI 图像增强功能</a></h3><p>微软图灵团队发布了一个 AI 模型  Super-Resolution (T-ISR)，它可以提高图片的质量，它将应用在 Bing 地图以及 Edge 浏览器中，目前已经在 <a href="https://www.microsoftedgeinsider.com/en-us/download/canary">Edge Canary</a> 中发布，将会在未来几个月推广给用户使用。</p><p>附上对比效果：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312333952.png" alt="image-20220531233321460"></p><h3 id="冒名顶替综合症"><a href="#冒名顶替综合症" class="headerlink" title="冒名顶替综合症"></a>冒名顶替综合症</h3><blockquote><p>冒名顶替综合症是一种心理现象，即一个人怀疑自己的技能、才能或成就，并有一种持续的内在恐惧，害怕被揭穿自己是个骗子。</p></blockquote><p>老实讲，从我开始写博客一直到今天，期间也写过一些较有深度的技术文章，往往这个时候都能感觉到自己知识的匮乏，而当我将这些文章发布到技术论坛时，一方面我自然希望可以帮助到更多人，另一方面也希望可以通过这些文章结识到更多志同道合的朋友，可是每当有人称赞我的文章写得不错的时候，我在开心之余，也隐约担心自己是否承受得起，其实这些文章是我花费了数天晚上才勉强肝出来的，并不轻松，我深知自己并没有他们口中说的那么厉害，甚至很多时候我会忘记自己在文章中写过的知识，但是好处是我可以非常快地重新拾起来，所以为了让自己可以持续地输出对别人有帮助的文章，我需要花费更多的时间在写作这件事情上，其实收益最大的是自己。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="没有-Docker-Desktop-的情况下运行-Docker"><a href="#没有-Docker-Desktop-的情况下运行-Docker" class="headerlink" title="没有 Docker Desktop 的情况下运行 Docker"></a><a href="https://www.swyx.io/running-docker-without-docker-desktop/">没有 Docker Desktop 的情况下运行 Docker</a></h3><p>Docker 几乎是每一位开发者都必备的工具，然而 Docker Desktop for Mac 也被无数人吐槽过，现在我们终于可以摆脱 Docker Desktop，使用 <a href="https://github.com/abiosoft/colima/">Colima</a> 即可在你的电脑上运行 Docker。</p><p>不过笔者按照文档上的步骤，遇到了这个报错：</p><blockquote><p>FATA[0000] error starting vm: error at ‘starting’: exit status 1</p></blockquote><p>如果你也遇到同样的问题，可以试试这个操作步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; brew unlink colima <span class="comment"># 已经安装的话，先卸载</span></span><br><span class="line"></span><br><span class="line">&gt; brew install --HEAD colima</span><br><span class="line"></span><br><span class="line">&gt; colima start --runtime docker</span><br><span class="line"></span><br><span class="line">&gt; docker ps <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="主要版本号不是神圣的"><a href="#主要版本号不是神圣的" class="headerlink" title="主要版本号不是神圣的"></a><a href="https://tom.preston-werner.com/2022/05/23/major-version-numbers-are-not-sacred.html">主要版本号不是神圣的</a></h3><p>本文的作者是 <a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a> 的提出者，相信大家对这个规范都不陌生，它规定了版本格式应该为：主版本号.次版本号.修订号。</p><p>版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>但作者在提出这个规范十年后的今天，发现了一个问题：大家把主版本号的升级看得太重要。</p><p>文章主要传递一个观点：<strong>主版本号的升级不应该作为一种营销的噱头，只要有 breaking change（重大改变） 时就应该升级，没有例外。</strong></p><p>下面聊些不太成熟的观点，在项目的实践中，特别是开源前端组件库，经常会面临一个选择困境：我们不得不对某个 API 做出 breaking change，然而这个  API 仅在少数场景下被使用到，如果严格遵循语义化版本，那我们将要升级主版本号，但是对于用户而言，会认为是整个组件库得到了升级，所以我认为这一点上还是需要根据实际情况做考虑。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://acapela.com/">Acapela</a>：一个收件箱搞定所有工作通知。</li></ul><ul><li><a href="https://uiverse.io/switches">uiverse.io</a>：一些开源的 UI 元素，可以直接复制代码。</li></ul><ul><li><a href="https://henryheffernan.com/">Henry Heffernan - Portfolio 2022</a>：一个惊艳的个人网站。</li></ul><ul><li><a href="https://sideproject.guide/">Side Project 指南</a>：一本关于程序员开发 Side Project 指南的小册。</li></ul><ul><li><a href="https://bionic-reading.com/">Bionic Reading</a>：这是一种英文阅读方式，它认为将每个单词的首字母变成大写后会使阅读效率提高，Reeder 也使用了这个服务。</li></ul><ul><li><a href="https://ooooooooooooooooooooooo.ooo/">ooooooooooooooooooooooo.ooo | URL Lengthner</a>：输入任意 URL，将它转换为全是 oooo。</li></ul><ul><li><a href="https://psychology-tools.com/">心理学工具</a>：一个经过学术验证的心理评估工具，如果这段时间感到焦虑、压力大的话可以简单做下测试。</li></ul><ul><li><a href="https://browser.engineering/index.html">Web Browser Engineering</a>：一本教你使用 1000 行的 Python 代码构建一个基本但完整的Web浏览器的书。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周轮子之 husky：统一规范团队 Git Hooks</title>
      <link href="//post/weekly-npm-packages-02.html"/>
      <url>//post/weekly-npm-packages-02.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>本文是每周轮子计划的第二篇，本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项目都会接入这个工具，它的用途主要是统一管理项目中的 Git Hooks 脚本，不熟悉该工具的同学也不要紧，下面我们先来简单介绍一下 husky，它到底解决了什么问题，我们为什么需要使用 husky。</p><p>大部分公司都会采用 Git 来对项目进行代码的版本控制，其好处相信大家都知道，这里就不再赘述，通常为了保证项目的代码质量、以及更好地进行团队之间的协作，我们都会在提交代码时做一些额外的工作，包括：检查 commit message 的规范性、统一代码风格、进行单元测试等等。</p><p>而这些工作自然不能完全依靠项目成员的自觉性，毕竟人都会犯错，所以这些工作都得交给自动化工具来处理。</p><p>因此，大部分版本控制系统都会提供一个叫做钩子（Hooks）的东西，Git 自然也不例外，Hooks 可以让我们在特定的重要动作发生时触发自定义脚本，通常分为客户端和服务端，而我们接触的大部分 Hooks 都是客户端的，也就是在我们本机上执行的。</p><p>下面我们简单介绍一下如何在 Git 中使用 Hooks，我们只需要在项目的 <code>.git/hooks</code> 目录中创建一个<strong>与某个 hook 同名的可执行脚本</strong>即可，比如我们想要阻止一切提交，并将 commit message 打印到终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .git/hooks/commit-msg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">INPUT_FILE=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">START_LINE=$(head -n1 <span class="variable">$INPUT_FILE</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前提交信息为：<span class="variable">$START_LINE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;阻止此次提交！！！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>这里先别纠结这段脚本代码是如何做到的，只需清楚我们可以利用 Git Hooks 做到这一点，实际上我们可以在这里做任何操作，比如检查 commit message 的规范性。</p><p>讲完如何使用 Git Hooks，那我们就得讲讲这种方式存在哪些不足。</p><p>在 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">Git 文档</a>中对客户端钩子有这么一段话：</p><blockquote><p>需要注意的是，克隆某个版本库时，它的客户端钩子并不随同复制。 如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。 </p></blockquote><p>简单来说就是，我们上面添加的这个 <code>commit-msg</code> Hook，只能在我们自己的机器上，不能被加入到版本控制中推送到远端，也就意味着我们无法同步这些 Hooks 脚本。</p><p>而 husky 主要就是为了解决这个问题，除此之外还提供了更加简便的方式来使用 Git Hooks，而无须采用上面那种方式。</p><p>先来介绍一下大家所熟知的 husky 用法，首先要安装这个工具，可以使用全局安装，但一般更推荐在项目本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky -D</span><br></pre></td></tr></table></figure><p>然后我们在 <code>package.json</code> 中添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;pre-push&quot;</span>: <span class="string">&quot;yarn test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这种方式是 husky v4 版本之前的配置方式，相信大部分同学都对这种方式很熟悉了，而在最新版本 husky（v7 之后） 已经不支持这样使用，而是采用命令行配置的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">npx husky add .husky/pre-push <span class="string">&quot;yarn test&quot;</span></span><br></pre></td></tr></table></figure><p>它的配置方式之所以会有如此翻天覆地的变化是有原因的，不过说来话长，我们下面会讲到，这里先按下不表。</p><p>本文就带领大家从 0 到 1 造一个 husky，我们先从第一种使用方式开始，然后一步步来看为什么 husky 在新版本会选择改变它的配置方式。</p><p>让我们开始吧！</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="v4-以前的版本"><a href="#v4-以前的版本" class="headerlink" title="v4 以前的版本"></a>v4 以前的版本</h3><p>我们先来以最 low 的方式实现它，第一步是对 <code>package.json</code> 进行配置，以便测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;echo hello husky!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后读取 <code>package.json</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// husky.js</span></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">husky</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pkg?.husky?.hooks) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pkg.husky.hooks !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = pkg.husky.hooks</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(hooks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">husky()</span><br></pre></td></tr></table></figure><p>现在我们现在已经能拿到 hooks 相关的配置，然后我们把相关的脚本内容写入到对应的 hooks 可执行文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [name, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(hooks)) &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="string">`#!/bin/sh\n<span class="subst">$&#123;value&#125;</span>\n`</span></span><br><span class="line"></span><br><span class="line">  fs.writeFileSync(<span class="string">`./.git/hooks/<span class="subst">$&#123;name&#125;</span>`</span>, script, &#123; <span class="attr">mode</span>: <span class="string">&#x27;751&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node husky.js</span><br></pre></td></tr></table></figure><p>然后我们就可以看到 <code>.git/hooks</code> 下面多了一个 <code>pre-commit</code> 可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat pre-commit</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> hello husky!</span><br></pre></td></tr></table></figure><p> 这时候进行 commit 也可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">hello husky!</span><br></pre></td></tr></table></figure><p>这时候我们已经完成了 husky 大部分的功能，但是这里还存在这么一个问题：<strong>如果现在我去修改 <code>package.json</code>  中的 husky 配置，hooks 文件如何同步更新？</strong></p><p>举个例子，如果现在把 <code>package.json</code> 改成这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line"><span class="deletion">-     &quot;pre-commit&quot;: &quot;echo hello husky!&quot;</span></span><br><span class="line"><span class="addition">+     &quot;pre-commit&quot;: &quot;echo hello husky2!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行 commit，它输出的仍然是 hello husky!，实际上如果我们不是手动执行写入 hooks 文件这个操作，甚至连第一步都做不到，可是回想上面 husky 的使用方式，我们只需要安装 husky 后进行配置即可，并不需要手动执行什么命令。</p><p>那 Huksy 是如何做到这一点的呢？动动你聪明的小脑瓜，有没有解决方案呢？</p><p>我们先来分析一下为什么无法做到自动同步更新 hooks，归根到底就是因为无法检测修改 <code>package.json</code> 后自动执行写入 hooks 操作，那我们不妨换一种思路：<strong>不用在修改 <code>package.json</code> 时执行写入操作，而是在执行 hooks 时去执行 <code>package.json</code> 中对应的 <code>hooks</code>。</strong></p><p>可能有点拗口，换句话说就是我们在一开始就把所有的 hooks 预注册了，然后在每一个 hooks 脚本中做同一件事：寻找 <code>package.json</code> 中对应的 hooks 并执行。</p><p>可能会觉得有点奇技淫巧 ，但也不失为一种曲线救国的方式，而事实上在 husky v4 之前还真的是这么做的。</p><p>那我们如何在一开始就注册所有 hooks 呢？</p><p>翻了一下 npm 的文档，发现有一个 <code>install</code> 钩子，它会在 <code>npm install</code> 后执行。</p><p>首先我们的项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── husky-test</span><br><span class="line">│   ├── husky</span><br><span class="line">│   │   ├── husky.js</span><br><span class="line">│   │   └── package.json</span><br><span class="line">│   └── package.json</span><br></pre></td></tr></table></figure><p>在 <code>husky/package.json</code> 添加以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;husky&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;install&quot;</span>: <span class="string">&quot;node husky&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>husky-test</code> 安装这个 npm 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;husky-test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;husky&quot;</span>: <span class="string">&quot;./husky&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候执行 <code>npm install</code> 会运行 <code>husky/husky.js</code> ，我们就可以在这个文件中预注册所有的 hooks，不过在此之前我们先梳理一下整体实现逻辑：</p><ol><li>我们要在 <code>husky.js</code> 中预注册所有的 hooks，可以在这个<a href="https://git-scm.com/docs/githooks">文档</a>中参考所有的 hooks。</li><li>我们要在所有的 hooks 中写入脚本内容，使其可以在被执行时寻找 <code>package.json</code> 中对应的 hook，并将其执行结果返回。<ol><li>因为 hooks 的 exit code 非 0 时要中断本次操作。</li></ol></li></ol><p>因此，经过梳理后，我们的目录结构调整如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── husky                   // husky 包</span><br><span class="line">│   ├── package.json     </span><br><span class="line">│   ├── husky.js            // install 入口</span><br><span class="line">│   ├── installer           // 初始化，预注册 hooks</span><br><span class="line">│   │   └── index.js     </span><br><span class="line">│   ├── runner              // 寻找对应的 hook 并执行</span><br><span class="line">│   │   └── index.js     </span><br><span class="line">│   └── sh                  // 所有 hooks 统一调用脚本</span><br><span class="line">│       └── husky.sh     </span><br><span class="line">└── package.json            // 测试</span><br></pre></td></tr></table></figure><p>我们在 <code>husky.js</code> 中调用 install 进行初始化操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> install = <span class="built_in">require</span>(<span class="string">&#x27;./installer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">install()</span><br></pre></td></tr></table></figure><p>然后在 <code>installer/index.js</code> 中预注册 hooks：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// installer/index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hookList = [</span><br><span class="line">  <span class="string">&#x27;applypatch-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-applypatch&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-applypatch&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-merge-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prepare-commit-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;commit-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-rebase&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-checkout&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-merge&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-update&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;push-to-checkout&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-auto-gc&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-rewrite&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sendemail-validate&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git</span>(<span class="params">args, cwd = process.cwd()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cp.spawnSync(<span class="string">&#x27;git&#x27;</span>, args, &#123; <span class="attr">stdio</span>: <span class="string">&#x27;pipe&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>, cwd &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> git([<span class="string">&#x27;rev-parse&#x27;</span>, <span class="string">&#x27;--show-toplevel&#x27;</span>]).stdout.trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGitHooksDir</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = getGitRoot()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path.join(root, <span class="string">&#x27;.git/hooks&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookScript</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`#!/bin/sh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">. &quot;$(dirname &quot;$0&quot;)/husky.sh&quot;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHook</span>(<span class="params">filename, script</span>) </span>&#123;</span><br><span class="line">  fs.writeFileSync(filename, script, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  fs.chmodSync(filename, <span class="number">0o0755</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHook</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hookScript = getHookScript()</span><br><span class="line"></span><br><span class="line">  writeHook(filename, hookScript)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHooks</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  getHooks(gitHooksDir).forEach(createHook)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHooks</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hookList.map(<span class="function">(<span class="params">hookName</span>) =&gt;</span> path.join(gitHooksDir, hookName))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMainScript</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainScript = fs.readFileSync(</span><br><span class="line">    path.join(__dirname, <span class="string">&#x27;../../sh/husky.sh&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mainScript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMainScript</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  fs.writeFileSync(path.join(gitHooksDir, <span class="string">&#x27;husky.sh&#x27;</span>), getMainScript(), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gitHooksDir = getGitHooksDir()</span><br><span class="line"></span><br><span class="line">  createHooks(gitHooksDir)</span><br><span class="line">  createMainScript(gitHooksDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这一步的结果是在安装 husky 时，会自动创建 hooks、并将 <code>husky.sh</code> 复制到 <code>.git/hooks</code> 中，所有 hooks 都会调用 <code>husky,sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/husky.sh&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>husky.sh</code> 中主要是做一件事，调用 <code>runner/index</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh/husky.sh</span></span><br><span class="line">gitParams=<span class="string">&quot;$*&quot;</span></span><br><span class="line">hookName=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">npm husky-run <span class="variable">$hookName</span> <span class="string">&quot;<span class="variable">$gitParams</span>&quot;</span></span><br></pre></td></tr></table></figure><p><code>husky-run</code> 是我们自定义的一个命令，需要在 <code>package.json</code> 中先注册：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// husky/package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;husky&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;husky-run&quot;: &quot;./runner/index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;install&quot;: &quot;node husky&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实际上就是调用 <code>runner/index</code>，我们要在这个文件中寻找对应的 hook 并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line">const &#123; spawnSync &#125; = require(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line">const &#123; cosmiconfigSync &#125; = require(<span class="string">&#x27;cosmiconfig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getConf(dir) &#123;</span><br><span class="line">  const explorer = cosmiconfigSync(<span class="string">&#x27;husky&#x27;</span>)</span><br><span class="line">  const &#123; config = &#123;&#125; &#125; = explorer.search(dir) || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const defaults = &#123;</span><br><span class="line">    skipCI: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> &#123; ...defaults, ...config &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getCommand(cwd, hookName) &#123;</span><br><span class="line">  const config = getConf(cwd)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> config &amp;&amp; config.hooks &amp;&amp; config.hooks[hookName]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> runner(</span><br><span class="line">  [, , hookName = <span class="string">&#x27;&#x27;</span>, husky_GIT_PARAMS],</span><br><span class="line">  &#123; cwd = process.cwd() &#125; = &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">  const <span class="built_in">command</span> = getCommand(cwd, hookName)</span><br><span class="line"></span><br><span class="line">  const env = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (husky_GIT_PARAMS) &#123;</span><br><span class="line">    env.husky_GIT_PARAMS = husky_GIT_PARAMS</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">command</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> runCommand(cwd, hookName, <span class="built_in">command</span>, env)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> runCommand(cwd, hookName, cmd, env) &#123;</span><br><span class="line">  const &#123; status &#125; = spawnSync(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;-c&#x27;</span>, cmd], &#123;</span><br><span class="line">    cwd,</span><br><span class="line">    env: &#123; ...process.env, ...env &#125;,</span><br><span class="line">    stdio: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status !== 0) &#123;</span><br><span class="line">    const noVerifyMessage = [</span><br><span class="line">      <span class="string">&#x27;commit-msg&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-commit&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-rebase&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-push&#x27;</span></span><br><span class="line">    ].includes(hookName)</span><br><span class="line">      ? <span class="string">&#x27;(add --no-verify to bypass)&#x27;</span></span><br><span class="line">      : <span class="string">&#x27;(cannot be bypassed with --no-verify due to Git specs)&#x27;</span></span><br><span class="line"></span><br><span class="line">    console.log(`husky &gt; <span class="variable">$&#123;hookName&#125;</span> hook failed <span class="variable">$&#123;noVerifyMessage&#125;</span>`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status === 127) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> status || 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const status = await runner(process.argv)</span><br><span class="line">    process.exit(status)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;husky &gt; unexpected error&#x27;</span>, err)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>我们来测试一下，在 <code>package.json</code> 添加如下配置：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;husky-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;husky&quot;: &quot;./husky&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="addition">+  &quot;husky&quot;: &#123;</span></span><br><span class="line"><span class="addition">+    &quot;hooks&quot;: &#123;</span></span><br><span class="line"><span class="addition">+      &quot;pre-commit&quot;: &quot;echo 123 &amp;&amp; exit 1&quot;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行一次 commit，得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">husky &gt; pre-commit hook failed (add --no-verify to bypass)</span><br></pre></td></tr></table></figure><p>OK，到这里我们除了一些代码上的健壮性问题以外，已经把大部分 husky v4 版本的核心功能都给实现了。</p><p>不过我们已经能够对 husky 的实现方式给摸透，各位同学认为这样的实现方式好不好呢？</p><p>其实 husky 的这种通过预注册所有 hooks 的方式一直被人诟病，详见 <a href="https://github.com/typicode/husky/issues/260">#260</a> 。</p><p>其实 husky 的维护者也知道这种方式属实不妥，不过由于当时 Git 的 hooks 机制，只能一直顶着骂名维护下去。</p><p>终于，在 Git v2.9 的版本升级中，正式支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，于是 husky 二话不说地进行了重构，用了一种全新的实现方式来做这件事，也就是我们今天看到的 husky v5 以后的版本（截止目前最新的 v8 版本）。</p><p>同时 husky 因为配置方式的缘故，使其仅局限于 node.js 项目，为了提高 husky 的使用范围，最新版本决定采用 CLI 配置的方式，参见：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</p><p>因此，最新版本的 husky 实现代码与前面版本截然不同，下面我们继续从 0 到 1 开始实现 husky。</p><h3 id="v4-以后的版本"><a href="#v4-以后的版本" class="headerlink" title="v4 以后的版本"></a>v4 以后的版本</h3><p>我们再把最新版本的 husky 使用方式介绍一遍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">npm set-script prepare <span class="string">&quot;husky install&quot;</span></span><br><span class="line">npm run prepare</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 hook</span></span><br><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;npm test&quot;</span></span><br><span class="line">git add .husky/pre-commit</span><br></pre></td></tr></table></figure><p>可以发现最新版本的 husky 无需利用 npm 的 install 钩子，毕竟已经不再局限于 node.js 项目，所以初始化操作需要另寻僻径，在 husky 文档中给出的解决方案是利用 npm 的 prepare 钩子，其可以执行 npm publish 和 不带参数的 npm install 时执行。</p><p>同时 husky 一共支持以下命令：</p><ol><li>husky install：安装，主要是配置 Git 的 core.hooksPath</li><li>husky uninstall：卸载，主要是恢复对 Git 的 core.hooksPath 的修改</li><li>husky set：新增 hook</li><li>husky add：给已有的 hook 追加命令</li></ol><p>因此，它的实现方式并不难，这里我直接张贴核心源码过来，首先是 CLI 的入口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get CLI arguments</span></span><br><span class="line"><span class="keyword">const</span> [, , cmd, ...args] = process.argv</span><br><span class="line"><span class="keyword">const</span> ln = args.length</span><br><span class="line"><span class="keyword">const</span> [x, y] = args</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set or add command in hook</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="function">(<span class="params">fn: (a1: <span class="built_in">string</span>, a2: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> (): <span class="function"><span class="params">void</span> =&gt;</span></span><br><span class="line">  <span class="comment">// Show usage if no arguments are provided or more than 2</span></span><br><span class="line">  !ln || ln &gt; <span class="number">2</span> ? help(<span class="number">2</span>) : fn(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLI commands</span></span><br><span class="line"><span class="keyword">const</span> cmds: &#123; [key: <span class="built_in">string</span>]: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">install</span>: (): <span class="function"><span class="params">void</span> =&gt;</span> (ln &gt; <span class="number">1</span> ? help(<span class="number">2</span>) : h.install(x)),</span><br><span class="line">  <span class="attr">uninstall</span>: h.uninstall,</span><br><span class="line">  <span class="attr">set</span>: hook(h.set),</span><br><span class="line">  <span class="attr">add</span>: hook(h.add),</span><br><span class="line">  [<span class="string">&#x27;-v&#x27;</span>]: <span class="function">() =&gt;</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">require</span>(p.join(__dirname, <span class="string">&#x27;../package.json&#x27;</span>)).version),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run CLI</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Run command or show usage for unknown command</span></span><br><span class="line">  cmds[cmd] ? cmds[cmd]() : help(<span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? <span class="string">`husky - <span class="subst">$&#123;e.message&#125;</span>`</span> : e)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="install-安装初始化"><a href="#install-安装初始化" class="headerlink" title="install 安装初始化"></a>install 安装初始化</h4><p>安装初始化主要做以下事情：</p><ol><li>拷贝 <code>husky.sh</code> 到项目中，其主要工作是添加 debug 开关以及支持 <code>.huskyrc</code> 配置文件，最后将其添加到 <code>.gitignore</code>。</li><li>将 Git 的 core.hooksPath 修改为项目目录的 <code>.husky</code>，后续添加的 hooks 都将存放在此目录。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">dir = <span class="string">&#x27;.husky&#x27;</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.HUSKY === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    l(<span class="string">&#x27;HUSKY env variable is set to 0, skipping install&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that we&#x27;re inside a git repository</span></span><br><span class="line">  <span class="comment">// If git command is not found, status is null and we should return.</span></span><br><span class="line">  <span class="comment">// That&#x27;s why status value needs to be checked explicitly.</span></span><br><span class="line">  <span class="keyword">if</span> (git([<span class="string">&#x27;rev-parse&#x27;</span>]).status !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Custom dir help</span></span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://typicode.github.io/husky/#/?id=custom-directory&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that we&#x27;re not trying to install outside of cwd</span></span><br><span class="line">  <span class="keyword">if</span> (!p.resolve(process.cwd(), dir).startsWith(process.cwd())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`.. not allowed (see <span class="subst">$&#123;url&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that cwd is git top level</span></span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(<span class="string">&#x27;.git&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`.git can&#x27;t be found (see <span class="subst">$&#123;url&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Create .husky/_</span></span><br><span class="line">    fs.mkdirSync(p.join(dir, <span class="string">&#x27;_&#x27;</span>), &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create .husky/_/.gitignore</span></span><br><span class="line">    fs.writeFileSync(p.join(dir, <span class="string">&#x27;_/.gitignore&#x27;</span>), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy husky.sh to .husky/_/husky.sh</span></span><br><span class="line">    fs.copyFileSync(p.join(__dirname, <span class="string">&#x27;../husky.sh&#x27;</span>), p.join(dir, <span class="string">&#x27;_/husky.sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure repo</span></span><br><span class="line">    <span class="keyword">const</span> &#123; error &#125; = git([<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;core.hooksPath&#x27;</span>, dir])</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    l(<span class="string">&#x27;Git hooks failed to install&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  l(<span class="string">&#x27;Git hooks installed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uninstall-卸载"><a href="#uninstall-卸载" class="headerlink" title="uninstall 卸载"></a>uninstall 卸载</h4><p>卸载的工作就更简单了，只需要恢复对 Git 的 core.hooksPath 的配置即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">uninstall</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  git([<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;--unset&#x27;</span>, <span class="string">&#x27;core.hooksPath&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-添加-hook"><a href="#set-添加-hook" class="headerlink" title="set 添加 hook"></a>set 添加 hook</h4><p>添加 hook 只需要创建对应的 hook 脚本文件，并写入内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">file: <span class="built_in">string</span>, cmd: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dir = p.dirname(file)</span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(dir)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`can&#x27;t create hook, <span class="subst">$&#123;dir&#125;</span> directory doesn&#x27;t exist (try running husky install)`</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    file,</span><br><span class="line">    <span class="string">`#!/usr/bin/env sh</span></span><br><span class="line"><span class="string">. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;cmd&#125;</span></span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    &#123; <span class="attr">mode</span>: <span class="number">0o0755</span> &#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  l(<span class="string">`created <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-追加-hook-命令"><a href="#add-追加-hook-命令" class="headerlink" title="add 追加 hook 命令"></a>add 追加 hook 命令</h4><p>add 命令是对已有的 hook 文件追加脚本文件，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">file: <span class="built_in">string</span>, cmd: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(file)) &#123;</span><br><span class="line">    fs.appendFileSync(file, <span class="string">`<span class="subst">$&#123;cmd&#125;</span>\n`</span>)</span><br><span class="line">    l(<span class="string">`updated <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    set(file, cmd)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文带领大家从 0 到 1 实现了 v4 以及最新版本的 husky，相信大家看完后对 husky 的实现方式也有了一定的了解，在以后的工作中使用它将会更加地得心应手，但如果你所在的项目中不是使用 Git，而是其它版本控制工具，也可以尝试基于 husky 改造，比如本人就曾尝试将 husky 改造使其<a href="https://github.com/gd4Ark/husky/pull/1">支持 Mercurial</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每周轮子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第12期：每周轮子计划、程序员应该如何写博客</title>
      <link href="//post/weekly-12.html"/>
      <url>//post/weekly-12.html</url>
      
        <content type="html"><![CDATA[<h2 id="本周轮子"><a href="#本周轮子" class="headerlink" title="本周轮子"></a>本周轮子</h2><p>以前看过一个小册子 <a href="https://github.yanhaixiang.com/make-wheels/">《一天学习一个 npm 轮子，十天后变成轮子哥 》</a>，觉得这种「首先实现一个最 Low 的解决方案，然后慢慢优化，进而推导出最终的源码」的学习思路非常不错，所以我也决定从现在开始，每周都学习造一个 npm 轮子。</p><p>当然前期只要专注于那些日常使用、相对简单的 npm 包，毕竟能力有限，太复杂的包就很难可以讲透。</p><p>这是本周的轮子：<a href="/post/weekly-npm-packages-01.html">《每周轮子之 only-allow：统一规范团队包管理器》</a>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="程序员应该怎么写博客？"><a href="#程序员应该怎么写博客？" class="headerlink" title="程序员应该怎么写博客？"></a><a href="https://www.v2ex.com/t/851549">程序员应该怎么写博客？</a></h3><p>这是在 V2EX 上看到的一个帖子，OP 是之前周刊有提到过的 <a href="https://hutusi.com/">胡涂说</a> 的博主，在这个帖子中，我收获不少有用的建议，也意外地发现到几个不错的博客。我也想借此机会聊一聊关于这个话题的一些想法，也算是当作我个人写作的总结与反思。</p><p>回顾本站的第一篇文章<a href="/post/d69467be.html">《锐捷无线AP学习笔记 - 入门篇》</a>，写于 2018 年，到现在也就第 4 个年头，相比有些人动不动建站十几年，自然算得上年轻，但我认为我在写博客这件事上有过不少的挣扎与坚持，总结起来一共经历了以下几个阶段，但其实以下阶段并不是层层递进式的，它们有可能会同时进行：</p><ol><li><strong>记录学习笔记</strong>，这个阶段的产出主要是一些较为基础的学习笔记，原创度也较低，属于网上一搜一大把那种，对他人的帮助接近于无，还记得当时把一篇文章分享到技术社区上，被某些暴躁的老哥说我误人子弟，更有甚者直接开怼让我干脆把整本书都抄过来，当时有点气馁，但也承认自己的确是很菜，也曾自我怀疑过是否应该继续往中文社区「倒垃圾」，但最后还是坚持下来了。据我了解很多程序员刚开始写博客都是写这类学习笔记，也有很多人仅仅停留在这个阶段，甚至放弃，实在是太可惜了。</li><li><strong>资源分享类</strong>，写技术文章很难写，有深度的技术文更是难上加上，所以曾有一段时间我特别喜欢写「资源分享」类的文章，譬如<a href="/posts/share-site.html">《分享一些好用的网站》</a>、<a href="/post/549a6198.html">《分享一些好用的 Chrome 扩展》</a>，这类文章写起来压根不费多少时间和经历，你只需要把平时经常使用的网站、工具分享一一罗列出来，，就能在社区上收获不少的点赞收藏，这也是为什么 GitHub 上简体中文项目的 Markdown 项目如此之多的原因，但是我后来意识到，写这类文章对我个人能力的提升并没有多大帮助，如果你知道一些非常有用的工具，你确实应该将它分享出去给更多人，这是非常有价值的，但我的建议是千万不要满足于只写这类文章。</li><li><strong>较有深度的技术文章</strong>，随着工作时间的增长，在技术上有了一些的积累，我开始尝试写一些较有深度的技术文章，包括一些经典面试题讲解、源码阅读、某个知识点深入剖析、一些工具类库的踩坑记录等，写这类文章是最痛苦的，因为你会发现在写的过程突然在某个地方你自己也无法讲清楚，说明你并没有理解透彻，于是只能逼迫自己一边查阅文档、一边根据自己的理解用自己的话把它讲透，这过程中的收获自然也是非常大，对其他人的帮助也不小。</li><li><strong>与技术无关的</strong>，人都是有感情的动物，除了技术以来，总需要聊点其他的东西，有可能是生活上的一些感悟，也有可能是你针对某个事情的看法，这类文章，它既有可能会引起读者的共鸣，也有可能会因为与读者的看法不同而遭到反感，且很多时候，自己也不确定这些看法到底是不是正确的，所以会害怕被别人看到自己不成熟的一面，我也曾有过这方面的顾虑，不敢在博客上公开谈论太多与技术无关的事情，但后来发现是我多虑了，因为这类文章，往往最终的读者只有你自己，因为读者看你的文章，他也只会关心对他有帮助的地方，而且即便你当时所记录下来的自己可能是不成熟的，这也是你成长的印记，比如我常常会在迷茫的时候翻看起之前刚踏入职场时写下的<a href="/posts/why-i-became-a-programmer.html">《我为什么会成为一名程序员》</a>，告诉自己不要忘了为什么会走上技术这条路，所以不要害怕写技术以外的东西，这些稚嫩的文字很有可能会在多年以后一直激励着你。</li></ol><p>可能还有些同学会认为自己文笔不好、词穷，写不了这么多文字，其实也是多虑了，我坦白我的文笔其实很差，不能像别人那样出口成章、行云流水，但其实你只要把意思表达清楚、并且注入你的感情即可，总之多写、坚持写。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="QOTD-协议"><a href="#QOTD-协议" class="headerlink" title="QOTD 协议"></a><a href="https://en.wikipedia.org/wiki/QOTD">QOTD 协议</a></h3><p>QOTD 的全程是 <strong>Quote of the Day</strong>，翻译过来就是「每日报价」，在 <a href="https://datatracker.ietf.org/doc/html/rfc865">RFC 865</a> 中定义，监听的端口是 17，这是一个非常少用到的协议，目前仅剩的公共 QOTD 服务器只有几个：</p><table><thead><tr><th>服务器地址</th><th>TCP 端口</th><th>UDP 端口</th></tr></thead><tbody><tr><td>djxmmx.net</td><td>17</td><td>17</td></tr><tr><td>alpha.mike-r.com</td><td>17</td><td>17</td></tr><tr><td>cygnus-x.net</td><td>17</td><td>17</td></tr></tbody></table><p>可以用它做什么呢？</p><p>比如<a href="https://github.com/daya0576/daya0576">这里</a>就有一个在 GitHub Action 上利用该协议定时获取 djxmmx.net 服务器上的名人名言，将它更新到 Github Profile 中。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="Bash-Pitfalls-编程易犯的错误"><a href="#Bash-Pitfalls-编程易犯的错误" class="headerlink" title="Bash Pitfalls: 编程易犯的错误"></a><a href="https://kodango.com/bash-pitfalls-part-1">Bash Pitfalls: 编程易犯的错误</a></h3><p>本文是<a href="http://mywiki.wooledge.org/BashPitfalls">《Bash Pitfalls》</a>的中文翻译版，介绍了40多条日常 Bash 编程中，老手和新手都容易忽略的错误编程习惯。作者会在每条给出错误的范例上，详细分析与解释错误的原因，同时给出正确的改写建议。</p><h3 id="Docker-镜像构建的一些技巧"><a href="#Docker-镜像构建的一些技巧" class="headerlink" title="Docker 镜像构建的一些技巧"></a><a href="https://www.kawabangga.com/posts/4676">Docker 镜像构建的一些技巧</a></h3><p>本文分享几个 Docker 镜像构建的一些技巧，可以帮助你提高 Docker 镜像构建的效率，对于老手来说已经是非常基本的事情了，但是对于新手还是很有帮助的。</p><p>原文一共举例了 4 个技巧，在此我只详细讲解第一个技巧，其余的麻烦移步<a href="https://www.kawabangga.com/posts/4676">原文</a>查看。</p><ol><li>删除缓存</li></ol><p>使用 apt、pip 等包管理器下载包时一般都会产生缓存，以便后续下载时使用，但是在 Docker Image 中，我们不需要这些缓存，所以一般都会在下载后，手动清除缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN dnf install -y --setopt=tsflags=nodocs \</span><br><span class="line">    httpd vim &amp;&amp; \</span><br><span class="line">    systemctl enable httpd &amp;&amp; \</span><br><span class="line">    dnf clean all</span><br></pre></td></tr></table></figure><p>要切记千万不要像这样分开写，因为 Dockerfile 里面的每一个 <code>RUN</code> 都会创建一层新的 layer，这样其实是创建了 3 层 layer，前 2 层带来了缓存，第三层删除了缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM fedora</span><br><span class="line">RUN dnf install -y mariadb</span><br><span class="line">RUN dnf install -y wordpress</span><br><span class="line">RUN dnf clean all</span><br></pre></td></tr></table></figure><p>但其实 Docker 在 <a href="https://www.docker.com/blog/whats-new-in-docker-1-13/">v1.13</a> 中引入了 <em>–squash</em> 参数，可以在完成构建后将所有的 layers <strong>压缩成一个 layer</strong>，也就是说，最终构建出来的 Docker image 只有一层，所以，如上在多个 <code>RUN</code> 中写 clean 命令，其实也可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash</span><br></pre></td></tr></table></figure><ol start="2"><li>改动不频繁的内容往前放</li><li>构建和运行 Image 分离</li><li>检查构建产物</li></ol><h3 id="JavaScript-函数式组合：有什么大不了的？"><a href="#JavaScript-函数式组合：有什么大不了的？" class="headerlink" title="JavaScript 函数式组合：有什么大不了的？"></a><a href="https://jrsinclair.com/articles/2022/javascript-function-composition-whats-the-big-deal/">JavaScript 函数式组合：有什么大不了的？</a></h3><p>这是我看到过所有写 JavaScript 函数式组合里面最通俗易懂的一篇文章，作者从头开始一步步地实现 compose、pipe、flow 等方法，并且让对函数式组合了解不多的同学知道，函数式组合的好处在哪？</p><p>举个例子，假如我们使用 Array 的方法是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = commentStrs</span><br><span class="line">    .filter(noNazi)</span><br><span class="line">    .slice(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .map(emphasize)</span><br><span class="line">    .map(itemize)</span><br><span class="line">    .join(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p>而改用函数式组合的方式，则是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(<span class="number">10</span>),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样写的好处在哪呢？</p><p>首先，我们可以增加任何 Array 原型上没有的自定义方法：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(10),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(&#x27;\n&#x27;),</span><br><span class="line"><span class="addition">+   chaoticListify,</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外，我们可以自由地实现像 map 这些方法，比如用生成器的方式改成它，而无需改变调用它们的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="keyword">function</span>*(<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> iterable) <span class="keyword">yield</span> f(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> join = <span class="function"><span class="params">s</span> =&gt;</span> <span class="function"><span class="params">iterable</span> =&gt;</span> [...iterable].join(s);</span><br></pre></td></tr></table></figure><p>综上所述，使用函数式组合的方式编写代码可以让我们写出更加简洁、优雅的代码，更重要的是它给我们提供了另一种思考的方式。</p><h3 id="中国黑客关系图"><a href="#中国黑客关系图" class="headerlink" title="中国黑客关系图"></a><a href="https://mp.weixin.qq.com/s/gowGNyJ_MaP6meQDQlSSZw">中国黑客关系图</a></h3><p>本文是新书《沸腾信安志》的一篇预热文章，主要讲述了中国上个世纪末到本世纪初的传奇黑客们的故事，想要了解有哪些著名的黑客，以及他们今何在的同学可以看看。</p><blockquote><p>网络安全行业和武侠江湖是很像的，有门派组织，有江湖名号，有武林大会，有绝计和宝物，而且都是大侠少而恶盗多，甚至连朝廷的管制方式都很相似。</p><p>这种氛围里，竟然出了这样一群奇人。</p><p>他们在最艰苦的岁月里，只要把道德底线稍微降低一点，就可以衣食无忧，然而他们没有；</p><p>他们掌握着最高超的技术，却拿着流量行业一半甚至更低的薪水，只要稍微做点灰产，就能摆脱困境，然而他们没有；</p><p>他们忍受着社会的质疑，承担着行业流氓带来的负面，却仍然坚持着自己热爱的技术创新。</p><p>直到现在，他们终于等到了自己的时代。</p></blockquote><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/zonemeen/musicn">zonemeen/musicn</a>：🎵 一个下载高质量音乐的命令行工具</li></ul><ul><li><a href="https://www.similarweb.com/zh/">Similarweb</a>：查看并分析任何网站流量，站长必备工具</li></ul><ul><li><a href="https://codeit.codes/">Codeit</a>：手机连接 Git 查看代码的神器 APP</li></ul><ul><li><a href="https://www.queue.so/">Queue</a>：使用 Notion 发布 Twitter 的工具</li></ul><ul><li><a href="https://coverview.vercel.app/">Coverview</a>：生成文章题图的工具</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周轮子之 only-allow：统一规范团队包管理器</title>
      <link href="//post/weekly-npm-packages-01.html"/>
      <url>//post/weekly-npm-packages-01.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先我们来提一个团队开发中很常见的需求：一般来说每个团队都会统一规定项目内只使用同一个包管理器，譬如 npm、yarn、pnpm 等，如果成员使用了不同的包管理器，则可能会因为 <em>lock file</em> 失效而导致项目无法正常运行，虽然这种情况一般都可以通过项目的上手文档来形容共识，但有没有更好的解决方案，比如在项目安装依赖时检测如果使用了不同的包管理器就抛出错误信息？</p><p>当然是可以的，pnpm 就有一个包叫做 <a href="https://www.npmjs.com/package/only-allow">only-allow</a> ，连 <a href="https://github.com/vitejs/vite/blob/c7fc1d4a532eae7b519bd70c6eba701e23b0635a/package.json#L16">vite</a> 都在使用它，所以本周我们就从 0 到 1 实现这个工具，以此对它的工作原理一探究竟。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>说干就干，我们先在 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#life-cycle-operation-order">npm 文档</a> 搜寻一番，发现有一个钩子叫做 <code>preinstall</code>：</p><blockquote><p>可以在运行 npm instal 之前执行某个命令，当 exit code 非 0 时终止运行</p></blockquote><p>所以第一步是在 <code>package.json</code> 中添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的问题就是：我们如何知道用户使用了哪一个包管理器？</p><p>我们知道 <code>process.env</code> 会包含当前脚本的运行环境，首先我们将它打印看看</p><p>分别使用 <code>yarn</code> 和 <code>npm install</code> 后，发现了以下几个相关字段的区别：</p><p>使用 <code>yarn</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_registry: &#x27;https:<span class="comment">//registry.yarnpkg.com&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/usr/local/lib/node_modules/yarn/bin/yarn.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;yarn/<span class="number">1.22</span><span class="number">.11</span> npm/? node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>npm</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_metrics_registry: &#x27;https:<span class="comment">//registry.npmjs.org/&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;npm/<span class="number">8.5</span><span class="number">.5</span> node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64 workspaces/<span class="literal">false</span>&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是三者的解释：</p><ol><li>npm_config_metrics_registry：npm 源，就是当我们安装 npm 包会从这个服务器上获取，可以通过 <code>npm config set registry</code> 或者     等工具进行配置。</li><li>npm_execpath：当前 npm 包管理器的执行目录，这个路径会根据你安装的方式而不同。</li><li>npm_config_user_agent：由包管理器设置的 UA，每个包管理器都不一样，比如 npm  <a href="https://github.com/npm/cli/blob/8a49e3ab6499c6196c5d7a0f6dad3b345944b992/lib/utils/config/definitions.js#L2190">lib/utils/config/definitions.js#L2190</a>，因此我们可以使用这个信息来判断客户端。</li></ol><p>因此我们可以通过 <code>process.env.npm_config_user_agent</code> 获取当前用户使用的包管理器，那么接下来的工作很简单了。</p><p>我们先写一个最 Low 的解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wantedPM = <span class="string">&#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = process.env.npm_config_user_agent.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的核心功能就已经实现了，还不赶紧发到 GitHub 开源一波坐等 stars？</p><p>别急，我们来思考下这段代码存在哪些不足：</p><ol><li>应该由用户指定可以使用哪一个包管理器。</li><li>这段代码的健壮性如何？</li></ol><p>那我们再修改一波，首先是接收用户传递参数，指定使用的包管理器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js yarn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改为通过接收参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ const argv = process.argv.slice(2)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const wantedPM = argv[0]</span></span><br><span class="line"><span class="deletion">- const wantedPM = &#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line">const usedPM = process.env.npm_config_user_agent.split(&#x27;/&#x27;)[0]</span><br><span class="line"></span><br><span class="line">if (usedPM !== wantedPM) &#123;</span><br><span class="line">  console.error(`You are using $&#123;usedPM&#125; but wanted $&#123;wantedPM&#125;`)</span><br><span class="line"></span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有第二个问题，这段代码的健壮性如何？譬如以下情况：</p><ol><li>用户不传或乱传参数怎么办？</li><li>如果以后有新需求：除了要限制包管理器，还要限制到具体某个版本怎么办？</li></ol><p>所以，我们再调整一波代码，检测传入的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们将获取 UA 的代码抽离出来，并使其可以获取版本，以便后续扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = getPackageManagerByUserAgent(</span><br><span class="line">  process.env.npm_config_user_agent</span><br><span class="line">).name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很好，现在我们已经将这个 npm 包的功能给实现了：<a href="https://www.npmjs.com/package/only-allow">only-allow</a>，可以看下它的源码：<a href="https://github.com/pnpm/only-allow/blob/master/bin.js">bin.js</a>。</p><p><strong>不过发现了一个问题：</strong>上面提到过 <code>preinstall</code>  钩子会在安装依赖时触发，但是经验证，npm 和 yarn 调用 <code>preinstall</code> 的时机不一样，npm 仅会在 <code>npm install</code> 时运行，而 <code>npm install &lt;pkg-name&gt;</code> 则不会，但 yarn 则会在 <code>yarn</code> 和 <code>yarn add &lt;pkg-name&gt;</code> 时都运行，所以如果想用这种方式限制 npm 使用者，可能无法达到预期，该问题在 2021 年<a href="https://github.com/npm/rfcs/issues/325">就有人提出</a>，但目前仍未有解决方案出现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每周轮子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第11期：扩大你的运气表面积（Luck Surface Area）</title>
      <link href="//post/weekly-11.html"/>
      <url>//post/weekly-11.html</url>
      
        <content type="html"><![CDATA[<h2 id="扩大你的运气表面积"><a href="#扩大你的运气表面积" class="headerlink" title="扩大你的运气表面积"></a>扩大你的运气表面积</h2><p>想说两件事，第一件事，在上周的某天下午，我收到了一封邮件：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204282317575.png" alt="image-20220428231741858"></p><p>这是 V2EX 上的一位老哥发来的邮件，他也在写周刊<a href="http://weekly.codelc.com/">《野生架构师》</a>，估计不少人都听过，毕竟最近在 V2EX 上比较活跃，收到这封来信让我非常开心，毕竟自己的周刊内容得到了他人的认可。</p><p>同时也让我知道了一个新的概念：运气表面积（Luck Surface Area）。</p><p>这个概念该如何理解，根据<a href="https://www.codusoperandi.com/posts/increasing-your-luck-surface-area">《How to Increase Your Luck Surface Area》</a>的描述：</p><blockquote><p>在你的生活中发生意外的数量，就是你的运气表面积，它与你所热爱的事情、以及被有效沟通的人数是成正比的，换句话说，你的运气是你自己创造的。</p></blockquote><p>它的公式是：<strong>运气表面积 = 你采取的行动 [X] x 你沟通的人数 [X]</strong> 。</p><p>运气表面积的工作原理是这样的，当你投入精力去做某件事情，你分享出去，你就会产生价值，但很多时候，这个价值会被所影响的人放大，它有可能会以某种你未曾预料的方式回报你，比如招聘你、投资你，但无论以何种方式发生，它都是偶然的。</p><p>说回上面那封邮件，我之所以写周刊在<a href="https://4ark.me/post/weekly-idea.html">《我为什么要写周刊》</a> 中有提到，我希望我能够对我每周所阅读的文章做一份总结，以此巩固我自身的理解，并希望不时输出自己观点的同时也能够帮助到其他人。</p><p>正因为我写周刊，被这位老哥看到了，发来这么一封邮件，让我感受到了被认可的快乐，因此更加坚定了我继续写周刊的信心，这就是我的运气表面积在扩大，但这一切都是非常偶然的，我在做这件事情的时候，我没有预料到这一点，所以正是因为我做这件事情为我自己创造了运气。</p><p>另外一件让我感到运气表面积在扩大的事，在一直订阅的<a href="https://hutusi.com/">胡涂说</a>的周刊<a href="https://hutusi.com/articles/weekly-13">《No.13: 周刊的周刊》</a>发现了他推荐我的周刊，而他的原话是：</p><blockquote><p>看到很多博主在写周刊，我想还是把这一传统给拾起来。</p></blockquote><p>这让我想到了一件非常奇妙的事情，前段时间 V2EX 上有讨论 <a href="https://v2ex.com/t/842511">为什么忽然间大家都开始做周刊了</a>，但我坦承我不是在跟风，或许别人也是如此，那么有没有可能是因为某一个人持续地在做这件事，影响了很多人，然后大家又互相影响，无形中扩大了大家的运气表面积，如果真是这样，那我认为是阮一峰影响了我，而我也可能在影响其他人。</p><p>最后从<a href="https://dimzou.feat.com/zh-CN/draft/580665/585314">这里</a>摘录一下以下三者的不同：</p><ol><li><strong>幸运</strong>是发生在你身上的事情，生在好人家是福，被雷劈是祸。</li><li><strong>机会</strong>需要您采取行动。您需要抓住机会，例如购买彩票，或约某人出去约会，以从偶然事件中受益。</li><li><strong>运气</strong>是成功或失败<em>显然</em>是偶然造成的。看起来这是一个机会，因为我们很少看到在成功或失败之前发生的一切。运气是通过发现和创造机会来实现的。这是你行为的直接后果。</li></ol><p>所以，记住一件事情，<strong>你可以创造你的运气，只要你去做更多的事情影响别人</strong>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="POSSE-和-Mastodon"><a href="#POSSE-和-Mastodon" class="headerlink" title="POSSE 和 Mastodon"></a>POSSE 和 Mastodon</h3><p>POSSE 的全称是 Publish (on your) Own Site, Syndicate Elsewhere，意为「在你自己的网站上发布，在其他地方联合」。</p><p>这是 2010 年首次在<a href="https://steveivy.gitlab.io/tantek-celik-diso-20-brass-tacks.html">《Tantek Celik Diso 20 Brass Tacks》</a> 提出的一种联合模型方案：</p><blockquote><p>在你自己的网站上发布，拥有自己的 URL 和永久链接，并通过其他社交媒体、社区中公布该链接。</p></blockquote><p>可以通过这段短片<a href="https://www.youtube.com/watch?v=X3SrZuH00GQ&t=835s">《Own your content on Social Media using the IndieWeb》</a>快速了解 POSSE。</p><p>采用该模型的好处是：如果我的 Twitter 帐户被删除（被官方或我自己删除），我不会丢失任何重要内容。</p><p>其实已经不少人采用这个方案，譬如就不少博主都会将文章链接发到 Twitter、Telegram 频道上，一方面是起到推广的作用，另一方面正是因为 POSSE。</p><p>你也可以通过这个链接<a href="https://indieweb.org/POSSE">《POSSE - IndieWeb》</a> 了解更多信息。</p><p>之所以越来越多人采用这个方案，都是因为对官方的不信任，所以希望把数据掌握在自己的手中，所以这里简单介绍一下 Mastodon：</p><blockquote><p>Mastodon 是互联网上最大的去中心化的社交网络，它由一个非营利组织基于开放网络标准建立。</p></blockquote><p>简单来说就是一个自托管的类 Twitter、微博的网站，你可以构建并部署自己的 Mastodon 实例，也可以加入他人的实例，顺便一提之前川普搞的社交媒体的 <a href="https://en.wikipedia.org/wiki/Truth_Social">Truth Social</a> 也是基于 Mastodon 的。</p><p>但 Mastodon 也有它的不足之处，譬如：</p><ol><li>稳定性，毕竟只有少部分人在维护实例。</li><li>还没有一个好的策略去防止虚假信息，仇恨言论，骚扰等。</li></ol><p>但也有不少人开始尝试从 Twitter 转向 Mastodon，比如 <a href="https://2ality.com/index.html">2ality</a> 的博主 <a href="https://fosstodon.org/@rauschma">Axel Rauschmayer</a>，有兴趣的同学可以从 <a href="https://fosstodon.org/explore">Explore Fosstodon</a>  开始探索。</p><h3 id="造谣的成本有多低？"><a href="#造谣的成本有多低？" class="headerlink" title="造谣的成本有多低？"></a>造谣的成本有多低？</h3><p>在如今的网络，造谣的成本非常低，比如我们就可以通过 <a href="https://fakedetail.com/">Fake Details</a> 这个网站去伪造各式各样的假信息，可以伪造下面这些社交媒体的假截图：</p><ul><li>Twitter 推文</li><li>Tiktok</li><li>Youtube</li><li>等等…</li></ul><p>甚至只需要在某个完全不相关的视频上面截个图，就可以张冠李戴地套在另外一件时事上面，而我们该如何去辨别这些假信息呢？</p><p>在<a href="https://4ark.me/post/weekly-04.html">《周刊第4期：独立思考》</a> 曾推荐过几个比较可靠的事实核查网站，这里再贴一下：</p><ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul><p>除了看以上这些网站给出的结论，我们还可以通过这些网站提供的<a href="https://tfc-taiwan.org.tw/topic/4112">核查工具箱</a>，自己去学习如何做事实核查。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chrome-用户体验报告比较工具"><a href="#Chrome-用户体验报告比较工具" class="headerlink" title="Chrome 用户体验报告比较工具"></a><a href="https://crux.zaps.dev/">Chrome 用户体验报告比较工具</a></h3><p>你只需要在 Chrome UX Report Compare Tool 这个网站上输入一个或多个 URL，它将会列出它们的各项性能指标，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205052214723.png" alt="image-20220505221453130"></p><p>然而当我输入本 Blog 的域名时，它提示我：Chrome 用户体验报告中没有足够的数据，这是访问人数不够多的缘故。</p><p>如果想要了解背后的技术细节，可以看这篇文章<a href="https://web.dev/chrome-ux-report-api/">《使用 Chrome 用户体验报告 API》</a>。</p><h3 id="使用-Javascript-的可选操作符可能会破坏你的代码"><a href="#使用-Javascript-的可选操作符可能会破坏你的代码" class="headerlink" title="使用 Javascript 的可选操作符可能会破坏你的代码"></a><a href="https://p42.ai/blog/2022-05-04/javascript-refactoring-gotchas-5-ways-converting-to-optional-chaining-can-break-your-code">使用 Javascript 的可选操作符可能会破坏你的代码</a></h3><p>熟悉 JS 的同学都知道我们可以通过 <code>obj?.x</code> 这个语法来更安全地访问对象属性等，但是如果盲目地使用这个语法，可能会导致一些意想不到的事情发生，比如以下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value &amp;&amp; value.length&#125;</span>, <span class="subst">$&#123;value?.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="literal">undefined</span>);       <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">null</span>);            <span class="comment">// null, undefined</span></span><br><span class="line">test(<span class="literal">true</span>);            <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">false</span>);           <span class="comment">// false, undefined</span></span><br><span class="line">test(<span class="number">1</span>);               <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="number">0</span>);               <span class="comment">// 0, undefined</span></span><br><span class="line">test(&#123;&#125;);              <span class="comment">// undefined, undefined</span></span><br><span class="line">test([]);              <span class="comment">// 0, 0</span></span><br><span class="line">test(&#123; <span class="attr">length</span>: <span class="string">&quot;a&quot;</span> &#125;); <span class="comment">// a, a</span></span><br><span class="line">test(<span class="string">&#x27;&#x27;</span>);              <span class="comment">// , 0</span></span><br><span class="line">test(<span class="literal">NaN</span>);             <span class="comment">// NaN, undefined</span></span><br></pre></td></tr></table></figure><p>通过这个例子我们发现，仅当值为 undefined 的时候，Optional Chaining 才有可能按照预期运行，所以我们编写代码的时候一定要多加注意，什么时候应该用 &amp;&amp; 做短路判断，什么时候使用 Optional Chaining 语法。</p><h3 id="在-git-仓库中使用-find-exec-sed-是很危险的"><a href="#在-git-仓库中使用-find-exec-sed-是很危险的" class="headerlink" title="在 git 仓库中使用 find . -exec sed 是很危险的"></a><a href="https://cmdcolin.github.io/posts/2022-05-04-findseddangerous">在 git 仓库中使用 find . -exec sed 是很危险的</a></h3><p>如果你想在 git 存储库中全局替换某个字符，那么你很有可能会遇到这个问题：<a href="https://stackoverflow.com/questions/6758963/find-and-replace-with-sed-in-directory-and-sub-directories">Find and replace with sed in directory and sub directories</a>，这是因为 find 命令没有忽略 .git 目录，运行该命令可能会导致 .git 目录损坏，所以更好的方式是使用 git ls-files：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files | xargs sed -i -e <span class="string">&#x27;s/apple/orange/g&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="凯文-·-凯利-70-岁生日写的-103-条人生忠告"><a href="#凯文-·-凯利-70-岁生日写的-103-条人生忠告" class="headerlink" title="凯文 · 凯利 70 岁生日写的 103 条人生忠告"></a><a href="https://justinyan.me/post/4911">凯文 · 凯利 70 岁生日写的 103 条人生忠告</a></h3><p>2022年4月28日，凯文·凯利（Kevin Kelly）在他的网站上发布了 70 岁生日的文章：<a href="https://kk.org/thetechnium/103-bits-of-advice-i-wish-i-had-known/">103 Bits of Advice I Wish I Had Known</a>，意为：103 条我希望早点知道的人生忠告。</p><p>此为中译版，非常推荐阅读，在这里摘录我个人认为有启发的几句：</p><ol><li>99%的时间里，真正关键的时刻就是此刻。</li><li>除了你以外，没有人会真的记得你拥有什么东西。</li><li>“但是”之前的话都是废话。</li><li>当你原谅其他人的时候，他们不一定会知道这件事，但你自己却会被治愈。原谅不是我们给予他人的东西；而是我们给自己的礼物。</li><li>教育的一半作用是学习哪些东西可以被忽略。</li><li>不要相信你认为你相信的一切。</li><li>为了丰厚的回报，请对你完全不感兴趣的事物保持好奇。</li><li>重复别人是一个很好的开始。重复你自己则是一个令人失望的终点。</li><li>如果你对于一个主题的意见可以根据你另一个主题的意见预测得出，那你可能陷入了某种意识形态的掌控。如果你认真审视你自己的意识，你的结论其实是无法预测的。</li></ol><h3 id="质疑和信任"><a href="#质疑和信任" class="headerlink" title="质疑和信任"></a><a href="https://adactio.com/journal/19021">质疑和信任</a></h3><p>这是 Jeremy 两篇文章，主要讨论了本文作者发现的一个奇怪现象，Web 开发者普遍存在这样一种心态：他们会在项目中优先选择安装 npm 依赖，然后隐式地引入了更多的依赖，也就相当于完全地信任这些 npm 包以及它们的作者。</p><p>但作者认为更应该直接使用浏览器的原生特性，比如 HTML 元素、CSS 功能和 JavaScript API，虽然它们并不总是完美的，并且在开发过程中需要额外花费很多心思，但原生的特性更值得被信赖。</p><p>而关于这个话题的讨论将由此展开，有些人认为之所以普遍存在这样一种心态，是因为浏览器兼容性的缘故，譬如在 MDN 的 <a href="https://insights.developer.mozilla.org/reports/mdn-web-developer-needs-assessment-2019.html#needs-assessment-segmented-view-of-the-needs-ranking">Overall Needs Ranking</a> 中排名前 5 的需求有 4 个属于兼容性问题，以前的 jQuery 和 Bootstrap 就是在这样的需求下产生，而现在这种情况已经逐步得到改善，越来越多人开始倾向于使用浏览器原生特性，而不是借助第三方库，总得来说，Web 开发者对浏览器的信任正在恢复。</p><p>最后提出了一个设计原则：如果可用，请默认使用浏览器原生功能，而不是第三方库。</p><h3 id="使用-Rust-开发单页应用程序"><a href="#使用-Rust-开发单页应用程序" class="headerlink" title="使用 Rust 开发单页应用程序"></a><a href="https://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/">使用 Rust 开发单页应用程序</a></h3><p>这是一篇使用 Rust 和  <a href="https://yew.rs/">Yew</a>  从 0 到 1 开发单页应用的文章，对于想要学习 Rust 和 Wasm 的同学可以看看。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://exercism.org/">Exercism</a>：一个学习编程语言的网站，非常有用。</li></ul><ul><li><a href="https://kill-the-newsletter.com/">Kill the Newsletter</a>：可将通过邮件订阅的 newsletters 转换为 RSS 源。</li></ul><ul><li><a href="https://wantwords.net/">汉语反向词典</a>：输入描述或词语，找到更多相似词语，帮助词穷的人更好地写作。</li></ul><ul><li><a href="https://ludwig.guru/">Ludwig</a>：和上面的差不多，不过是针对英文的。</li></ul><ul><li><a href="https://www.youtube.com/watch?v=0eKVizvYSUQ">How Google Search Works</a>：一段介绍 Google 搜索如何工作的五分钟短片。</li></ul><ul><li><a href="https://notefolio.net/">notefolio</a>：一个韩国的 UI 设计网站。</li></ul><ul><li><a href="https://natto.dev/">natto</a>：一个在线画 2D canvas 的工具。</li></ul><ul><li><a href="https://jimmysong.io/eng-practices/">谷歌工程实践</a>：顾名思义，Google 的通用工程实践，几乎涵盖所有语言和项目，内含 Code Review 以及代码编写指南。</li></ul><ul><li><a href="https://workers.cloudflare.com/">Cloudflare Workers</a>：Cloudflare 的云函数产品。</li></ul><ul><li><a href="https://github.com/StepfenShawn/Cantonese">Cantonese</a>：一个高中生写的粤语编程语言。</li></ul><ul><li><a href="https://github.com/mattpocock/ts-error-translator">TypeScript Error Translator</a>：将 TypeScript 错误翻译成英语，提供 VSCode 扩展。</li></ul><ul><li><a href="https://github.com/adriancooney/puppeteer-heap-snapshot">puppeteer-heap-snapshot</a>：一个用来获取和查询 Chome DevTools 堆快照的 CLI 工具。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第10期：你如何在网上找到可靠的信息？</title>
      <link href="//post/weekly-10.html"/>
      <url>//post/weekly-10.html</url>
      
        <content type="html"><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Git-2-36-亮点"><a href="#Git-2-36-亮点" class="headerlink" title="Git 2.36 亮点"></a><a href="https://github.blog/2022-04-18-highlights-from-git-2-36/">Git 2.36 亮点</a></h3><p>4 月 18 日，Git 正式发布 <a href="https://lore.kernel.org/git/xmqqh76qz791.fsf@gitster.g/T/#u">2.36 版本</a>，其中包含 96 个贡献者的改动，其中有 26 个新特性，在此罗列一些我比较感兴趣的新特性：</p><ol><li>git log –remerge-diff，更好地显示合并提交的差异，在此之前，如果我们查看一个具有合并冲突的提交差异时，输入的结果往往很难理解，而现在使用 <code>--remerge-diff</code> 则可以用 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-mergeconflictStyle">mergeconflictStyle</a> 的样式显示差异。</li><li>更严格的存储库权限检查，在 2.35 版本时，出现了<a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">两个安全漏洞</a>，此漏洞会影响在多用户计算机上工作的用户，这可能会导致某个用户在其他用户的存储库上执行任意命令，在 Git <a href="https://lore.kernel.org/git/xmqqv8veb5i6.fsf@gitster.g/">2.35.2</a> 版本中发布了安全补丁，总得来说就是 Git 更改了默认行为，防止这种情况的发生，我们也可以通过最新的 <a href="https://git-scm.com/docs/git-config/#Documentation/git-config.txt-safedirectory">safe.directory</a> 配置来有意义地绕过这个行为。</li><li>我们都知道 git bisect 这个命令可以用于二分查找，快速定位引入 BUG 的提交，同时它也可以通过指定一个可执行脚本来自动化这个过程，<code>git bisect run test.sh</code>，但在此之前，Git 并没有检查指定的文件是否为可执行脚本，导致 bisect 运行出错，该问题现在得到修复。</li><li>还有很多，感兴趣自行了解。</li></ol><h3 id="问HN：你如何在网上找到可靠的信息？"><a href="#问HN：你如何在网上找到可靠的信息？" class="headerlink" title="问HN：你如何在网上找到可靠的信息？"></a><a href="https://news.ycombinator.com/item?id=31107699">问HN：你如何在网上找到可靠的信息？</a></h3><p>在 hacker news 上看到的一个帖子，在信息爆炸的时代，我们如何在网上找到可靠的信息？总结出了一些自认为有用的观点：</p><ol><li>在信息源寻找「信息」，而不是「观点」，我们根据这些「信息」，得到我们自己的「观点」，同时以开放的心态去验证自己的「观点」，留意那些与你不同观点的人。</li><li>永远不要相信单一的信息来源，譬如不要只看国内的媒体：）</li><li>摆脱信息茧房，学习使用 RSS 订阅你感兴趣的内容，但是如何寻找有用的信息源也是一大难题。</li><li>尝试使用英文搜索你的问题，如果 Google 不好用，可以试试 <a href="https://teclis.com/">Teclis</a>。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="JavaScript-根据背景色显示对应的文字颜色"><a href="#JavaScript-根据背景色显示对应的文字颜色" class="headerlink" title="JavaScript 根据背景色显示对应的文字颜色"></a>JavaScript 根据背景色显示对应的文字颜色</h3><p>在 2022 的今天，dark 模式已经成为任何一个关注用户体验的应用不可或缺的功能，其中有一个很常见的需求就是根据背景颜色决定对应的文字颜色，这里就简单讲述一下我的实现思考。</p><p>首先我们需要知道任何颜色都有对应的灰度值的，得到颜色对应的灰度以后，就能知道该颜色是属于偏亮还是偏暗。</p><p>而获取灰度值的公式为：(0.299 * <em>r</em> + 0.587 * <em>g</em> + 0.114 * <em>b</em>) / 255</p><p>下面我们简单测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 rgb 获取灰度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGrayLevelFromRgb</span>(<span class="params">[r, g, b]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b) / <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>])) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0.299</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>])) <span class="comment">// 0.07058823529411765</span></span><br></pre></td></tr></table></figure><p>而我们只需要设定一个阈值，大于这个阈值的就属于 light，否则为 dark 即可。</p><p>这里我设定的阈值是 0.85，这个阈值具体是多少根据实际情况而定。</p><h3 id="在-Vim-中保存只读文件"><a href="#在-Vim-中保存只读文件" class="headerlink" title="在 Vim 中保存只读文件"></a>在 Vim 中保存只读文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w ! sudo tee % &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="Mac-在-dock-隐藏特定应用"><a href="#Mac-在-dock-隐藏特定应用" class="headerlink" title="Mac 在 dock 隐藏特定应用"></a>Mac 在 dock 隐藏特定应用</h3><p>有时候我们想要在 Mac 的 dock 中隐藏特定应用，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsappinfo setinfo -app XXX ApplicationType=UIElement</span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="怎么花两年时间面试一个人"><a href="#怎么花两年时间面试一个人" class="headerlink" title="怎么花两年时间面试一个人"></a><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎么花两年时间面试一个人</a></h3><p>这是一篇 11 年前的文章（2011），但在今天看来仍然非常有用，本文比较长，但我还是建议你阅读。</p><p>这里简单摘要一些本文内容，本文开宗明义地提出一个问题：<strong>招聘难，难于上青天</strong>。</p><p>这是因为：</p><ol><li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定前找到他们。</li><li>比较差的会投很多次简历，找不到工作的时间越多，投的简历越多，给整个 pool 带来很多噪音，top10% 的简历也许根本不算全部人的 top10%。</li></ol><p>公司招到靠谱的人非常重要，所以，<strong>招聘也许是一个公司决策当中最最重要的一个环节</strong>。</p><p>本文作者就根据他的一些经验，给出了一些关于如何做招聘的建议。</p><p>最后作者给出如何花两年时间面试一个人的方法，那就是看面试者平时的积累，推荐的方式是：书 + GitHub，这样足以相当两年左右的面试。</p><h3 id="你应该阅读学术计算机科学论文"><a href="#你应该阅读学术计算机科学论文" class="headerlink" title="你应该阅读学术计算机科学论文"></a><a href="https://stackoverflow.blog/2022/04/07/you-should-be-reading-academic-computer-science-papers/">你应该阅读学术计算机科学论文</a></h3><p>作为一名在职程序员，你需要不断地学习，你可以通过查看教程、文档、StackOverflow，以及你可以找到的任何帮助你更好地编写代码并保持最新技能的内容。但是，你试过深入研究计算机科学论文来提高你的编程能力吗？</p><p>虽然以上提到的教程可以帮助你立即编写代码，但阅读学术论文能够帮助你了解编程的来龙去脉，从空指针到对象，这些编程中大部分日常使用的功能都可以追溯到上世纪 60 年代，未来的创新一样建立在今天的研究之上。</p><p>所以，不妨试一下直接通过阅读论文去了解这些编程的知识，如果认为阅读论文还是太难，可以试一下观看这些演讲：<a href="https://www.youtube.com/c/PapersWeLove/videos">PapersWeLove - YouTube</a>。</p><h3 id="WebAssembly-使用JavaScript-垃圾回收器"><a href="#WebAssembly-使用JavaScript-垃圾回收器" class="headerlink" title="WebAssembly 使用JavaScript 垃圾回收器"></a><a href="https://jott.live/markdown/js_gc_in_wasm">WebAssembly 使用JavaScript 垃圾回收器</a></h3><p>我们知道，JavaScript 自带有垃圾回收机制，而 WebAssembly 却没有这个机制，因为它在比较底层的环境中运行，我们只能靠自己分配内存。</p><p>目前有一个关于 WebAssembly 的<a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md">提案</a>，涉及实现一个垃圾回收机制，但可惜还处于 Stage 2，仍没有浏览器实现该功能。</p><p>而本文作者发现了一个取巧的方式可以实现这个需求，那就是使用 WeakRefs，总的来说就是通过 WeakRefs 特性，自行实现一个永久循环的函数，去做垃圾回收的事情。</p><p>感兴趣可以阅读相关<a href="https://github.com/bwasti/web_assembly_experiments/tree/main/memory_management">实现代码</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://it-tools.tech/">IT Tools</a>：一个开发者工具，包含日常使用的功能，如 Base64 转换、QR Code 生成，URL 解析等，使用体验极佳。</li></ul><ul><li><a href="https://www.joshwcomeau.com/operator-lookup/">Operator Lookup</a>：输入一个 JavaScript 的操作符（e.g. +、=&gt;），将会解释该操作符的作用，对初学者非常有用。</li></ul><ul><li><a href="https://gitexplorer.com/">Git Explorer</a>：通过的问答选择的方式寻找你想要的 Git 命令，从此使用 Git 命令不再求人。</li></ul><ul><li><a href="https://sourabhbajaj.com/mac-setup">macOS Setup Guide</a>：本指南介绍了在新 Mac 上设置开发环境的基础知识。旨在供所有人用作设置环境或安装语言/库的指南。</li></ul><ul><li><a href="https://tiny-helpers.dev/">Tiny Helpers</a>：Web 开发者的工具集合。</li></ul><ul><li><a href="https://iep.utm.edu/">Internet Encyclopedia of Philosophy</a>：互联网哲学百科全书，有很多关于形而上的哲学论文。</li></ul><ul><li><a href="https://stage.so/">Stage</a>：一个设计工具。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第9期：Web 发展中的 100 个重大事件</title>
      <link href="//post/weekly-09.html"/>
      <url>//post/weekly-09.html</url>
      
        <content type="html"><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Web-发展中的-100-个重大事件"><a href="#Web-发展中的-100-个重大事件" class="headerlink" title="Web 发展中的 100 个重大事件"></a><a href="https://developer.chrome.com/100/">Web 发展中的 100 个重大事件</a></h3><p>自 2008 年 Chrome 浏览器正式发布以来，到现在 Chrome 已经发展到第 100 个版本了，为此还开发了一个网站，该网站展示了从 2008 年 Chrome 浏览器发布以来的 100 个对于 Web 发展的重大里程碑事件，譬如 GitHub 一周年、Node.js 发布、Flexbox 提案等，有兴趣可以看看。</p><h3 id="我们如何失去-54K-的-GitHub-stars"><a href="#我们如何失去-54K-的-GitHub-stars" class="headerlink" title="我们如何失去 54K 的 GitHub stars"></a><a href="https://httpie.io/blog/stardust">我们如何失去 54K 的 GitHub stars</a></h3><p>相信大家都知道 <a href="https://github.com/httpie/httpie">httpie</a> 这个命令行工具，近日，由于维护者误操作将仓库设置为私有仓库，导致 54K 的 stars 被清零，经与 GitHub 官方沟通后，被告知无法恢复，截止今日（2022-04-17）已经重新涨回 12.7K。</p><p>httpie 在吐槽之余，还顺便教了一下 GitHub 做产品：</p><ol><li>UI/UX 设计，在设置为私有仓库时，告知用户会损失哪些数据。</li><li>数据库的软删除设计。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chromium-的-DNS-缓存时间"><a href="#Chromium-的-DNS-缓存时间" class="headerlink" title="Chromium 的 DNS 缓存时间"></a><a href="https://textslashplain.com/2022/03/31/chromiums-dns-cache/">Chromium 的 DNS 缓存时间</a></h3><p>Chromium 的 DNS 缓存时间大概在一分钟左右：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default TTL for successful resolutions with ProcTask.</span></span><br><span class="line"><span class="keyword">const</span> unsigned kCacheEntryTTLSeconds = <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>DNS 的解析过程比较复杂，有兴趣可以看这个：<a href="https://source.chromium.org/chromium/chromium/src/+/main:net/dns/README.md;drc=761feeebc0214d55f2cff89f5904f5521ab02610">Chrome Host Resolution</a>，或者简单看下这两张图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png" alt="img"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png" alt="img"></p><p>上图源自本站一篇旧文：<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p><p>如果想要查看浏览器 DNS 配置的详细信息，可以按照以下流程：</p><ol><li>打开：chrome://net-export，开始记录，打开任意一个网站发起请求，导出 JSON 文件。</li><li>在 <a href="https://netlog-viewer.appspot.com/#import">NetLog Viewer</a> 导入查看，DNS 栏目。</li></ol><h3 id="ECMAScript-提案-通过复制改变数组"><a href="#ECMAScript-提案-通过复制改变数组" class="headerlink" title="ECMAScript 提案 - 通过复制改变数组"></a><a href="https://2ality.com/2022/04/change-array-by-copy.html">ECMAScript 提案 - 通过复制改变数组</a></h3><p>这篇博客文章描述了 Robin Ricard 和 Ashley Claymore 提出的 ECMAScript 提案 <a href="https://github.com/tc39/proposal-change-array-by-copy">“Change Array by copy”</a>。它为 Array 和 TypedArray 提出了四种新方法：</p><ul><li><code>.toReversed()</code></li><li><code>.toSorted()</code></li><li><code>.toSpliced()</code></li><li><code>.with()</code></li></ul><p>大多数 Array 方法是无副作用的 – 它们不会更改调用它们的数组，例如：<code>filter</code>、<code>map</code> 等。</p><p>但也有副作用的方法，例如：<code>reverse</code>、<code>sort</code>、<code>splice</code>。</p><p>因此新加入的三个方法为上述三种方法提供了无副作用版本，除此之外还引入了一个新方法：<code>with。</code></p><p>它是下面这段代码的无副作用版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[index] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line">arr.with(index, value) <span class="comment">// 返回一个新的 array</span></span><br></pre></td></tr></table></figure><h3 id="CSS-父选择器-has"><a href="#CSS-父选择器-has" class="headerlink" title="CSS 父选择器 - :has()"></a><a href="https://ishadeed.com/article/css-has-parent-selector/">CSS 父选择器 - :has()</a></h3><p>在以前， 我们无法根据父元素是否包含某个子元素时决定父元素的样式。</p><p>譬如，我们希望在 <code>.card</code> 有子元素 <code>img</code> 时设置特定样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;a.jpg&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>card text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>:has()</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:has</span>(<span class="selector-tag">img</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>:has()</code> 不止可以用于检查父元素是否包含某个子元素，还可以检查后面的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 检查 <span class="selector-tag">h2</span> 后面跟着 <span class="selector-tag">p</span></span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:has</span>(+ <span class="selector-tag">p</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>但遗憾的是，截止目前（2022-04-18）只有 Safari 15.4和 Chrome Canary 支持该特性，详见 <a href="https://caniuse.com/css-has">caniuse</a>。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="React-18-允许组件渲染-Undefined"><a href="#React-18-允许组件渲染-Undefined" class="headerlink" title="React 18 允许组件渲染 Undefined"></a><a href="https://blog.saeloun.com/2022/04/14/react-18-allows-components-to-render-undfined.html">React 18 允许组件渲染 Undefined</a></h3><p>在 React 18 之前，如果我们这样渲染了一个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Circle <span class="keyword">from</span> <span class="string">&#x27;./Circle&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Square <span class="keyword">from</span> <span class="string">&#x27;./Square&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">&#123;type&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Circle</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;square&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Shape;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) : <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> <span class="attr">type</span>=<span class="string">&quot;rectangle&quot;</span>/&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Shape 组件返回 Undefined，我们将得到以下报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Shape(...): Nothing was returned from render. This usually means a <span class="built_in">return</span> statement is missing. Or, to render nothing, <span class="built_in">return</span> null.</span><br></pre></td></tr></table></figure><p>为了修复报错，我们必须显式返回 <code>null</code>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import Circle from &#x27;./Circle&#x27;;</span><br><span class="line">import Square from &#x27;./Square&#x27;;</span><br><span class="line"></span><br><span class="line">function Shape(&#123;type&#125;) &#123;</span><br><span class="line">  if(type <span class="comment">=== &#x27;circle&#x27;) &#123;</span></span><br><span class="line">    return &lt;Circle /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type <span class="comment">=== &#x27;square&#x27;) &#123;</span></span><br><span class="line">    return &lt;Square /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ return null;</span></span><br><span class="line">&#125;</span><br><span class="line">export default Shape;</span><br></pre></td></tr></table></figure><p>但随着 React 18 的发布，即便组件未返回任何内容，也不会引发运行时错误。</p><p>基于以下三点原因，使 React 18 作出此改动：</p><ol><li><p>与其抛出错误，不如使用 Lint 工具</p><ul><li>渲染 Undefined 报错这个机制是在 2017 年加入的，当时类型系统和 Lint 工具还没开始流行，但现在我们完全可以使用 ESLint 等工具帮我们处理这些类型的错误。</li></ul></li><li><p>很难创建正确的类型，考虑以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx </span></span><br><span class="line"><span class="keyword">const</span> Shape = (&#123; children &#125;: ComponentType): <span class="function"><span class="params">ComponentType</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>): <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须在 <code>ComponentType</code> 类型将 Undefined 排除在外，但更好的解决方法就是允许渲染 Undefined。</p></li><li><p>保持一致的行为</p><ul><li>因为最近 Suspense 的 fallbacks <a href="https://github.com/reactwg/react-18/discussions/72">允许渲染 Undefined</a>，所以保持一致。</li></ul></li></ol><h3 id="JavaScript-中-RegExp-与-String-replace-的神奇特性"><a href="#JavaScript-中-RegExp-与-String-replace-的神奇特性" class="headerlink" title="JavaScript 中 RegExp 与 String.replace 的神奇特性"></a><a href="https://blog.huli.tw/2022/04/14/javascript-string-regexp-magic/">JavaScript 中 RegExp 与 String.replace 的神奇特性</a></h3><p>下面这段代码的执行结果是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;example.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// ???</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str2)) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>相信很多人都会认为两个都是 true，但答案是 true 和 false，即便你写成这样，第二个输出结果也是 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这是因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#%E5%BD%93%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E6%A0%87%E5%BF%97%E7%9A%84%E6%AD%A3%E5%88%99%E4%BD%BF%E7%94%A8test">RegExp 是有副作用的</a>，以下为 MDN 原话：</p><blockquote><p>如果正则表达式设置了全局标志，<code>test() </code>的执行会改变正则表达式  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>lastIndex</code></a> 属性。连续地执行<code>test()</code>方法，后续的执行将会从 lastIndex 处开始匹配字符串，(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec()</code></a> 同样改变正则本身的 <code>lastIndex 属性值</code>).</p></blockquote><p>以下代码证明了这点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/foo/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is at 0</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is now at 3</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>再来看另外一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;4ark&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="regexp">/\w+/</span>.test(str)</span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们还能拿得到 str 之前的值吗？</span></span><br></pre></td></tr></table></figure><p>答案是可以的，因为 RegExp 上有一个神奇的属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/input#%E8%AF%AD%E6%B3%95">RegExp.input</a>。</p><p>除此之外，还有这些：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch">RegExp.lastMatch</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastParen">RegExp.lastParen</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/leftContext">RegExp.leftContext</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/rightContext">RegExp.rightContext</a></li></ol><p>但是需要注意，这些特性是非标准的，请尽量不要在生产环境中使用它！</p><p>另外原文还有关于 String.replace 的神奇特性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">使用字符串作为参数</a>，简单来说就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123&#123;n&#125;456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 123A456</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123123A456，原本 &#123;n&#125; 的地方变成 123A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$`A&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456A456，原本 &#123;n&#125; 的地方变成 456A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$&#x27;A&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="在用户离开页面时可靠地发送-HTTP-请求"><a href="#在用户离开页面时可靠地发送-HTTP-请求" class="headerlink" title="在用户离开页面时可靠地发送 HTTP 请求"></a><a href="https://css-tricks.com/send-an-http-request-on-page-exit/">在用户离开页面时可靠地发送 HTTP 请求</a></h3><p>我们希望在用户离开当前页面时发送一个 HTTP 请求，这是一个非常常见的需求，譬如页面埋点等。</p><p>但根据 <a href="https://developer.chrome.com/blog/page-lifecycle-api/">Chrome 页面的生命周期</a>显示，在页面终止运行时，无法保证进程内的请求会成功，因此，在离开页面时发送请求可能并不可靠，如果我们依赖这个行为，则会出现潜在的重大问题。</p><p>通过下图可看出在页面离开时，请求会被取消掉：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204181217957.gif" alt="在“网络”选项卡中查看 HTTP 请求失败"></p><p>为什么请求会被取消呢？下面是 Chrome 对于页面终止生命周期（Terminated）的描述：</p><blockquote><p>A page is in the <em>terminated</em> state once it has started being unloaded and cleared from memory by the browser. No <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task">new tasks</a> can start in this state, and in-progress tasks may be killed if they run too long.</p><p><strong>Possible previous states:</strong><br><a href="https://developer.chrome.com/blog/page-lifecycle-api/#state-hidden">hidden</a> <em>(via the <a href="https://developer.chrome.com/blog/page-lifecycle-api/#event-pagehide"><code>pagehide</code></a> event)</em></p><p><strong>Possible next states:</strong><br>NONE</p></blockquote><p>简单来说就是一个页面被卸载并从内存清除时，它就处于终止状态，在这种状态下，没有新的任务可以启动，正在运行的任务如果运行时间过长，则有可能会被 killed 掉。</p><p>那我们应该如何解决这个问题呢？有下面几种方案：</p><ol><li>阻塞页面跳转，直到请求被响应：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for response to come back...</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;/log&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attr">some</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...and THEN navigate away.</span></span><br><span class="line">   <span class="built_in">window</span>.location = e.target.href;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但这样也有很明显的缺点，1）损害用户体验；2）没有包含所有页面离开行为，例如关闭浏览器 tab。</p><ol start="2"><li>使用 Fetch 的 <a href="https://fetch.spec.whatwg.org/#request-keepalive-flag">keepalive</a> 选项，使请求继续保留，即便页面已终止。</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/some-other-page&quot; id=&quot;link&quot;&gt;Go to Page&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.getElementById(&#x27;link&#x27;).addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;</span><br><span class="line">    fetch(&quot;/log&quot;, &#123;</span><br><span class="line">      method: &quot;POST&quot;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">      &#125;, </span><br><span class="line">      body: JSON.stringify(&#123;</span><br><span class="line">        some: &quot;data&quot;</span><br><span class="line">      &#125;), </span><br><span class="line"><span class="addition">+     keepalive: true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <a href="https://w3c.github.io/beacon/#sendbeacon-method">Navigator.sendBeacon()</a> 方法</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/some-other-page&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">some</span>: <span class="string">&quot;data&quot;</span> &#125;)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span> &#125;);</span></span><br><span class="line"><span class="javascript">    navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, blob));</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 a 标签的 <a href="https://css-tricks.com/the-ping-attribute-on-anchor-links/">ping 属性</a></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:3000/other&quot;</span> <span class="attr">ping</span>=<span class="string">&quot;http://localhost:3000/log&quot;</span>&gt;</span></span><br><span class="line">  Go to Other Page</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击该链接后，它会自动发出一个 POST 请求，并将 href 属性放在请求头中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers: &#123;</span><br><span class="line">  &#x27;ping-from&#x27;: &#x27;http:<span class="comment">//localhost:3000/&#x27;,</span></span><br><span class="line">  &#x27;ping-to&#x27;: &#x27;http:<span class="comment">//localhost:3000/other&#x27;</span></span><br><span class="line">  &#x27;content-type&#x27;: &#x27;text/ping&#x27;</span><br><span class="line">  <span class="comment">// ...other headers</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但有如下限制：</p><ol><li>只能在 a 标签上使用</li><li>浏览器支持很好，但 Firefox 除外 :(</li><li>无法自定义发送的数据…</li></ol><p>如果选择使用哪个方法呢？文中还给出了一个很好的提示：</p><ul><li>以下情况，推荐使用 fetch + keepalive<ul><li>需要自定义 header 和请求内容</li><li>希望发出 GET，而不只是 POST</li><li>需要支持较旧的浏览器，并且已有 fetch 的 polyfill。</li></ul></li><li>以下情况，推荐使用 <code>sendBeacon()</code><ul><li>只是简单的请求，不需要太多的自定义内容</li><li>喜欢更干净、更优雅的 API。</li><li>您希望保证您的请求不会与应用程序中发送的其它高优先级的请求竞争。</li></ul></li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/Troland/how-javascript-works">Troland/how-javascript-works</a>：本文是翻译介绍 JavaScript 的工作原理的，该系列原文还在更新中，原文见<a href="https://blog.sessionstack.com/tagged/tutorial">这里</a>。此为<a href="https://xcoder.in/">死月</a>翻译的中文版。</li></ul><ul><li><a href="https://webaim.org/projects/million/">The WebAIM Million</a> ：2022年关于前 100 万个主页的可访问性报告。</li></ul><ul><li><a href="https://turborepo.org/">Turborepo</a>：Turborepo 是一个针对 JavaScript 和 TypeScript 代码库的高性能构建系统。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第8期：阅读 ECMAScript 规范</title>
      <link href="//post/weekly-08.html"/>
      <url>//post/weekly-08.html</url>
      
        <content type="html"><![CDATA[<h2 id="阅读-ECMAScript-规范"><a href="#阅读-ECMAScript-规范" class="headerlink" title="阅读 ECMAScript 规范"></a>阅读 ECMAScript 规范</h2><p>有必要先向部分初学者解释一下 JavaScript 和 ECMAScript 的区别，最开始 ECMA 仅是 European Computer Manufacturers Association （欧洲计算机制造商协会）的首字母缩写，不过随着计算机的国际化，组织的标准牵涉到很多其他国家，因此这个组织已经改名为 Ecma 国际，所以现在的 Ecma 本身就是一个名字，不再是首字母缩写。</p><p>ECMAScript 与 JavaScript 其实就是同一个东西，只是因为 JavaScript 这个名称已经被 Sun 公司注册了商标，并且不开放给 Ecma 协会使用，所以 JavaScript 的标准只能叫做 ECMAScript，而 JavaScript 可以看做是 ECMAScript 规范的一种实现。</p><p>我们为什么要学习阅读 ECMAScript 规范呢？如果你只是一名 JavaScript 的初学者，你确实没有太大的必要去阅读 ECMAScript 规范，只需要通过阅读 MDN 文档就能学习如何编写 JavaScript，但随着 JavaScript 水平的提升，我们会越来越不满足于使用，我们会想要知道更多内部的细节，然而并不是所有的 JavaScript 细节都会在 MDN 文档上说明。</p><p>下面我就举个在工作中真实遇到的场景，以此阐述我们为什么需要阅读 ECMAScript 规范。</p><p>考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">300</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">200</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="number">50.5</span>: <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得这段代码的输出顺序是什么呢？答案是：<code>100,200,300,50.5</code>。</p><p>这是为什么呢？</p><p>从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a> 的 MDN 文档中，无法得到我们想要的答案，这时候就只能通过阅读 ECMAScript 规范：</p><p> <img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080105185.png" alt="image-20220408010524823"></p><p>通过以上信息我们得知，JavaScript 在遍历一个对象的时候，它将按照如下规则执行：</p><ol><li>创建一个空的列表用于存放 keys</li><li>将所有<strong>合法的数组索引</strong>按升序的顺序存入</li><li>将所有<strong>字符串类型索引</strong>按属性创建时间以升序的顺序存入</li><li>将所有 <strong><code>Symbol</code> 类型索引</strong>按属性创建时间以升序的顺序存入</li><li>返回 keys</li></ol><p>PS：当然 for…in 是不会返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> 类型的属性的，需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>。</p><p>以上源自我遇到的一个真实案例，详见<a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a>。</p><p>相信大家都已经非常清楚学习阅读 ECMAScript 规范的重要性，可 ECMAScript 规范也不是这么容易阅读的，所以这里提供了一些文章，帮助你快速学习阅读 ECMAScript 规范：</p><ul><li><a href="https://timothygu.me/es-howto/#example-string-prototype-substring">How to Read the ECMAScript Specification</a></li><li><a href="https://v8.dev/blog/tags/understanding-ecmascript">Understanding the ECMAScript spec</a></li><li><a href="https://blog.huli.tw/2022/01/30/how-to-validate-javascript-knowledge/">你知道的 JavaScript 知識都有可能是錯的</a></li></ul><p>总之，与本文一样带着问题去阅读，往往能够事半功倍。</p><h2 id="《编程语言的设计与实现》——-松本行弘"><a href="#《编程语言的设计与实现》——-松本行弘" class="headerlink" title="《编程语言的设计与实现》—— 松本行弘"></a>《编程语言的设计与实现》—— 松本行弘</h2><p>此书是 Ruby 语言的创造者 —— 松本行宏在《日经Linux》杂志上的连载整合而成，主要介绍了新语言 Streem 的设计与实现过程。作者从设计 Streem 这门新语言的动机开始讲起，由浅入深，详细介绍了新语言开发中的各个环节，以及语言设计上的纠结与取舍，其中也不乏对其他编程语言的调查与思考，向读者展示了创建编程语言的乐趣。</p><p>笔者现在刚看完第二章，不过也可以谈谈我的阅读感悟：作为一名野生前端，我对编译原理可谓是一窍不通，顶多也就写个 Babel 小玩具的水平，像《编译原理》这种专业书，我是连前十页都啃不下去，好在日系书籍有一个很大的特点就是：<strong>浅显易懂</strong>，此书也不例外，在前两章就带领读者如何通过 lex 进行词法解析，然后通过 yacc 进行语法解析，这过程还会将编译原理中的一些知识带出来，譬如 BNF（巴科斯范式）、窥孔优化等。</p><p>除了编译原理以外，我们还可以通过本书学习如何站在语言设计者的角度去思考语言的特性，为什么要这么设计，从而使我们的视野更加开阔，所以建议每一位开发者都阅读本书（对我这种野生程序员尤为重要）。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="CSS-属性使用次数排行榜"><a href="#CSS-属性使用次数排行榜" class="headerlink" title="CSS 属性使用次数排行榜"></a><a href="https://chromestatus.com/metrics/css/popularity">CSS 属性使用次数排行榜</a></h3><p>Chrome 使用<a href="https://source.chromium.org/chromium/chromium/src/+/main:tools/metrics/histograms/enums.xml">匿名使用统计数据</a>计算每个在 Chrome 浏览器加载的页面中 CSS 属性出现的次数，数据的实时性大概在 24 小时之内。</p><p>以下截取部分排名靠前的 CSS 属性：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080001598.png" alt="image-20220408000057438"></p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="为什么-HTTP-301-后会把-POST-转为-GET？"><a href="#为什么-HTTP-301-后会把-POST-转为-GET？" class="headerlink" title="为什么 HTTP 301 后会把 POST 转为 GET？"></a><a href="https://zh.wikipedia.org/wiki/HTTP_301">为什么 HTTP 301 后会把 POST 转为 GET？</a></h3><p>根据 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2">RFC 7231, section 6.4.2: 301 永久重定向</a> 指出：</p><blockquote><p>Note: For historical reasons, a user agent MAY change the request<br> method from POST to GET for the subsequent request.  If this<br> behavior is undesired, the 307 (Temporary Redirect) status code<br> can be used instead.</p></blockquote><p>简而言之就是因为历史原因，当某些 HTTP/1.0 客户端收到该状态码时，可能会将 POST 方法改为 GET 方法，继续向新地址发出请求，这是错误的实现——故而后续标准引入了 <a href="https://zh.wikipedia.org/wiki/HTTP_307">HTTP 307</a>。</p><p>所以最好只在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a> 方法时使用 301，其他情况使用 307 或者 308 来替代 301。</p><h3 id="JavaScript-的数字安全范围"><a href="#JavaScript-的数字安全范围" class="headerlink" title="JavaScript 的数字安全范围"></a><a href="https://blog.huli.tw/2022/03/14/javascript-number/">JavaScript 的数字安全范围</a></h3><p>你会如何解释这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们知道 JavaScript 的数字是用 64 bit 來存，而且遵循的规格是 IEEE 754-2019，既然用 64 bit 来存，那可以表示的数字自然是有限的。</p><p>我们可以用 <code>Number.MAX_SAFE_INTEGER</code> 表示 JavaScript 最大正整数的安全范围，也就是 <code>2^53 - 1</code> = <code>9007199254740991</code>。</p><p>这里所说的安全指的是：<strong>能够准确区分两个不相同的值</strong>，例如 <code>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2</code> 这在 JavaScript 上是成立的，但它在数学上是错误的，我们可以使用 <code>Number.isSafeInteger()</code> 来判断一个数字是否是一个「安全整数」。</p><p>需要注意的是，最大的安全范围不代表 JavaScript 只能存储 <code>Number.MAX_SAFE_INTEGER</code> 这么大的数字，其实我们最大可以存储 <code>Number.MAX_VALUE</code> 也就是 1.7976931348623157e+308 ，只是它不在安全范围之内罢了。</p><p>总之，对于一些比较大的数字（譬如 uuid 这类），优先考虑是否使用 String 类型，如果一定要数字类型，可以了解下 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>。</p><h3 id="为什么「Enter键」要被翻译为「回车键」？"><a href="#为什么「Enter键」要被翻译为「回车键」？" class="headerlink" title="为什么「Enter键」要被翻译为「回车键」？"></a><a href="https://haohailong.net/2012/why-enter-key-is-huiche-in-chinese">为什么「Enter键」要被翻译为「回车键」？</a></h3><p>其实「回车」并不是 “Enter” 的翻译，而是 “return” 的翻译。这个 return 其实指的是 “↵+Enter” 中箭头的意思，换言之，Enter 并不是“↵”的一个解释，严格讲 “Enter” 和“↵”是这个键的两种不同的名称，也即两个不同的用途。</p><p>之所以会被翻译成「回车」，是因为现代电脑键盘是从过去的打字机上继承过来的，在过去的机械打字机上有个部件叫「字车」，每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而 “Return” 键最早就是这个作用，因此被翻译为「回车」。</p><p>有兴趣可以看看这个视频：</p><iframe src="//player.bilibili.com/player.html?aid=591562931&bvid=BV1uq4y1k7EM&cid=440002269&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="DeepL-Api-设计中的欺骗战术"><a href="#DeepL-Api-设计中的欺骗战术" class="headerlink" title="DeepL Api 设计中的欺骗战术"></a><a href="https://zu1k.com/posts/thinking/deception-tactics-in-deepl-api-design/">DeepL Api 设计中的欺骗战术</a></h3><p>本文作者通过逆向 DeepL 的 Windows 客户端（C#），破解了 DeepL 如何实现接口防滥用。</p><p>直接说结论，其实 DeepL 并没有使用一些常规的方法（譬如 token、签名等）去实现接口防滥用，而是通过两个非常取巧的方法去把开发者绕晕：</p><ol><li>timestamp 参数并不是一个真实的时间戳，而是通过时间戳和源文本的长度进行伪造的，公式是：<code>ts - ts % i_count + i_count</code>，由于与真实的时间戳仅有毫秒部分的差别，一般人无法直接看出端倪。</li><li>id 参数就是一个随机数，只不过后续的请求会在此基础上 + 1，并且这个 id 会决定文本中一个小小的、微不足道的空格。但由于我们通过拿到结果后都会先对 JSON 进行一下格式化，所以很容易忽略这种细节。</li></ol><p>如果不是逆向源代码，相信一般人很难发现这两点细节，不得不感叹 DeepL 工程师的脑洞。</p><h3 id="Cloudflare-如何将网站加载时间缩短-30"><a href="#Cloudflare-如何将网站加载时间缩短-30" class="headerlink" title="Cloudflare 如何将网站加载时间缩短 30%"></a><a href="https://blog.cloudflare.com/early-hints/">Cloudflare 如何将网站加载时间缩短 30%</a></h3><p>本文介绍 Cloudflare 在 2021 年发布的一个新特性：Early Hints，准确来说它是一个 <a href="https://httpwg.org/specs/rfc8297.html">Web 标准</a>，它定义了一个新的状态码 103。</p><p>其最核心的功能是：在服务器响应 200 时，先向客户端响应 103，其响应内容包含这个网页所需呈现内容的资源提示，客户端可利用此提示加载页面速度，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204111949351.png" alt="img"></p><p>在上面提到的 <a href="https://httpwg.org/specs/rfc8297.html">RFC</a> 中可看到 HTTP 103 的响应大概长这样（其中可能会有多个 103 响应）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client request:</span><br><span class="line"></span><br><span class="line">  GET / HTTP/1.1</span><br><span class="line">  Host: example.com</span><br><span class="line"></span><br><span class="line">Server response:</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 103 Early Hints</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 200 OK</span><br><span class="line">  Date: Fri, 26 May 2017 10:02:11 GMT</span><br><span class="line">  Content-Length: 1234</span><br><span class="line">  Content-Type: text/html; charset=utf-8</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  &lt;!doctype html&gt;</span><br><span class="line">  [... rest of the response body is omitted from the example ...]</span><br></pre></td></tr></table></figure><p>我们可以在 Chrome 94 及更新版本使用该特性，关于更多内容可见：<a href="https://blog.cloudflare.com/early-hints/">early-hints</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://cn.history.js.org/index.html">JavaScript 二十年</a>：这本书纪录了从 1995 年到 2015 年这二十年的 JavaScript 历史，看完它会对 JavaScript 有不同的体会（还会知道很多冷知识），此为中译版，原版地址：<a href="http://wirfs-brock.com/allen/posts/866">JavaScript: The First 20 Years</a>。</li></ul><ul><li><a href="https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#readme">js-quirks</a>：关于 JavaScript 的一些怪癖语法说明，对于想要实现 JavaScript 解析器的同学很有帮助和启发。</li></ul><ul><li><a href="https://moonvy.com/">Moonvy 月维</a>：探索「设计生产力」之道，与你一起， 创造设计师与开发者的必备工具。</li></ul><ul><li><a href="https://quokkajs.com/">QUOKKA</a>：<em>Quokka</em> 是一个调试工具，可以为您正在编写的代码提供实时反馈（可惜大部分功能都要收费。</li></ul><ul><li><a href="https://www.iconfinder.com/p/free-ukraine-icons">Free Ukraine icons</a>：一些与乌克兰战争有关的免费 icon 图标。</li></ul><ul><li><a href="https://express.adobe.com/zh-Hans-CN/sp/">Adobe Creative Cloud Express</a>：Adobe 新推出的一个设计工具，可提供快速「去除背景」、「转换为 GIF」、「合并 PDF」以及更多高级操作。</li></ul><ul><li><a href="https://uxtools.co/challenges">UX Design Challenges | UX Tools</a>：一些 UX 的挑战，帮助你学习如何提高产品的用户体验。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第7期：使用新的周刊模板</title>
      <link href="//post/weekly-07.html"/>
      <url>//post/weekly-07.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用新的周刊模板"><a href="#使用新的周刊模板" class="headerlink" title="使用新的周刊模板"></a>使用新的周刊模板</h2><p>在本期开始采用新的周刊模板，新增了两个模块：</p><ul><li>本周见闻：一些有趣的事情、观点，与「分享文章」最大的区别在于它们通常是一些比较简短的信息。</li><li>tips：一些有用的技巧，可以帮助你提高工作效率。</li></ul><p>如此，周刊内容就显得更加丰富，可以分享更多元的信息了。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="React-v18-正式发布"><a href="#React-v18-正式发布" class="headerlink" title="React v18 正式发布"></a><a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18 正式发布</a></h3><ol><li><p><strong>自动批处理</strong></p><p>批处理是指 React 将多个状态更新合并到单个 re-render 中以获得更好的性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在之前: 只有 React 事件是批处理的。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 将渲染两次，每次状态更新一次（没有批处理的情况）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在之后: setTimeout、Promise、原生事件这类异步操作都将合并到一次 re-render 中。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 只会在最后重新渲染一次（这就是批处理！）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>了解更多：<a href="https://github.com/reactwg/react-18/discussions/21">https://github.com/reactwg/react-18/discussions/21</a></p></li><li><p><strong>Transitions</strong></p><p>这是 React 中的一个新概念，用于区分紧急和非紧急更新（过渡更新）。</p><ul><li><strong>紧急更新</strong>：反映了直接交互，如输入、单击、按下等。</li><li><strong>过渡更新</strong>：将 UI 从一个视图转换为另一个视图。</li></ul><p>通常，为了获得最佳用户体验，单个用户输入应同时导致紧急更新和非紧急更新。您可以在输入事件中使用 startTransition API 来通知 React 哪些更新是紧急的，哪些是过渡的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;startTransition&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急，显示输入的内容</span></span><br><span class="line">setInputValue(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部的任何状态更新标记为转换</span></span><br><span class="line">startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 过渡：显示结果</span></span><br><span class="line">  setSearchQuery(input);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>startTransition 中包含的更新操作都将作为过渡更新进行处理，如果出现更紧急的更新，则会打断之前的过渡更新，只渲染最新的。</p><p>了解更多：<a href="https://reactjs.org/docs/react-api.html#transitions">https://reactjs.org/docs/react-api.html#transitions</a></p></li></ol><ol start="4"><li><p><strong>Hooks</strong></p><ol><li><a href="https://reactjs.org/docs/hooks-reference.html#useid">useId</a>：用于在客户端和服务器上生成唯一 ID</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usetransition">useTransition</a>：标记为过渡性更新。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue">useDeferredValue</a>：允许您延迟重新渲染树的非紧急部分，类似于防抖。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore">useSyncExternalStore</a>：允许外部存储通过强制对存储的更新为同步来支持并发读取。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#useinsertioneffect">useInsertionEffect</a>：允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。</li></ol></li></ol><p>关于 React v18 更多新功能请查看：<a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18.0 – React Blog </a></p><h3 id="CSS-新提案-共享元素转场效果"><a href="#CSS-新提案-共享元素转场效果" class="headerlink" title="CSS 新提案 - 共享元素转场效果"></a><a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">CSS 新提案 - 共享元素转场效果</a></h3><p>CSS 的一个新提案，为切换页面提供平滑加载动画，无论是 SPA 还是 MPA 都适用，效果如下：</p><p><video src="https://user-images.githubusercontent.com/93594/141100217-ba1fa157-cd79-4a9d-b3b4-67484d3c7dbf.mp4" controls auto-play="true" ></video></p><p>关于更多可了解：<a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">shared-element-transitions/explainer.md</a></p><h3 id="尊重用户的默认字体大小"><a href="#尊重用户的默认字体大小" class="headerlink" title="尊重用户的默认字体大小"></a><a href="https://www.huy.rocks/everyday/03-27-2022-typography-respect-user-s-default-font-size">尊重用户的默认字体大小</a></h3><p>在处理文本和 CSS 时，我们通常都会默认设置一个固定的字体大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在大部分 WEB 网站都没有问题，但是对于内容网站（如新闻网站、论坛、博客等），这可能会导致可用性问题，因为每个人设置的默认字体大小有可能不一样，比如在 Chrome 就可以通过 chrome://settings/fonts 更改字体大小，所以更好的做法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在内部元素采用 <code>em</code> 和 <code>rem</code>。</p><h3 id="TypeScript-的-Web-API-类型声明是怎么来的？"><a href="#TypeScript-的-Web-API-类型声明是怎么来的？" class="headerlink" title="TypeScript 的 Web API 类型声明是怎么来的？"></a><a href="https://www.huy.rocks/everyday/03-29-2022-typescript-a-note-about-lib-dom-d-ts">TypeScript 的 Web API 类型声明是怎么来的？</a></h3><p>在 TypeScript 中，所有的 Web API 类型声明都在 <a href="https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts">lib.dom.d.ts</a> 中实现，一共多达 18877 行，它当然不是手动编写的，而是利用 <a href="https://github.com/w3c/webref">webref</a> 进行生成机器可读的 Web 标准，每 6 小时自动生成一次，然后利用 <a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/">TypeScript-DOM-lib-generator</a> 自动生成 lib.dom.d.ts。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="使用-Lighthouse-展示网站的-JavaScript-依赖关系"><a href="#使用-Lighthouse-展示网站的-JavaScript-依赖关系" class="headerlink" title="使用 Lighthouse 展示网站的 JavaScript 依赖关系"></a><a href="https://sia.codes/posts/lighthouse-treemap/">使用 Lighthouse 展示网站的 JavaScript 依赖关系</a></h3><p>熟悉 Webpack 的前端同学应该知道有一个插件叫做 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack-bundle-analyzer</a>，它用于展示每个 npm 包的体积。</p><p>现在我们也可以通过 Lighthouse Treemap 查看网站的 JavaScript 依赖关系和文件体积，效果如下：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041746785.jpg"></p><p>使用方法：在 Chrome 使用 Lighthouse 检查，然后在结果页中点击「View Treemap」即可。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="我讨厌的5个编码面试问题"><a href="#我讨厌的5个编码面试问题" class="headerlink" title="我讨厌的5个编码面试问题"></a><a href="https://thoughtspile.github.io/2022/03/21/bad-tech-interview/">我讨厌的5个编码面试问题</a></h3><p>本文列举几个作者最不喜欢的五类面试题目：</p><ol><li><p><strong>一些不重要的琐事</strong></p><p>这一类面试题通常是一些实际工作中很少遇到的场景，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> y = &#123;&#125;;</span><br><span class="line">x.__proto__ = y;</span><br><span class="line">y.__proto__ = x;</span><br><span class="line"><span class="built_in">console</span>.log(x.field);</span><br></pre></td></tr></table></figure><p>首先 <code>__proto__</code> 并不是一个标准的属性，实际工作中也应该避免使用它来修改原型链，能够正确回答它并不能真正显示候选人的 JavaScript 水平，只能体现他看过多少面试题。</p><p>这些题目通常关注于一些 JavaScript ES5 之前的糟粕，但现在已经是 2022 年了，我们没有必要再问这类问题。</p></li><li><p><strong>具体的细节</strong></p><p>这类问题通常过于关注细节，比如：</p><ul><li>迁移到 Webpack 6 会遇到什么问题？</li><li>如何检查浏览器对服务器发送事件的支持？</li></ul><p>这些问题，即便候选人真的在工作中解决过，除非事先准备好，否则也很难完整地回答出来，但我们都擅长通过搜索引擎解决这类问题。</p><p>这些题目极有可能是面试官最近解决过的一些棘手问题，他对此记忆犹新，但是根据这些问题来判断候选人的能力是不公平的，因为即便候选人回答不出来，也不代表他无法解决此类问题，这只是双方信息不对称所导致的。</p><p>所以面试官更应该着重关注于候选人最近解决过什么棘手问题，以此判断候选人解决问题的能力。</p></li><li><p><strong>混淆问题</strong></p><p>这些问题通常具有一个标准的答案，比如：</p><ol><li>Number 和 Object 之间有什么区别？</li></ol><p>这个题目的答案仅仅是：Number 是不可变的。</p><p>但候选人可能会认为这是一个开放式的题目，因此会从各方面对它们进行对比，这严重浪费时间。</p><p>同样的，这些问题也体现出候选人的面试经验，只有他被问过几次同样的题目，才熟练地知道它具有一个标准的答案。</p><p>所以面试官应该更直接地问：哪些 JavaScript 类型是不可变的。</p></li><li><p><strong>实现问题</strong></p><p>这类问题通常与浏览器实现细节相关，但它们不在规范里面：</p><ul><li><code>console.log(Object.keys(&#123; x: 0, y: 0 &#125;).join())</code> 问 x 和 y 哪个在前面？</li></ul><p>大多数人都知道正确的答案：根据添加顺序进行排序。</p><p>但此类特性依赖于 JS 引擎的实现，在 ECMAScript 规范中并没有明确定义。</p><p>所以面试官在问这类题目的时候，不应该持有标准化答案的心态，它更应该是一个开放式的题目。</p><p>PS：我曾写过一篇文章深入剖析 <code>Object.keys</code> 的规范：《<a href="https://4ark.me/post/how-object-keys-work.html">一行 Object.keys() 引发的血案</a>》。</p></li><li><p><strong>缺少上下文</strong></p><p>开放式问题是你在面试中可以问的最好的问题之一，因为它们具有挑战性，并能够真正体现候选人解决问题的能力，然而这些问题取决于面试官个人观点，否则容易引起反作用。</p><p>例如，这个函数有什么问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = fn(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题对于不同的人具有不同的观点，有些人觉得这段代码问题一大堆，比如：</p><ol><li>为什么使用 <code>var</code> 而不是 <code>let</code> ？</li><li>为什么不使用 <code>for...of</code> ?</li><li>它具有副作用，不应该直接修改 <code>arr</code></li><li>为什么不直接使用 <code>.map()</code> ?</li></ol><p>但也有人觉得它没有任何问题，既然它能够正常工作，我们为什么需要重构它？仅仅是为了让它看上去更好吗？我们的目标是什么？没有明确目标的重构就是浪费时间！</p><p>所以，双方都没有错，因为它完全取决于上下文。</p><p>所以，当你提出一个开放式问题时，要么放下你预期的答案，专注于解决问题的过程，要么引入缺失的要求来指导你想要的解决方案。</p><p>最后，作者给出了一个如何改进面试题目的建议：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041732556.png" alt="img"></p></li></ol><h3 id="不良面试官的七个习惯"><a href="#不良面试官的七个习惯" class="headerlink" title="不良面试官的七个习惯"></a><a href="https://blog.thoughtspile.tech/2022/03/28/interview-bad-habits/">不良面试官的七个习惯</a></h3><p>此文接着上一篇《我讨厌的5个编码面试问题》，列举几个面试官不好的习惯：</p><ol><li><p><strong>骄傲的自负</strong></p><p>有些面试官通常抱有一种「<strong>既然是我在面试你，那么我的能力自然比你强</strong>」的心态，他们往往摆出一副居高临下的样子，但你要清楚，你掌握所有面试问题的答案，这本就是一种信息不对称，所以你不应该抱有这种想法。</p></li><li><p><strong>专注于答案</strong></p><p>就像考试一样，面试官列出所有的面试题目，照本宣科地问问题，这类问题通常具有标准答案，但真正的工作中很少是考试一样解决问题的，并且这类问题都可以通过搜索引擎解决。</p><p>我们更应该倾向于开放式的题目，专注于候选人解决问题的过程，比如问「如何设计一个 Swiper」会比「具有哪些触摸事件」更合适。</p><p>此类问题其实还蕴含了一个顾虑：不信任候选人，认为他们缺乏这些基础知识。</p></li><li><p><strong>不给出任何提示</strong></p><p>试问当你身边的同事在某个问题卡住的时候，你会选择帮助他还是立即解雇他？所以我们应该引导候选人，而不是让他一个人苦苦挣扎。</p></li><li><p><strong>规划不善</strong></p><p>面试前没有提前规划好面试流程、或者是面试流程安排得太紧凑都会导致面试效果不佳。</p><p>假设你们明显有可能在某个问题上进行深入地探讨，千万不要仅仅因为你需要问更多初级的问题而打断候选人展示自己的机会。又或者你招聘的是高级开发人员，而候选者碰巧是一位非常不错的初级开发人员，你也不要轻易地错过。</p></li><li><p><strong>忽略简历</strong></p><p>不要浪费候选人的宝贵时间，假设候选人是一位顶尖大学毕业、甚至有一个技术博客和开源项目，这都可以体现出候选人的专业技能，而面试官仍要花费近 30 分钟去问一些基础问题，这会让候选人觉得是在浪费自己的时间。</p><p>诚然简历是可以造假，但仍不应该花费过多的时间去印证候选人是否具备这些基础知识，把时间花在更有价值的问题上。</p></li><li><p><strong>过渡延长</strong></p><p>不要让面试时间过长，除非你有自信保证候选人愿意花费这么多时间。</p></li><li><p><strong>避免群体面试的不良反应</strong></p><p>多个面试官时千万不要你一句我一句的，也不要显得某个面试官在场是完全没必要的，更好的做法是其中一位面试官负责主要的问题，其他面试官负责观察。</p></li></ol><h3 id="如何看待-ECMAScript-新提案-Type-Annotations"><a href="#如何看待-ECMAScript-新提案-Type-Annotations" class="headerlink" title="如何看待 ECMAScript 新提案 - Type Annotations"></a><a href="https://2ality.com/2022/03/type-annotations-first-look.html">如何看待 ECMAScript 新提案 - Type Annotations</a></h3><p>这个月有一个 ECMAScript 的新提案，可以在 JavaScript 中使用 TypeScript 部分类型声明，参见：<a href="https://github.com/tc39/proposal-type-annotations">tc39/proposal-type-annotations</a>。</p><p>此提案一经提出，在中英文社区都引起了不少的轰动，而《<a href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a>》的作者 Dr. Axel Rauschmayer 在这篇文章中提出了一些他的看法。</p><p>先展示一下这个提案的一些使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很标准的 TypeScript 语法，而 JavaScript 将这样处理这些类型声明：</p><ol><li>在运行时，JavaScript 引擎完全忽略它们 - 就好像它们是注释一样。</li><li>在开发时，类型检查器可以静态分析注释并警告开发人员有关潜在问题。</li></ol><p>下面是本文作者的一些看法：</p><ul><li>优点：<ul><li>为类型声明标准化是很好的，并且将使该领域的工具和实验更容易。</li><li>可以在不编译源代码的情况下使用 TypeScript 进行编程（例如）。在开发时只会进行类型检查。这将大大改善静态类型 JavaScript 的开发体验：<ul><li>执行时不需要中间文件。<ul><li>这在 Node 上特别有用 .js 您可以直接运行 TypeScript 文件。</li></ul></li><li>调试时，不需要源映射即可查看原始源代码。</li><li><code>.d.ts</code>文件通常也不需要。</li></ul></li></ul></li><li>缺点：<ul><li>像 TypeScript 这样的静态类型系统是完全可选的 JavaScript 之上的层，不会给 JavaScript 增加任何复杂性。</li><li>该提案为该语言添加了许多新的语法。即使引擎忽略它，它们仍然必须能够解析它。升级  JavaScript 工具需要时间和精力。</li><li>如果在将库部署到 npm 之前没有将 TypeScript（等）编译为 JavaScript，那么对于不喜欢 TypeScript 的人来说，浏览 TypeScript 开发人员编写的源代码将变得不那么愉快。<ul><li>为了帮助解决这个问题，从文件中删除所有类型批注可能成为文本编辑器支持的操作。</li></ul></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>我个人非常喜欢这个提案，也很希望这个提案能够最终进入到 ECMAScript 的标准中。但这背后仍会有无数的坑，比如 <code> add&lt;number&gt;(4,5)</code> 它也是合法的 JavaScript 代码，至于如何解决这类与现有代码冲突的问题，就让我们拭目以待吧。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.patterns.dev/">改进构建 Web 应用程序的方式</a>：一本关于设计模式和组件模式的免费书籍，用于使用原生 JavaScript 和 React 构建强大的 Web 应用程序。</li></ul><ul><li><p><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">Git 飞行规则(Flight Rules)</a>：这是一篇给宇航员（这里就是指使用 Git 的程序员们）的指南，用来指导问题出现后的应对之法。</p></li><li><p><a href="https://devhints.io/">里科的备忘单</a>：一些语言、框架、工具的 TL;DR，帮助你快速了解某一门技术。</p></li></ul><ul><li><a href="https://refactoringguru.cn/design-patterns">常用的设计模式有哪些？</a>：图文并茂地列出了几乎所有的设计模式，帮助你理解设计模式。</li></ul><ul><li><a href="https://developer-advocacy.com/">开发人员的宣传手册</a>：本手册引导你成为任何产品或公司的布道者。</li></ul><ul><li><a href="https://www.accessguide.io/">访问指南</a>：这是对可访问性的友好介绍！列出了很多有用的知识帮助你提高网站的可访问性。</li></ul><ul><li><a href="https://tldp.org/LDP/abs/html/index.html">高级 Bash 脚本编写指南</a>：帮助你学习 Bash 脚本，而且它没有任何版权，可用于课堂、知识分享会。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第6期：网络没有版本号</title>
      <link href="//post/weekly-06.html"/>
      <url>//post/weekly-06.html</url>
      
        <content type="html"><![CDATA[<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="网络没有版本号"><a href="#网络没有版本号" class="headerlink" title="网络没有版本号"></a><a href="https://hiddedevries.nl/en/blog/2022-01-03-the-web-doesnt-have-version-numbers">网络没有版本号</a></h3><p>在过去一年时间里，我们经常听到 WEB3 ，以及相关的术语：如区块链、加密、NTF 等，让不少 WEB 开发者认为这项技术是未来的趋势，于是每个开发者都跃跃欲试，但本文作者认为我们应该对这个充满误导性的术语 「WEB3」持谨慎态度，因为网络并没有版本号，更没有某个权威的机构会定期更新网络的版本。</p><p>希望 WEB3 及其相关术语不会成为 WEB 开发者的简历上必备的流行词，对于大部分 WEB 开发者而言，该领域的专业知识是不必要的。</p><h3 id="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"><a href="#您在软件开发方面的经验水平将使您产生截然不同的观点和意见" class="headerlink" title="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"></a><a href="https://www.kevinhooke.com/2022/03/22/your-experience-level-in-software-development-will-lead-you-to-wildly-different-points-of-view-and-opinions/">您在软件开发方面的经验水平将使您产生截然不同的观点和意见</a></h3><p>假设你是一个初级开发者，你为了实现某个功能，而刚好有一个库/框架能够满足你的需求，所以你希望能够把这个库/框架加入到项目中，但比你更有经验的同事拒绝了这个建议，他认为没必要仅仅为了实现一个功能而添加一个库/框架。</p><p>你可能会认为这是一个短视的看法，他们不应该被困在什么都自己重新造轮子的旧观念上。</p><p>但也许他是这样思考问题的：</p><ol><li>添加一个库，意味着增加系统的复杂度、意味着更多的风险。</li><li>需要及时跟踪这个库的安全漏洞、并在 breaking change 时更新现有的代码。</li><li>这个库的安全性如何？是否会有意外的情况发生？</li><li>添加这个库的成本和风险？成本是否会比自己开发更低？</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>对于任何一个商业项目而言，不应该也不可能完全脱离开源社区的框架、类库，我们确实不可能所有事情都重新造轮子，开源类库的健壮性肯定比自己实现要强，但这也不意味着我们可以盲目地使用开源类库，即便要使用类库，也可能会面临多个不同选择，我们应该从生态社区、维护积极性、安全性等多方面进行考察和对比，最终选择出适合的方案。</p><h3 id="当你在构建产品时，你应该听取谁的意见？"><a href="#当你在构建产品时，你应该听取谁的意见？" class="headerlink" title="当你在构建产品时，你应该听取谁的意见？"></a><a href="https://justinjackson.ca/opinion">当你在构建产品时，你应该听取谁的意见？</a></h3><aside>💬 "在我使用苹果产品的这么多年里，我从来没有退过一个产品。直到现在。上个月我购买了带 Touch Bar 的新 MacBook Pro。真让人失望。这是第一个让我的工作效率下降的苹果设备。该公司已经与史蒂夫-乔布斯关于简单、优雅机器的愿景脱节。- 迈克尔-凯特</aside><p>人们根据自己的背景来重视不同的东西。就比如对于笔记本电脑，不同的群体需要不同的功能：</p><ul><li><strong>学生们</strong>想要一台价格实惠且重量轻的笔记本电脑（因为他们会把它带到课堂上）。</li><li><strong>程序员</strong>想要一台具有高分辨率屏幕，大量内存和全尺寸键盘的笔记本电脑。</li><li><strong>游戏玩家</strong>想要一个具有超强 CPU和 GPU 的电脑，他们也不介意笔记本电脑是否笨重。</li></ul><p>本文作者提出我们在构建产品时，最应该听从谁的意见，以及如何听从：</p><ul><li><strong>只接受为您的产品付费的人的产品反馈</strong>，很多人可能不同意这个观点，但是请看看 Feedbook 和谷歌，我们中的许多人都在每天使用它，但是 Facebook 和谷歌似乎不太关心我们的隐私，并在未经我们同意的情况下分享我们的信息。为什么？<strong>因为他们效忠的是广告商</strong>。</li></ul><h3 id="在浏览器-devtools-中打印图片"><a href="#在浏览器-devtools-中打印图片" class="headerlink" title="在浏览器 devtools 中打印图片"></a><a href="https://www.bram.us/2022/02/13/log-images-to-the-devtools-console-with-console-image/">在浏览器 devtools 中打印图片</a></h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203282335113.png" alt="Untitled"></p><p>我们使用以下代码在 devtools 中利用 <code>console.log</code> 输出图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBox</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">string</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&quot;font-size: 1px; padding: &quot;</span> + <span class="built_in">Math</span>.floor(height/<span class="number">2</span>) + <span class="string">&quot;px &quot;</span> + <span class="built_in">Math</span>.floor(width/<span class="number">2</span>) + <span class="string">&quot;px; line-height: &quot;</span> + height + <span class="string">&quot;px;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.image = <span class="function"><span class="keyword">function</span>(<span class="params">url, scale</span>) </span>&#123;</span><br><span class="line">    scale = scale || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dim = getBox(<span class="built_in">this</span>.width * scale, <span class="built_in">this</span>.height * scale);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c&quot;</span> + dim.string, dim.style + <span class="string">&quot;background: url(&quot;</span> + url + <span class="string">&quot;); background-size: &quot;</span> + (<span class="built_in">this</span>.width * scale) + <span class="string">&quot;px &quot;</span> + (<span class="built_in">this</span>.height * scale) + <span class="string">&quot;px; color: transparent;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接使用这个库：<a href="https://github.com/adriancooney/console.image">https://github.com/adriancooney/console.image</a></p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://myxml.in/cors-tester.html">CORS Tester</a>：跨域对于前后端来说都是一个不可逾越的知识点，在实际项目开发中也必然会遇到各种各样的跨域问题，可以使用这个网站在线体验跨域的请求。</p></li><li><p><a href="https://effective-shell.com/">Effective Shell</a>：一本学习 Shell 的在线书籍，适合任何一个想要入门 Shell 的同学。</p></li><li><p><a href="https://curlconverter.com/">Convert curl commands to code</a>：将 CURL 转换到各编程语言的实例中，当然我们平常都会使用 Postman、PAW 等工具进行转换，不过也总有需要在线转换的时候把？</p></li><li><p><a href="https://exploringjs.com/impatient-js/index.html">JavaScript for impatient programmers (ES2022 edition)</a>：在 JavaScript 世界中有很多非常经典的书籍，如 《JavaScript 权威指南》、《JavaScript 高级程序设计》、《你不知道的 JavaScript》 等，但我推荐这本更加现代化的书，包含了最新的 ES2022 新特性。</p></li><li><p><a href="https://charm.sh/">Charm</a>：在 CLI 构建你的图形界面，真的很漂亮！</p></li><li><p><a href="https://jless.io/">jless</a>：一个更好地显示 JSON 的 CLI 工具，推荐使用！</p></li><li><p><a href="https://devtoys.app/">DevToys</a>：堪称开发者的瑞士军刀，提供了比如文件转换（JSON &lt;&gt; YAML ）、编码解码、格式化（支持 JSON、SQL、XML）、哈希生成、UUID 生成、图片压缩多种功能。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第5期：拖延症</title>
      <link href="//post/weekly-05.html"/>
      <url>//post/weekly-05.html</url>
      
        <content type="html"><![CDATA[<h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><p>本期周刊延迟了两天，今晚抽空补上，内容会相对比较少。</p><p>反思一下，一个原因是这周比较忙，但主要还是因为自己的拖延症，希望以后能够克服这个问题。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="Exhausting-Exhaustive-Testing"><a href="#Exhausting-Exhaustive-Testing" class="headerlink" title="Exhausting Exhaustive Testing"></a><a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">Exhausting Exhaustive Testing</a></h3><p><em>原文地址：<a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">《Exhausting Exhaustive Testing》 | openmymind</a></em></p><p>非常短的一篇文章，但作者的观点让我醒醐灌顶：编写有效的测试具有挑战性，每个测试用例都需要考虑最大化其价值。</p><p>举一个例子，比如我们有这么一个软删除用户的函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deleteUser(id) (bool, error) &#123;</span><br><span class="line">  tag, <span class="attr">err</span> := conn.Exec(<span class="string">`</span></span><br><span class="line"><span class="string">    update users</span></span><br><span class="line"><span class="string">    set status = &#x27;deleted&#x27;</span></span><br><span class="line"><span class="string">    where id = $1</span></span><br><span class="line"><span class="string">  `</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tag.RowsAffected() == <span class="number">1</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会如何测试这个函数？是不是这样：</p><ol><li>插入一个新的用户</li><li>调用这个函数</li><li>判断这个新用户是否被删除</li></ol><p>这样测试没有错，但是我们忽略了一点：如果这个函数把所有用户都删除了呢？是不是也能通过测试？</p><p>所以正确的测试方式是：插入两个用户，删除第一个用户，确保第二个用户没有被删除。</p><p>还有另外一个例子，假如我们要获取用户列表，SQL 是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name</span><br><span class="line"><span class="keyword">from</span> users</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> customer_id <span class="operator">=</span> $<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><p>通常我们可能是这样测试的：</p><ol><li>插入一个新用户，设置 customer_id</li><li>调用函数</li><li>判断是否返回这个新用户</li></ol><p>但作者认为至少需要插入四个新用户才能进行这个测试：</p><ol><li>四个用户，其中一个被删除的 A、一个 customer_id 不符合的 B，剩余两个才符合条件</li><li>确保没有返回 A 和 B</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>诚然我们都认同测试的重要性，但是如何编写测试是一门非常高深的学问，只是编写测试用例的时候只是流于表面的，那么其价值是非常低的，甚至是浪费时间的。</p><h3 id="百度腾讯阿里真的是高科技企业吗？"><a href="#百度腾讯阿里真的是高科技企业吗？" class="headerlink" title="百度腾讯阿里真的是高科技企业吗？"></a><a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">百度腾讯阿里真的是高科技企业吗？</a></h3><p><em>原文地址：<a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">《百度腾讯阿里真的是高科技企业吗？》 | 马工</a></em></p><p>那么，这些潜力人才去了BAT，在干什么呢？腾讯的公众号文章《搞了运维开发这么多年，原来 Ping 还能这么玩儿！》揭示了部分真相：一个北大本科毕业生在腾讯研究一个1981年的协议ICMP，而这个协议因为不安全已经被大多数美国同行比如AWS给默认禁掉了。说句不客气的话，ICMP协议就是IT行业的回字的四种写法，让北大毕业生去研究ICMP协议，就是把他们变成孔乙己。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://oktools.net/aes">AES加密/解密</a>：一个在线 AES 加密/解密的工具。</p></li><li><p><a href="https://plantuml-editor.kkeisuke.dev/">PlantUML Editor</a>：一个在线画 PlantUML 的工具。</p></li><li><p><a href="https://getoss.art/">OssArt</a>：一个非常有意思的开源项目，它可以帮你打印出最早从 2010 年开始的 GitHub Activity 贡献图，让你的成就感满满。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hg hooks 实践历程</title>
      <link href="//post/hg-hooks.html"/>
      <url>//post/hg-hooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><blockquote><aside> 💬 提交代码前记得 lint</aside><aside> 💬 又有人没跑测试就提交代码</aside><aside> 💬 project-config 有改动，麻烦 yarn setup 一下</aside></blockquote><p>相信使用 Hg 的同学们已经非常熟悉上面这几句话了，我们每次在提交或者拉取代码时总需要手动执行某些命令，实在繁琐。</p><p>但现在已经 2022 年了，难道就没有更好的解决方法吗？</p><p>有的，我们知道，在 Git 有个东西叫做 hooks（钩子），可以在特定事件发生之前或之后执行特定动作。</p><p>同样的，Hg 也有 <a href="https://www.mercurial-scm.org/wiki/hook">hooks</a>，不过并不像 Git 一样生态蓬勃发展，也没有太多现有的开源工具可供大家使用。</p><p>本文就来介绍一下我们从 0 到 1 的 Hg hooks 实践过程，同时也希望能够起到抛砖引玉的作用。</p><h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在没有引入 Hg hooks 之前，我们常常会面对几种情况：</p><ol><li>有同学在提交代码时忘记执行 <code>yarn lint</code>、<code>yarn test</code></li><li>修改了 <code>project-config</code> 的常量，却忘记通知大家，或者有人错过了这条信息。</li></ol><p>这都有可能会导致其他小伙伴拉取代码后，发现页面上的某个功能突然异常，花费一段时间排查才发现原来是没有执行 <code>yarn setup</code>。</p><p>可能有部分同学会想到，那我自定义一个命令在提交或者拉取代码时自动做这件事不就好了吗？</p><p>比如这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn lint &amp;&amp; hg commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hg pull --update &amp;&amp; yarn setup</span><br></pre></td></tr></table></figure><p>这样也不是不行，但是会存在一些问题：</p><ol><li>由于每个人的拉取代码的命令不一样，如果项目开发流程发生变化，则每个人都需要同步修改</li><li>有些同学习惯使用图形化界面，比如 SourceTree、vscode-hg 等，则无法自定义操作命令</li></ol><p>因此，我们另辟蹊径，寻找更好的解决方案。</p><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>我们最主要想解决的问题就是：</p><ol><li>在提交代码前自动执行 <code>yarn lint</code>、<code>yarn test</code>，不通过则直接终止提交。</li><li>在拉取代码后，检测到如果 project-config 目录发生改动，则自动执行 <code>yarn setup</code>。</li><li>还有更多：<ol><li>检查 commit message 规范</li><li>统一代码的格式化风格</li></ol></li></ol><p>这些都可以通过 Hg hooks 解决，所以开始之前，我们先对 Hg hooks 做一个简单的认识。</p><h3 id="Hg-hooks-介绍"><a href="#Hg-hooks-介绍" class="headerlink" title="Hg hooks 介绍"></a>Hg hooks 介绍</h3><p>Hg hooks 能做什么，这次再介绍一遍：<strong>它可以在特定事件发生之前或之后执行特定动作。</strong></p><p>特定事件，指的就是我们在对 Hg 仓库进行操作时的一些钩子，比如提交前（precommit）、提交后（commit），可以在这里查看全部 hooks 列表：<a href="https://www.mercurial-scm.org/repo/hg/help/hgrc">hooks</a>。</p><p>下面介绍一下如何使用 hook，我们可以通过以下两个文件进行配置：</p><ol><li><code>~/.hgrc</code>：全局的，将对所有 hg 仓库起作用。</li><li> 项目根目录的 <code>.hg/hgrc</code> ：仅对当前仓库起作用。</li></ol><p>比如我们想要实现一个简单的需求：在提交代码前进行 <code>yarn lint</code>。</p><p>首先编辑 <code>.hg/hgrc</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hooks</span>]</span><br><span class="line"><span class="string">precommit</span> <span class="string">=</span> <span class="string">./bin/hooks/precommit.sh</span> <span class="comment"># 这个路径是相对于项目根目录的</span></span><br></pre></td></tr></table></figure><p>然后编写脚本 <code>bin/hooks/precommit.sh</code>（也可以使用 python）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">yarn lint</span><br><span class="line"></span><br><span class="line"><span class="comment"># lint 没有通过直接退出</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这里需要特别指出，之所以需要重新声明 <code>PATH</code> 变量：</p><ol><li>hooks 脚本的运行环境取决于同学提交代码的地方，比如通过 SourceTree 提交，由于环境不一样，就可能会出现 <code>yarn: command not found</code> 的报错，参见：<a href="https://stackoverflow.com/questions/22883197/git-command-not-found-in-the-custom-action-for-sourcetree">‘Git Command Not found’ in the custom action for SourceTree - Stack Overflow</a>。</li><li>每个同学安装 hg 的方式可能不一样，有通过 brew、pip、甚至自己手动编译的，它们的可执行文件路径不一样。<ul><li>可以通过 <code>which hg</code> 查看这个命令的可执行文件路径。</li></ul></li></ol><p>这样，一个简单的 hook 就配置完成了，这时候提交代码就会触发 <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;ci: precommit hooks&quot;</span></span><br><span class="line"></span><br><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br></pre></td></tr></table></figure><p>当 hook 脚本的 exit code 不为 0 的时候，则会终止当前的 Hg 操作，对于某些具有事务性的 hook（e.g. pretxncommit），还会自动进行回滚。</p><p>可以通过以下链接对 Hg hooks 进行更深入地学习：</p><ul><li><a href="https://www.mercurial-scm.org/wiki/hookExamples">hookExamples</a></li><li><a href="https://www.mercurial-scm.org/wiki/Usefulhooks">Usefulhooks</a></li><li><a href="http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html">Chapter 10. Handling repository events with hooks (red-bean.com)</a></li></ul><h3 id="Hg-hooks-实践"><a href="#Hg-hooks-实践" class="headerlink" title="Hg hooks 实践"></a>Hg hooks 实践</h3><h4 id="提交代码前（precommit）"><a href="#提交代码前（precommit）" class="headerlink" title="提交代码前（precommit）"></a>提交代码前（precommit）</h4><p>这里需要用到的 hook 是 precommit，它的运行时机在提交之前，exit code 非 0 时将终止提交。</p><p> <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要 lint 的项目</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram&#x27;</span></span><br><span class="line">    <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    <span class="string">&#x27;core&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否修改该项目，无则跳过 lint</span></span><br><span class="line">    has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;app&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$app</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">    yarn &amp;&amp; yarn lint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lint 是否报错，是则直接退出脚本</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对当前修改或新增的文件批量进行 prettier 格式化</span></span><br><span class="line">hg status | grep -E <span class="string">&quot;^(M|A).*.(js|json|wxss)$&quot;</span> | sed <span class="string">&#x27;s|^M||g; s|^A||g&#x27;</span> | xargs ./node_modules/.bin/prettier --write &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>比较浅显易懂，由于是 Monorepo 架构，所以仅针对当前改动的子项目执行 <code>yarn lint</code> ，当 lint 不通过时终止提交；然后仅对当前变更的文件做 prettier 格式化，并且忽略这行命令的输出和错误。</p><p>ps：其实这里的 prettier 机制有点问题，原本的目的是仅格式化当前提交的文件，但 Hg 没有 staging area 的概念，故只能粗暴处理，如果有更好的解决方法欢迎指教。</p><ul><li>hg commit 可以只提交指定的部分文件，所以是有 changed files 和 commited files 两个概念，但是没有找到办法获取 commited files，参见：<a href="https://stackoverflow.com/questions/24565802/mercurial-pre-commit-hook-how-to-tell-apart-changed-and-committed-files">Mercurial pre-commit hook: How to tell apart changed and committed files - Stack Overflow</a></li><li>另一种思路：使用 pretxncommit 钩子，就可通过 $Hg_NODE 变量拿到当前 commit 的信息，但缺点是 pretxncommit 阶段将不能再对文件进行改动，则格式化后需要重新提交一遍。</li></ul><p>随着版本迭代，在 precommit 钩子中增加了检测 utils、test 目录改动则自动执行单元测试 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改以下文件需要执行单元测试</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram/utils miniprogram/test&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    dir=(<span class="variable">$app</span>)</span><br><span class="line">    pass=0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;dir[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 判断是否修改工具方法、测试用例，无则跳过</span></span><br><span class="line">        has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;d&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 同一个项目只执行一次</span></span><br><span class="line">        [ <span class="variable">$pass</span> -eq 1 ] &amp;&amp; <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$d</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line">        yarn &amp;&amp; yarn <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># test 是否报错，是则直接退出脚本</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        pass=1</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> -</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="拉取代码后（changegroup）"><a href="#拉取代码后（changegroup）" class="headerlink" title="拉取代码后（changegroup）"></a>拉取代码后（changegroup）</h4><p>主要想解决的问题是：当拉取代码后，检测到 project-config 目录发生变更，则执行 <code>yarn setup</code>。</p><p>首先要解决第一点，如何获取从远端拉取代码所改动的文件？有下面几种方法：</p><ol><li><p><a href="https://backend.bolt80.com/hgdoc/hg-incoming.html">hg incoming</a>：显示远端中的新 commit</p><ul><li>缺点：该方法只是显示新的 commit，后面仍需要再进行一次 pull 才能将新 commit 拉取下来，导致拉取代码时间翻倍。</li></ul></li><li><p><a href="https://backend.bolt80.com/hgdoc/hg-pull.html">hg pull</a>：在拉取代码之后、进行 update 或 rebase 之前，通过 <code>hg log</code> 对比本地 head 和 远端拉取下来的 head。</p></li><li><p>hooks：</p><ol><li>update：工作目录发生改变时，所以只要进行提交、储藏、切换分支都会触发，<strong>不考虑</strong>。</li><li>incoming：每一个新的 commit 被传入时都会触发一次，过于频繁，<strong>不考虑</strong>。</li><li>changegroup：在 push、pull、unbundle 时都会触发，但多个 commit 被传入也只会触发一次，<strong>可考虑</strong>。</li><li>还有一些不太满足的 hooks 不一一介绍了。</li></ol></li></ol><p>在一开始，我们曾尝试使用第二种方法解决该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    no_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改动文件</span></span><br><span class="line">    regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本次 pull 变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">    has_change=$(hg <span class="built_in">log</span> --verbose -r .:tip | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参考 hg update --rebase 的实现，先尝试 rebase，如果不需要 rebase，则直接 update</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/35327163/what-is-the-rebase-command-used-in-hg-pull-rebase</span></span><br><span class="line">    <span class="comment"># @link：https://www.mercurial-scm.org/repo/hg/file/tip/hgext/rebase.py#l2172</span></span><br><span class="line">    has_rebase=$(hg rebase -b . -d <span class="string">&#x27;last(branch(.))&#x27;</span> | grep <span class="string">&quot;nothing to rebase&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_rebase</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg update</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        yarn setup</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$no_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以很好地工作，它可以满足：</p><ul><li>拉取代码时自动储藏、恢复本地改动</li><li>当两端都同时修改 project-config 时，可以 update 或者 rebase 后再统一 <code>yarn setup</code></li></ul><p>后来发现使用 changegroup  hook 配合 <code>hg log</code> 一样可以解决问题，于是就有了 <code>changegroup.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改动文件</span></span><br><span class="line">regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本次变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line"><span class="comment"># @see：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">has_change=$(hg <span class="built_in">log</span> -v -r <span class="variable">$Hg_NODE</span>: | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> $(hg root) || <span class="built_in">exit</span> 1</span><br><span class="line">    yarn setup</span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p> 因此 <code>hgpl</code> 可以精简成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    has_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull --rebase</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-message-检查（pretxncommit）"><a href="#commit-message-检查（pretxncommit）" class="headerlink" title="commit message 检查（pretxncommit）"></a>commit message 检查（pretxncommit）</h4><p>使用 pretxncommit 钩子可对当前提交信息进行检查，如检查 commit message：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">shelve_user=<span class="string">&quot;shelve@localhost&quot;</span></span><br><span class="line"></span><br><span class="line">commit_user=$(hg tip --template &#123;user&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 hg shelve 也会触发 pretxncommit 钩子，所以要进行忽略</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$commit_user</span>&quot;</span> == <span class="string">&quot;<span class="variable">$shelve_user</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">commit_message=$(hg tip --template &#123;desc&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[msg] <span class="variable">$commit_message</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$commit_message</span>&quot;</span> | ./node_modules/.bin/commitlint</span><br></pre></td></tr></table></figure><h2 id="铁器时代？"><a href="#铁器时代？" class="headerlink" title="铁器时代？"></a>铁器时代？</h2><p>这个标题之所以打上一个问号，是因为该方案仍在 POC 阶段，尚未落地实施，但也可作为一个对未来的展望。</p><p>迄今为止，我们的 Hg hooks 已经能够满足大部分场景了，那还存在些什么问题呢？</p><p>相信不少同学已经发现这样操作会存在有一个很明显的问题，那就是：hooks 配置如何同步？</p><p>我们知道 <code>.hg</code> 目录是不会加入版本控制的，这是非常合理且必要的，因为 hooks 本身是一些权限极高的可执行脚本，所以出于安全考虑（你也不想你 clone 一个仓库后，它会自动执行某些你不想执行的命令），<strong>因此是不会有任何一个 VSC 会将 hooks 加入版本控制的。</strong></p><p>可是这就会导致：</p><ol><li>假如项目新增了一个 hook，需要通知项目成员同步修改本地的 hooks 配置。</li><li>新成员加入项目，需要手动配置 hooks。</li></ol><p>如果这个问题不能得到解决，那归根到底还是无法绕过通知项目成员手动操作的过程。</p><p>所幸，以上问题在 Git 中同样存在，并且已经有很多非常成熟的方案，如： <a href="https://github.com/typicode/husky">huksy</a>、<a href="https://pre-commit.com/">pre-commit</a> 。</p><p>那有没有人在 Hg 生态上解决这个问题呢？粗略找到了两个：</p><ol><li><a href="https://github.com/TobiasTimm/husky-hg">husky-hg</a></li><li><a href="https://github.com/theylom/tdog-husky-hg">tdog-husky-hg</a>（前者的 fork</li></ol><p>都是基于 husky <a href="https://github.com/tobiastimm/husky-hg/commit/fcd100f4f1a7bdf04c05f51ddd80af9f87687ddc#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519R2">v0.14.3</a> 改造的，最后提交时间都在三年前（2019），然而 husky 现在已经迭代到 <a href="https://github.com/typicode/husky/releases/tag/v7.0.4">v7</a> 版本了，这 3 年间经过无数迭代，使用方式和实现原理都发生翻天覆地的变化，于是我们决定基于 husky v7 自行改造。</p><p>但是在此之前，我们先了解一下 Git 如何配置 hooks：</p><ol><li>在以前的 Git 版本中，如果要配置一个 hooks 则需要在 <code>.git/hooks</code> 目录新增一个 hook 同名的可执行文件，并且出于前面说的安全考虑， <code>.git</code>  目录是不会被加入版本控制的，<strong>因此也存在上面所说的问题</strong>。</li><li>在 Git v2.9 以后，支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，项目成员只需要在第一次配置 core.hooksPath 即可，后续增删 hooks 都可直接使用。</li></ol><p>因为 Git 支持 core.hooksPath ，所以 husky 直接采用了新的实现原理重构：</p><ol><li><p>在 huksy v4 的时候，由于 Git hooks 目录无法被加入版本控制，它们是这样解决这个问题的：</p><ol><li>在初始化的时候就在 <code>.git/hooks</code> 目录预先创建所有的 hooks 可执行文件，然后在 hooks 文件中执行定义在 <code>package.json</code> 中的 hooks 命令。</li><li> 这样很显然可以解决 hooks 无法同步的问题，但是这个实现原理也被不少人诟病，见 <a href="https://github.com/typicode/husky/issues/260">#260</a> 。</li></ol></li><li><p>由于 Git v2.9 的升级，在 husky v7 中使用了新的实现方式：</p><ol><li>将 hooks 可执行文件存放在一个可以被进行版本控制的目录（默认是 <code>.husky</code>），然后初始化的时候只需要配置  core.hooksPath 即可。</li></ol></li></ol><p>显然，v7 的实现方式更加方便快捷了，除此之外，它们的使用方式也有很大的不同：</p><ol><li>在 v4 中，通过在 <code>package.json</code>  中配置 <code>husky</code> 字段来定义 hooks。</li><li>在 v7 中，<strong>它不再仅限于 Node.js 项目</strong>，可以直接通过 CLI 的方式进行配置，参见：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</li></ol><p>在深入了解背后的实现原理后，我们得出了结论：</p><ol><li>v4 版本的代码<strong>有较多历史包袱，不利于改造，故基于 v7 版本修改</strong>。</li><li>但 v7 版本的实现方式对 Hg 并不完全适用，所以需要继续沿用 v4 的部分实现方式，所以这样设计：<ol><li>将 hooks 脚本存放在可被版本控制的 <code>.husky</code> 目录</li><li>但不通过预注册所有的 hooks 的方式，而是采用按需配置，初始化时根据 <code>.husky</code> 的 hooks 可执行文件列表注入 hooks 配置。<ol><li>比如在 Node.js 项目中可以通过 npm 的 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#prepare-and-prepublish">prepare</a> 钩子来自动初始化。</li></ol></li></ol></li><li>因此，使用方式与 husky <a href="https://typicode.github.io/husky/">文档</a> 中基本一致。<ol><li><code>husky install</code>、<code>husky add .husky/pre-commit</code></li></ol></li></ol><p>以上的心路历程、改造进展可以通过这个 <a href="https://github.com/gd4Ark/husky/pull/1">PR</a> 查看，感兴趣的同学可自行尝试：</p><ol><li>clone 项目，安装依赖，执行 npm link。</li><li>参考  husky <a href="https://typicode.github.io/husky/">文档</a> 进行使用。</li></ol><h2 id="背后的一些二三事"><a href="#背后的一些二三事" class="headerlink" title="背后的一些二三事"></a>背后的一些二三事</h2><p>最后分享一些我们在实践 Hg hooks 时的小插曲。</p><h3 id="一个隐藏字符引发的前端事故"><a href="#一个隐藏字符引发的前端事故" class="headerlink" title="一个隐藏字符引发的前端事故"></a>一个隐藏字符引发的前端事故</h3><p>有一天下午，在群里收到这么一个反馈：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191549957.jpg"  alt="2471647676117_.pic" style="margin-left: 0;" /><p>点开大图一看，好家伙！赫然一个「口」字就这么明目张胆地贴在页面的左下角，看它「浓眉大眼」的。</p><p>到底是哪里出了问题呢？</p><p>仔细看清楚，才发现它其实不是一个「口」字，而是「□」，学名叫做 <a href="https://zh.wikipedia.org/zh-hans/%E8%99%9A%E7%BC%BA%E5%8F%B7">虚缺号</a>，通俗地讲就是一个特殊字符。</p><p>于是打开对应的代码文件，果然一个红底白色 BS 字符引入眼帘：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204042021847.png"></p><h4 id="这是-VSCode-的锅？"><a href="#这是-VSCode-的锅？" class="headerlink" title="这是 VSCode 的锅？"></a>这是 VSCode 的锅？</h4><p>在网上有一番搜寻后，发现早就已经有不少人遇到过这个问题：</p><ul><li><a href="https://github.com/wangduanduan/wangduanduan.github.io/issues/158">vscode控制字符引起的问题以及解决思路</a></li><li><a href="https://jiangxiaokun.com/css/2018/11/15/ghost_chars/">隐藏字符引发的血案</a></li></ul><p>看下他们提供的复现过程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191703719.gif" alt="hmmm"></p><p>直接说下这个 Bug 的结论：</p><ol><li>VSCode 开启 webview 的情况下，使用中文输入法时按下退格键，就会导致出现退格符。</li><li>VSCode 底层是 Electron，Electron 底层用的 chromium，这个 BUG 是 chromium 的。</li><li>该 BUG 已经在 VSCode v1.4.0 得到修复，参见这个 <a href="https://github.com/microsoft/vscode/issues/37114#issuecomment-544236959">issue</a>。</li></ol><p>但既然该问题在 2019 年已经修复，那为什么在 2022 年的今天还会出现这个退格符呢？</p><p>由于已经复现不了，根源追求也就只能不了了之，但影响又如此之大，所以我们应该怎么去规避它呢？</p><h4 id="规避方案"><a href="#规避方案" class="headerlink" title="规避方案"></a>规避方案</h4><h5 id="利用-VSCode-扩展自动删除"><a href="#利用-VSCode-扩展自动删除" class="headerlink" title="利用 VSCode 扩展自动删除"></a>利用 VSCode 扩展自动删除</h5><p>有一个 VSCode 扩展 <a href="https://github.com/satokaz/vscode-bs-ctrlchar-remover">Remove backspace control character</a> 专门用于解决此类问题，安装后我们只需要在 setting.json 添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[wxml]&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;satokaz.vscode-bs-ctrlchar-remover&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可在保存代码的时候自动移除这些特殊的隐藏字符。</p><p>实现方式主要是通过正则去匹配这类隐藏字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm</span><br></pre></td></tr></table></figure><p>在这里查看所有字符的介绍：<a href="https://www.techonthenet.com/unicode/chart.php">Unicode</a>，本文所出现的 BS 正是 [\u0008]，也就是退格符。</p><h5 id="提交代码前自动删除"><a href="#提交代码前自动删除" class="headerlink" title="提交代码前自动删除"></a>提交代码前自动删除</h5><p>更好的方式是：我们可以在 precommit 钩子自动做这件事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.wxml&quot;</span> -<span class="built_in">exec</span> perl -i -p -e <span class="string">&quot;s/[\x08]//g&quot;</span> &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行命令的 time total</span></span><br><span class="line">0.10s user 0.80s system 93% cpu 0.953 total</span><br></pre></td></tr></table></figure><h3 id="让-vscode-hg-提交代码时显示-ESLint-报错的规则"><a href="#让-vscode-hg-提交代码时显示-ESLint-报错的规则" class="headerlink" title="让 vscode-hg 提交代码时显示 ESLint 报错的规则"></a>让 vscode-hg 提交代码时显示 ESLint 报错的规则</h3><p>起因是某位同学反映在 vscode-hg 提交代码的时候，无法显示 ESLint 校验不通过的规则提示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203201415448.png" alt="image-20220320141520784"></p><p>通常我们提交代码时，如果 yarn lint 不通过，会输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br><span class="line"></span><br><span class="line">/Users/4ark/project/helper/404.js</span><br><span class="line">  9:7  error  <span class="string">&#x27;a&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"></span><br><span class="line">✖ 1 problem (1 error, 0 warnings)</span><br><span class="line"></span><br><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>而 vscode-hg 只输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>不过经测试在 VSCode 中进行 Git 代码提交时并不存在该问题，所以猜测是 vscode-hg 这个扩展的原因。</p><p>于是抱着怀疑的态度看一下源码，发现果然如此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hg.ts#L620</span></span><br><span class="line"><span class="keyword">if</span> (options.logErrors !== <span class="literal">false</span> &amp;&amp; result.stderr) &#123;</span><br><span class="line">    <span class="built_in">this</span>.log(<span class="string">`<span class="subst">$&#123;result.stderr&#125;</span>\n`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只输出了 stderr，但是 ESLint 的规则输出是 stdout。</p><p>于是我们为了更好地使用 Hg hooks，让它支持了输出 ESLint 规则，见 <a href="https://github.com/mrcrowl/vscode-hg/issues/185">#185</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们在实践 Hg hooks 过程的一些经历和心得，未必是最佳解决方案，正如文本开头所说，撰写本文的目的是希望能起到抛砖引玉的作用，与大家一起进一步的深入探讨。</p><p>对于本文的实践思路、代码实现有任何的意见和建议，都请不吝指教。</p><p>最后感谢大家的阅读。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vcs </tag>
            
            <tag> hg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第4期：独立思考</title>
      <link href="//post/weekly-04.html"/>
      <url>//post/weekly-04.html</url>
      
        <content type="html"><![CDATA[<h2 id="本周做了啥"><a href="#本周做了啥" class="headerlink" title="本周做了啥"></a>本周做了啥</h2><p>给日常使用的 <a href="https://github.com/mrcrowl/vscode-hg">vscode-hg</a> 扩展提了两个没什么技术含量的 PR，顺便蹭了一个 contributor：</p><ul><li><a href="https://github.com/mrcrowl/vscode-hg/pull/184">docs: typo lineAnnotationEnabled option</a></li><li><a href="https://github.com/mrcrowl/vscode-hg/pull/185">feat: output stdout</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="useMemo-和-useCallback-之间的深入比较"><a href="#useMemo-和-useCallback-之间的深入比较" class="headerlink" title="useMemo 和 useCallback 之间的深入比较"></a><a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">useMemo 和 useCallback 之间的深入比较</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">《A Deep Dive Comparison Between useMemo And useCallback》 | Technical Blog</a></em></p><ul><li>它们的目的：都是通过缓存提高性能，避免组件重复渲染</li><li>相似之处：<ul><li>用法一致：与所有 hooks 一样，只能在组件的顶层调用</li><li>接收的参数一致：第一个为函数，第二个为依赖项</li><li>功能一致：返回缓存过的值，检测到依赖性发生时重新计算并缓存</li></ul></li><li>区别：<ul><li>它们表面上没有真正的区别</li><li>它们的内部实现也基本一致</li><li>使用场景的区别：<code>useCallback</code> 缓存函数，而 <code>useMemo</code> 缓存其它类型</li><li>实现原理的区别：<code>useCallback</code> 是缓存函数本身，而 <code>useMemo</code> 是缓存函数的返回值。</li></ul></li></ul><p>以下是它们的实现方式：</p><ul><li>useCallback</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初级开发人员如何为新团队提供价值"><a href="#初级开发人员如何为新团队提供价值" class="headerlink" title="初级开发人员如何为新团队提供价值"></a><a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">初级开发人员如何为新团队提供价值</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">《How You As a Junior Developer Can Immediately Provide Value When Joining a Team》 | Technical Blog</a></em></p><ul><li><strong>初级开发人员并不意味着不能提供价值：</strong>相反，初级开发人员可以给团队带来很多东西。</li><li><strong>质疑现状：</strong>如果一个团队长期合作，人们会开始接受彼此的缺点，习惯于某种风格和工作方式，也就会陷入舒适区，这可能会使团队停滞不前。所以你需要保持批判性，寻找团队懒惰、坏习惯、效率低下或者可以改进的地方，并且付诸行动去改变现状。</li><li><strong>新鲜血液：</strong>任何一个项目组都不可能每时每刻使用最新的技术、工具，可能会使得团队成员没有动力跟上最先进的技术，陷入一种恶性循环之中。你作为一个团队的新成员，可能你反而会在当前领域了解更多最先进的技术和工具，从而打破团队的恶性循环。</li><li><strong>意识到团队沟通的问题：</strong>长期合作的团队可能面临习惯现有的沟通方式，会自动忽略对方的缺陷，导致缺乏真正的沟通。而你能够意识到这些问题，并帮助团队提高这方面的效率。</li><li><strong>挑战团队现有的知识</strong>：每个团队内部都有一些的解决方案或流程，并且习惯于此，而你可以提出更多潜在的替代方案，帮助团队寻找更优的解决方案。</li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>作为一名初级开发人员可能认为自己只能负责最简单的一部分业务，并没有意识到自己能给团队带来这么多价值，但其实你可以通过你作为一个新成员的位置，去发现你刚加入的团队一些不好的习惯，通过正确的心态和行动去改变现状。</p><h3 id="你的代码不必完美无缺"><a href="#你的代码不必完美无缺" class="headerlink" title="你的代码不必完美无缺"></a><a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">你的代码不必完美无缺</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">《Your Code Doesn’t Have to Be Perfect》 | Technical Blog</a></em></p><p>作者通过一段经历，讲述他在实现某个功能时，由于想要实现最佳的解决方案，一开始就花费了大量的时间去进行完美的设计、抽象和封装，结果一个星期的时间没有任何真正的业务产出。</p><p>以下是作者一些教训：</p><ul><li><strong>不要从开始就重构：</strong>不需要刚开始就寻找最优的实现方式，这会让你过早地陷入到某个细节当中，把大量的时间花费在无意义的抽象中。</li><li><strong>复制粘贴还不错：</strong>我们应该坚持 DRY（不要重复你自己），但这不应该是起点，而是最终目标。可以在刚开始时通过复制粘贴实现功能，但这不意味着它就是最终上线的代码，而是在这个功能工作之后，再通过重构来提高代码质量。</li><li><strong>真正的重构需要适当的知识：</strong>通过改进现有的代码会使你的重构过程更加高效，因为这时候你已经掌握了更多的信息，可以更好地了解哪些代码是有意义的抽象。</li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>每个开发者都经历过这个阶段，想要一开始就设计好所有的细节、编写最完美的代码，但这是不可能的，所有代码都是经过不断地重构。你的代码不必在一开始就完美无缺，在生产项目中更是如此，毕竟不存在没有 deadline 的项目，只要懂得这个道理，你的工作效率会大大提高。</p><h3 id="关于编写可读代码的最重要的事情"><a href="#关于编写可读代码的最重要的事情" class="headerlink" title="关于编写可读代码的最重要的事情"></a><a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">关于编写可读代码的最重要的事情</a></h3><p>原文地址：<a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">《The Most Important Thing I Learned About Writing Readable Code》</a></p><p>编写代码时最重要的是可读性，一段难以理解的代码，即使你已经知道它的目的，你也很难理解它。所以编写具有可读性的代码是非常必要的。</p><p>已经有非常多的经典书籍在探讨这个话题，例如：</p><ul><li>《代码大全》</li><li>《重构》</li><li>《代码整洁之道》</li></ul><p>本文作者之前也写过几篇关于代码可读性的文章，不过我认为大部分已经是老生常谈了：</p><ul><li><a href="https://blog.logrocket.com/write-more-readable-react-code/">《如何编写更具可读性的 React 代码》</a><ul><li><strong>代码长度：</strong>更短的代码通常更容易阅读，但有时候并非如此。所以要根据场景，代码并不是越短越好。</li><li><strong>代码分组：</strong>将特定上下文的代码组合在一起，使得阅读性更高。React 的自定义组件、Hook 就是做这件事情。</li><li><strong>复杂的 JavaScript 结构：</strong>不是所有人都完全熟悉 JavaScript 的语言特性，如果依赖某些特性的固定或隐式行为，会使某些对 JavaScript 不太熟悉的开发人员难以理解这些代码。作者还特地拿 <code>Array.reduce</code> 来举了个例子，认为使用 <code>Array.reduce</code> 虽然可以让代码更加紧凑，但内部需要跟踪太多细节，如果直接使用 <code>for-loop</code> 会使代码更具有可读性。</li><li><strong>条件运算符 &amp;&amp;：</strong>这种短路的隐式行为没有 if-else 的可读性高。</li><li><strong>一次处理多种情况：</strong>例如在同一个 <code>useEffect</code> 处理多个 deps，会使代码更加混乱。</li><li><strong>变量命名：</strong>计算机两大难题之一，这个命题有点大。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/6-concrete-tips-that-will-make-your-react-pull-requests-easier-to-review/">《6 个技巧使你的 PR 更容易被 Review》</a><ul><li><strong>PR 的用途</strong>：Why、How</li><li><strong>分享视觉变化的屏幕截图</strong>：根据代码变更很难想象视觉的变化，所以展示一个截图可以帮助 Reviewer 更快地知道界面变化。</li><li><strong>列出功能要求</strong>：列出你想要实现的功能预期，否则很难通过代码上下文去预测你的实现是否正确、或者还有更优的解决方案。</li><li><strong>列出新的依赖</strong>：如果新增了依赖，你是如何决定采用哪一个库的。</li><li><strong>避免复杂的代码实现</strong></li><li><strong>提供有关如何 Review 的其他说明</strong>：告诉 Reviewer 从哪里开始 Review。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/this-is-my-10-questions-react-code-reviewing-routine/">《帮助你对 React 代码进行 Review 的 10 个问题》</a><ul><li>代码是否正常工作？</li><li>我明白了发生了什么吗？</li><li>代码是否可读？</li><li>组件或 Hook 是否做得太多？</li><li>这必须是组件或者 Hook 吗？</li><li>这个 API 设计可以简化吗？</li><li>有测试吗？</li><li>测试有意义吗？</li><li>这个功能的辅助功能方面如何？</li><li>是否更新了相应的文档？</li></ul></li></ul><p>但作者认为有一件更重要的事情被忽略了，那就是：<strong>沟通。</strong></p><p>每个人对于「代码是否具有可读性」的理解都不一样，所以日常中经常会出现下面这种对话：</p><ul><li>“你觉得这段代码非常难以阅读，但我认为它很容易。”</li><li>“我不同意，我经常使用这种实现方式，但理解它并没有难度。”</li><li>“使用这种方式实现，而不是你提供的那种方式实现，意味着我们不需要担心 xxx，可以使代码更短。”</li></ul><p>这种回答并非完全没有道理的，但它们都有共同点：<strong>他们之所以不同意使用这种实现会使代码可读性更差，是因为他们觉得自己能够理解这样的代码。</strong></p><p>的确，他们确实非常熟悉这段代码是如何工作的，但他们搞错了一件事：<strong>他们认为我是因为理解不了这段代码，才觉得这段代码难以阅读。</strong></p><p>然而事实并非如此，因为问题的根本在于：<strong>代码的可读性与你无关，而是与其他人有关，准确地说，是与未来接手这段代码的人有关，甚至这个人很可能就是六个月后的自己。</strong></p><p>所以，你要为他们编写具有可读性的代码。</p><h4 id="个人思考-2"><a href="#个人思考-2" class="headerlink" title="个人思考"></a>个人思考</h4><p>首先我需要说明，我并不认同作者提到的「 <code>for-loop</code> 可读性比 <code>Array.reduce</code> 好」这个结论，我认为 <code>Array.reduce</code> 与 <code>forEach</code>、<code>map</code> 这些标准方法并无不同，不是 JavaScript 的糟粕，甚至是精华部分；另外 <code>Array.reduce</code>  真正需要考虑的细节也不多，只要熟悉递归思想，它其实很好理解。</p><p>除此之外的大部分观点我都是非常认同的，特别是本文讲到的「沟通」二字。我曾待过一个团队，当时合并代码前是需要两人交叉 Review 的，也遇到过几次关于「这样实现的可读性好不好」的问题展开讨论，基本都是各执一词，往往这种时候都需要一个第三者来进行判断，由这个人决定采用哪一种实现。</p><p>还记得有一次更离谱，某位同学酷爱使用位运算符，他对此给出的理由是：这样实现会使代码更快。</p><p>首先我并不认同这种说法，因为他没有给出专业的对比分析，即便这是真的，但在我们负责的这种 Web 项目中，这种速度的提升简直是可以忽略不计的，所以我就「可读性」本身这件事与他讨论，结果他开始和我解释这个位运算符是如何工作的，这位同学就犯了上面提到的问题，其实我不是不理解位运算符如何工作，我还曾写过一篇《<a href="https://4ark.me/post/learn-bitwise-operators.html">深入理解按位操作符</a>》的文章，我只是单纯认为不应该在项目中使用位运算符罢了。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.aisixiang.com/">爱思想</a>：华语圈内最具原创性和思想性的公益纯学术网站，有人文社科各领域、人品和作品均有一定高度的学者的大量访谈记录、论文等，可帮助你提高独立思考的能力。</li></ul><ul><li><a href="https://www.allhistory.com/">全历史</a>：在全历史 App 或网站里，你可以按照时间轴、关系图谱、时间地图查看各国，各个历史时期的历史相关内容。</li></ul><ul><li>在信息爆炸的今天，充斥着大量的虚假信息，这里推荐一些事实核查网站帮助你快速辨别信息真伪：<ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第3期：持续折腾</title>
      <link href="//post/weekly-03.html"/>
      <url>//post/weekly-03.html</url>
      
        <content type="html"><![CDATA[<h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><p>之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。</p><ul><li>《<a href="https://4ark.me/post/git-tips.html">Git tips</a>》</li><li>《<a href="https://4ark.me/post/hg-tips.html">Hg tips</a>》</li></ul><h2 id="折腾-iTerm2-tmux"><a href="#折腾-iTerm2-tmux" class="headerlink" title="折腾 iTerm2 + tmux"></a>折腾 iTerm2 + tmux</h2><p>很早之前就安装了 tmux，但是苦于一直记不住命令，也就没有坚持用。</p><p>不过其实 iTerm2 已经整合了 tmux，可以将 tmux 的各种命令操作映射到 iTerm2 本身的快捷键操作中，这可以大大降低 tmux 的学习成本，于是花了点时间折腾、以及 iTerm2 的外观调整，整体效果是这样的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203050038886.png?imageMogr2/format/webp"></p><p>主要参考以下这两篇文章：</p><ul><li><a href="https://toutiao.io/posts/q86tnu/preview">iTerm2 整合 Tmux 利器</a></li><li><a href="https://haidong.dev/iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/">iTerm2 设置详解</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="解剖-Netflix"><a href="#解剖-Netflix" class="headerlink" title="解剖 Netflix"></a><a href="https://lanzhiheng.com/posts/no-rule-in-netflix">解剖 Netflix</a></h3><p><em>原文地址：<a href="https://lanzhiheng.com/posts/no-rule-in-netflix">《解剖 Netflix - 全美员工满意度最高的企业》 | Step By Step</a></em></p><p>这是本文作者从一本叫做《零规则》的书的笔记，主要讲述一家名为 Netflix 的科技公司的经营传奇。</p><p>这家公司是全美员工满意度最高的公司，而「零规则」这几个字，也正是 Netflix 的核心文化之一。</p><p>下面就来讲讲 Netflix 的不同之处：</p><ul><li><p>「零规则」并不是完全没有规则：「零规则」不代表 Netflix 是一家毫无规则的公司，它也有解雇员工的准则，而且可能比其他公司都要狠，甚至连 CEO 都能被解雇；它的零规则指的是它不会花时间制定考勤、打卡、费用报销、上班时长等细则，因为 Netflix 相信自己招聘的肯定是最出色的员工，否则，他们也无法在如此严苛的岗位筛选中存活下来。</p></li><li><p>行业的最高薪资：只招揽最优秀的人才，并且没有固定的涨薪幅度，而是鼓励员工出去面试，根据拿到的 offer 给予对应的涨幅。</p></li><li><p>同事不是家人：许多企业会宣称我们是一个大家庭、同事们都是家人。而 Netflix 认为同事是合作伙伴，而不是家人，因为如果在公司里大家都以家人相称反而会导致不能作出正确的决策。</p></li><li><p>以 Netflix 最大利益为考量：Netflix 采用树形的决策模式，底层员工不需要凡事去请示上司，因为自己才是决定这件事的最佳人选，Netflix 认为员工不会因为这个决定让自己蒙羞。</p></li><li><p>无休假规定也没有固定的工作时长：如果一个人用工作时长的一半就完成了他的工作，剩下的时间他选择阳光海滩。而另一个人每天加班加点，超时工作才能把事情做完，果断给第一个人加工资。</p></li><li><p>信息透明：没有「报喜不报忧」的潜规则，Netflix 认为自家员工都是成年人，有能力辨别什么能说什么不能说。</p></li></ul><h3 id="在生产环境中使你的-npm-i-速度提升-50"><a href="#在生产环境中使你的-npm-i-速度提升-50" class="headerlink" title="在生产环境中使你的 npm i 速度提升 50%"></a><a href="https://shanyue.tech/frontend-engineering/npm-install.html">在生产环境中使你的 npm i 速度提升 50%</a></h3><p><em>原文地址：<a href="https://shanyue.tech/frontend-engineering/npm-install.html">《在生产环境中使你的 npm i 速度提升 50%》 | 山月行</a></em></p><ul><li>选择时延低的 <code>registry</code>，需要企业技术基础建设支持</li><li><code>NODE_ENV=production</code>，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)</li><li><code>CI=true</code>，npm 会在此环境变量下自动优化</li><li>结合 CI 的缓存功能，充分利用 <code>npm cache</code></li><li>使用 <code>npm ci</code> 代替 <code>npm i</code>，既提升速度又保障应用安全性</li></ul><h3 id="浅析-Web-录屏技术方案与实现"><a href="#浅析-Web-录屏技术方案与实现" class="headerlink" title="浅析 Web 录屏技术方案与实现"></a><a href="https://www.zoo.team/article/webrtc-screen">浅析 Web 录屏技术方案与实现</a></h3><p><em>原文地址：<a href="https://www.zoo.team/article/webrtc-screen">《浅析 Web 录屏技术方案与实现》 | zoo</a></em></p><ul><li><p>有感录屏：</p><ul><li><p>有感录屏一般指通过获得用户的授权或者通知用户接下来的操作将会被录制成视频，并且在录制过程中，用户有权关闭中断录屏。即无论在录屏前还是录屏的过程中，用户都始终能够决定录屏能否进行。</p></li><li><p>实现方式：WebRTC。</p></li></ul></li><li><p>无感录屏</p><ul><li><p>无感录屏指在用户无感知的情况，对用户在页面上的操作进行录制。实现上与有感录制区别在于，无感录制通常是利用记录页面的 DOM 来进行录制。常见的有 canvas 截图绘制视频和 rrweb 录制等方案。</p></li><li><p>实现方式：</p><ol><li>canvas</li><li>rrweb</li></ol></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>rrweb 的话只是对 SPA 场景比较好，但对于 微前端/Iframe 场景，它基于 DOM 的回溯就会失效从而失去其录制功能，加上整个 rrweb 链路代码实现复杂度较高，个人认为能用 WebRTC 还是走 RTC 实现比较好。</p><h3 id="如何为你的问题获得有用的答案"><a href="#如何为你的问题获得有用的答案" class="headerlink" title="如何为你的问题获得有用的答案"></a><a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">如何为你的问题获得有用的答案</a></h3><p><em>原文地址：<a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">《How to get useful answers to your questions》 | Julia Evans</a></em></p><ol><li>问一个模糊或未明确指定的问题时，可能出现的问题：<ol><li>这个人首先解释一堆我已经知道的东西</li><li>这个人解释了一些我不知道的事情，但我认为这些事情与我的问题无关</li><li>这个人开始给出相关的解释，但使用我不理解的术语，所以我仍然最终感到困惑</li></ol></li><li>通过问「是否」的问题，可以更快地得到有用的信息。</li><li>如果别人做了一个漫长而无关紧要的解释，可以直接打断</li><li>不接受没有回答你的问题的答案</li></ol><h3 id="谈谈在SQL语句中的优化技巧"><a href="#谈谈在SQL语句中的优化技巧" class="headerlink" title="谈谈在SQL语句中的优化技巧"></a><a href="https://qq52o.me/696.html">谈谈在SQL语句中的优化技巧</a></h3><p><em>原文地址：<a href="https://qq52o.me/696.html">《谈谈在SQL语句中的优化技巧》 | qq52o</a></em></p><p>此文一共列了 30 个优化技巧，内容已经比较精炼了，这里我就不一一列出，有兴趣直接进原文阅读。</p><h3 id="求职时的常见错误"><a href="#求职时的常见错误" class="headerlink" title="求职时的常见错误"></a><a href="https://1byte.io/resume-mistakes/">求职时的常见错误</a></h3><p><em>原文地址：<a href="https://1byte.io/resume-mistakes/">《求职时的常见错误》 | 1 Byte</a></em></p><ul><li>细节：对待简历要认真，一个连简历都不重视细节的人，可想而知在工作中有多马虎。</li><li>精通：慎重「精通」二字，除非你有自信比面试官更熟悉它。</li><li>面试：遇到不会的难题，不要轻易放弃，面试官想要看到的是你如何解决问题。</li></ul><h3 id="如何在-Emacs-里做所有事"><a href="#如何在-Emacs-里做所有事" class="headerlink" title="如何在 Emacs 里做所有事"></a><a href="https://1byte.io/how-to-do-everything-in-emacs/">如何在 Emacs 里做所有事</a></h3><p><em>原文地址：<a href="https://1byte.io/how-to-do-everything-in-emacs/">《如何在 Emacs 里做所有事》| 1 Byte</a></em></p><p>Emacs 简直堪称是一个操作系统，之前有研究过使用 Emacs 下面的 Org-mode 插件来做我的内容管理系统，但是折腾了一下觉得太难上手了，于是转向使用 Notion。</p><p>而本文中的视频就展示了 Emacs 的 Org-mode 强大，有兴趣可以看看。</p><h3 id="小程序单元测试最佳实践"><a href="#小程序单元测试最佳实践" class="headerlink" title="小程序单元测试最佳实践"></a><a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">小程序单元测试最佳实践</a></h3><p><em>原文地址：<a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">《小程序单元测试最佳实践》 | wxsm’s pace</a></em></p><ul><li><p>启动很慢！至少需要 30 秒；因为每个不同的测试文件都需要单独启动并连接一遍实例。</p><ul><li>共享同一个全局实例（×），不起作用。</li><li>将所有测试用例放在单文件中共享实例（×），运行一次需要等到所有测试跑完才能看到结果。</li><li>不通过 launch，直接 connect 到现有窗口（√），只在第一次会比较慢。</li></ul></li><li><p>通过 navigateTo 这类方法跳转很慢：通过点击页面元素的方式触发会比较快。</p></li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>去年年初的时候也曾尝试过在项目中推动微信小程序的 E2E 自动化测试，当时把此文所提到的坑都踩过一遍、连最后选择的解决方案都是一样的。</p><p>之前也有在  Web 项目实践过的 E2E 测试（用的是 Cypress），体验比微信小程序的自动化测试好一万倍不止。不过回头想想，像微信小程序这样不伦不类的产物，本来就是恶心开发者的，还扯什么开发体验呢？</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://polypane.app/css-specificity-calculator">CSS Specificity Calculator</a>：CSS 选择器优先级计算，帮助你快速计算你的 CSS 选择器优先级。</p></li><li><p><a href="https://github.com/2nthony/blogkit">Blogkit</a>：一个朋友的开源项目，利用 Notion API 驱动，将 Notion 作为博客的后台数据库，目前已经支持分发到内置的静态网站以及语雀。</p><ul><li>btw，自从 Notion 开放 API 依赖，将 Notion 作为博客后台数据库的 idea 就层出不穷，并且已经有不少人付诸实践，比如这里还有一个：<a href="https://www.coryetzkorn.com/blog/how-the-notion-api-powers-my-blog">How the Notion API Powers My Blog</a>。 虽然我个人也很喜欢使用 Notion 作为我的资料库，但目前仍没有打算基于它来做博客。</li></ul></li><li><p><a href="https://coderwall.com/">Coderwall</a>：一个开发人员社区的开发和设计技巧、工具和项目，可以从上面学到很多技巧，包括但不限于：Shell、Git、JavaScript、CSS 等。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git tips</title>
      <link href="//post/git-tips.html"/>
      <url>//post/git-tips.html</url>
      
        <content type="html"><![CDATA[<h2 id="批量删除-git-分支"><a href="#批量删除-git-分支" class="headerlink" title="批量删除 git 分支"></a>批量删除 git 分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a | grep -e <span class="string">&quot;fix/&quot;</span> | xargs git branch -D</span><br></pre></td></tr></table></figure><h2 id="批量添加匹配文件到暂存区"><a href="#批量添加匹配文件到暂存区" class="headerlink" title="批量添加匹配文件到暂存区"></a>批量添加匹配文件到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s -uall | grep .vue | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs git add</span><br></pre></td></tr></table></figure><h2 id="按最后提交日期排序所有远程分支"><a href="#按最后提交日期排序所有远程分支" class="headerlink" title="按最后提交日期排序所有远程分支"></a>按最后提交日期排序所有远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv --sort=-committerdate</span><br></pre></td></tr></table></figure><p>更多：<a href="https://stackoverflow.com/questions/5188320/how-can-i-get-a-list-of-git-branches-ordered-by-most-recent-commit">How can I get a list of Git branches, ordered by most recent commit?</a></p><h2 id="更好的-git-log"><a href="#更好的-git-log" class="headerlink" title="更好的 git log"></a>更好的 git log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="列出另外一个分支没有的提交"><a href="#列出另外一个分支没有的提交" class="headerlink" title="列出另外一个分支没有的提交"></a>列出另外一个分支没有的提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry -v branch-A branch-B</span><br></pre></td></tr></table></figure><h2 id="clone-特定分支"><a href="#clone-特定分支" class="headerlink" title="clone 特定分支"></a>clone 特定分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b develop git@github.com:user/myproject.git</span><br></pre></td></tr></table></figure><h2 id="递归移动文件夹"><a href="#递归移动文件夹" class="headerlink" title="递归移动文件夹"></a>递归移动文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv bar/&#123;,.&#125;* .</span><br></pre></td></tr></table></figure><h2 id="列出特定分支的记录"><a href="#列出特定分支的记录" class="headerlink" title="列出特定分支的记录"></a>列出特定分支的记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p branch-name</span><br></pre></td></tr></table></figure><h2 id="查看特定文件的-git-记录"><a href="#查看特定文件的-git-记录" class="headerlink" title="查看特定文件的 git 记录"></a>查看特定文件的 git 记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -- filename</span><br></pre></td></tr></table></figure><h2 id="修改-git-提交为任何人"><a href="#修改-git-提交为任何人" class="headerlink" title="修改 git 提交为任何人"></a>修改 git 提交为任何人</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -c user.name=<span class="string">&quot;NEW NAME&quot;</span> -c user.email=<span class="string">&quot;new_email@gmail.com&quot;</span> commit --amend --date=<span class="string">&quot;Tue Nov 20 03:00 2018 +0100&quot;</span> --author=<span class="string">&quot;NEW NAME &lt;new_email@gmail.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查看当前所有子目录的-git-状态"><a href="#查看当前所有子目录的-git-状态" class="headerlink" title="查看当前所有子目录的 git 状态"></a>查看当前所有子目录的 git 状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 1 -mindepth 1 -<span class="built_in">type</span> d -<span class="built_in">exec</span> sh -c <span class="string">&#x27;(echo &#123;&#125; &amp;&amp; cd &#123;&#125; &amp;&amp; git status -s &amp;&amp; echo)&#x27;</span> \\;</span><br></pre></td></tr></table></figure><h2 id="创建-git-归档时忽略某些目录"><a href="#创建-git-归档时忽略某些目录" class="headerlink" title="创建 git 归档时忽略某些目录"></a>创建 git 归档时忽略某些目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cvfz app.tar.gz --exclude <span class="string">&quot;.git/*&quot;</span> --exclude <span class="string">&quot;.git&quot;</span> app/</span><br></pre></td></tr></table></figure><h2 id="列出未发布的-commit"><a href="#列出未发布的-commit" class="headerlink" title="列出未发布的 commit"></a>列出未发布的 commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> @&#123;u&#125;..</span><br></pre></td></tr></table></figure><h2 id="在所有-commit-中寻找代码"><a href="#在所有-commit-中寻找代码" class="headerlink" title="在所有 commit 中寻找代码"></a>在所有 commit 中寻找代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all | xargs git grep</span><br></pre></td></tr></table></figure><h2 id="找到一个文件是何时被删掉的"><a href="#找到一个文件是何时被删掉的" class="headerlink" title="找到一个文件是何时被删掉的"></a>找到一个文件是何时被删掉的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --diff-filter=D -- path/to/file</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branch</span><br></pre></td></tr></table></figure><h2 id="让-git-可以递归调用"><a href="#让-git-可以递归调用" class="headerlink" title="让 git 可以递归调用"></a>让 git 可以递归调用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.git <span class="string">&#x27;!git&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="revert-cherry-pick"><a href="#revert-cherry-pick" class="headerlink" title="revert cherry-pick"></a>revert cherry-pick</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -p --onto SHA^ SHA</span><br></pre></td></tr></table></figure><h2 id="永久删除文件"><a href="#永久删除文件" class="headerlink" title="永久删除文件"></a>永久删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter <span class="string">&#x27;rm -rf my_folder/my_file&#x27;</span> HEAD</span><br></pre></td></tr></table></figure><h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink = <span class="string">&quot;!f() &#123; echo &quot;</span>https://$(git config --get remote.origin.url | grep --color=never -o -E <span class="string">&#x27;github.com[:/][^\\.]+&#x27;</span> | sed s/\\:/\\\\//)/commit/$(git rev-parse @&#123;u&#125;)<span class="string">&quot;; &#125;; open <span class="subst">$(f)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="仅忽略本地副本的文件更改"><a href="#仅忽略本地副本的文件更改" class="headerlink" title="仅忽略本地副本的文件更改"></a>仅忽略本地副本的文件更改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged &lt;file&gt;</span><br><span class="line"></span><br><span class="line">git update-index --no-assume-unchanged &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="忽略已跟踪的文件"><a href="#忽略已跟踪的文件" class="headerlink" title="忽略已跟踪的文件"></a>忽略已跟踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="获取当前分支名称"><a href="#获取当前分支名称" class="headerlink" title="获取当前分支名称"></a>获取当前分支名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-color 2&gt; /dev/null | sed -e <span class="string">&#x27;/^[^*]/d&#x27;</span> -e <span class="string">&#x27;s/* \(.*\)/\1/&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看某个版本的目录树"><a href="#查看某个版本的目录树" class="headerlink" title="查看某个版本的目录树"></a>查看某个版本的目录树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD~5:hello.txt</span><br><span class="line"></span><br><span class="line">git show awesome-feature:app/models</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> vcs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hg tips</title>
      <link href="//post/hg-tips.html"/>
      <url>//post/hg-tips.html</url>
      
        <content type="html"><![CDATA[<h2 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h2><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>Hg 本身支持简写，如：</p><ul><li>hg status =&gt; hg st</li><li>hg shelve =&gt; hg she</li><li>hg unshelve =&gt; hg unshe</li><li>hg update =&gt; hg up</li><li>hg commit =&gt; hg ci</li><li>hg diff =&gt; hg d</li></ul><p>也可以通过下面几种方式来自定义想要的别名。</p><h4 id="方式一：hg-alias"><a href="#方式一：hg-alias" class="headerlink" title="方式一：hg alias"></a>方式一：hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">amend = commit --amend</span><br><span class="line">br = branch</span><br><span class="line">brs = branches</span><br><span class="line">wip = !<span class="variable">$HG</span> addremove &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="variable">$HG</span> ci -m <span class="string">&quot;--wip-- [skip ci]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg amend</span><br><span class="line">&gt; hg br</span><br><span class="line">&gt; hg brs</span><br><span class="line">&gt; hg wip</span><br></pre></td></tr></table></figure><h4 id="方式二：bash-alias"><a href="#方式二：bash-alias" class="headerlink" title="方式二：bash alias"></a>方式二：bash alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> hgst=<span class="string">&quot;hg status&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hgd=<span class="string">&quot;hg diff&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hga=<span class="string">&quot;hg add&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgst</span><br></pre></td></tr></table></figure><h4 id="方式三：bash-function"><a href="#方式三：bash-function" class="headerlink" title="方式三：bash function"></a>方式三：bash function</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgpl</span><br></pre></td></tr></table></figure><h4 id="方式四：bash-function-hg-alias"><a href="#方式四：bash-function-hg-alias" class="headerlink" title="方式四：bash function + hg alias"></a>方式四：bash function + hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">pl = !<span class="built_in">source</span> ~/.bash_profile &amp;&amp; hgpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg pl</span><br></pre></td></tr></table></figure><h3 id="复制其它分支的-commit"><a href="#复制其它分支的-commit" class="headerlink" title="复制其它分支的 commit"></a>复制其它分支的 commit</h3><p>假设我们有多个分支在并行开发，在 A 分支做了某些改动，希望把这些改动也应用到 B 分支。</p><p>这时候可以用 <a href="https://www.mercurial-scm.org/repo/hg/help/graft">graft</a> 命令将这个 commit 从别的分支复制到当前分支，类似于 Git  <a href="https://git-scm.com/docs/git-cherry-pick">cherry-pick</a> 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg brs</span><br><span class="line">feature/v1                     6:f8528de0eb4c</span><br><span class="line">feature/v1.1                   5:288d0414598d</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -G --style compact</span><br><span class="line">@  6[tip]:1   f8528de0eb4c   2021-12-14 13:04 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-04</span><br><span class="line">|</span><br><span class="line">| o  5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-03</span><br><span class="line">| |</span><br><span class="line">| o  4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-02</span><br><span class="line">| |</span><br><span class="line">| o  3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-00</span><br><span class="line">| |</span><br><span class="line">| o  2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">|/     feat: feature-v1.1-00</span><br><span class="line">|</span><br><span class="line">o  1   431a3844a58c   2021-12-14 12:54 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-01</span><br><span class="line">|</span><br><span class="line">o  0   5d35d7d5baf8   2021-12-14 12:53 +0800   4Ark</span><br><span class="line">     feat: feature-v1</span><br></pre></td></tr></table></figure><p>feature/v1.1 分支是基于 feature/v1 创建的，目前两个分支都分别提交了一些东西，我们希望将 feature/1.1 的最后一个提交（5:288d0414598d）复制到 feature/1 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg update feature/v1</span><br><span class="line">&gt; hg graft -r 5</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r tip --style compact</span><br><span class="line">7[tip]   42cf5e6dfe1e   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><h4 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制单个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个，但有一个例外</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2::5 and not 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整个分支作为一个提交复制过来，如果要编辑提交信息将 -r 改成 --edi</span></span><br><span class="line">&gt; hg graft -r feature/v1.1 --base <span class="string">&quot;ancestor(&#x27;feature/v1.1&#x27;,&#x27;feature/v1&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>如果在 graft 过程中有冲突，可以解决后使用 <code>hg graft --continue</code> 继续进行，或者使用 <code>hg graft --abort</code> 终止本次操作。</p><h3 id="同一个仓库链接到多个目录（worktree）"><a href="#同一个仓库链接到多个目录（worktree）" class="headerlink" title="同一个仓库链接到多个目录（worktree）"></a>同一个仓库链接到多个目录（worktree）</h3><p>如果熟悉 git 的同学应该知道 git 有一个 <a href="https://git-scm.com/docs/git-worktree">worktree</a> 命令，它可以将多个目录链接同一个仓库，并且可以在各自的目录下切换到不同的分支，特别适合以下场景：</p><ol><li>并行开发：在两个不同的分支上开发，不需要频繁回来地切换。</li><li>快速试验、修复：在开发中需要验证、或修复某个 BUG，但不想影响现有的工作目录，就可以在新的工作目录中进行开发。</li><li>代码迁移合并：假如 A 分支和 B 分支版本区别过大，无法直接使用 <code>graft</code>，这时候就可以从新的工作目录中直接拷贝文件。</li></ol><p>其实 hg 也有类似的命令，那就是 <a href="https://www.mercurial-scm.org/wiki/ShareExtension">share</a>，需要先开启扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc </span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">share =</span><br></pre></td></tr></table></figure><p>然后这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg share xxx-project project-v2</span><br><span class="line">&gt; <span class="built_in">cd</span> project-v2</span><br><span class="line">&gt; hg up feature/xxx</span><br></pre></td></tr></table></figure><h2 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h2><p style="color: red; font-weight: bold;">注意：以下操作请谨慎执行，除非有特别声明，否则均只能操作未发布的提交。</p><h3 id="撤销前一次提交"><a href="#撤销前一次提交" class="headerlink" title="撤销前一次提交"></a>撤销前一次提交</h3><p>如果提交后发现某个文件忘记添加了，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/rollback">rollback</a> 进行回滚：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;feat: do something&quot;</span></span><br><span class="line">&gt; hg rollback </span><br></pre></td></tr></table></figure><p>该操作会把最后一次 commit 移除，但这个 commit 的改动仍在。</p><h3 id="回滚某个-commit"><a href="#回滚某个-commit" class="headerlink" title="回滚某个 commit"></a>回滚某个 commit</h3><p>如果想要回滚某个 commit，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/backout">backout</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚最后一个提交</span></span><br><span class="line">&gt; hg backout -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交</span></span><br><span class="line">&gt; hg backout -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交，但先不提交（推荐使用这种方式）</span></span><br><span class="line">&gt; hg backout -r 9487 --no-commit</span><br></pre></td></tr></table></figure><p>效果就和 <code>git revert</code> 一样。</p><h3 id="撤销某个-commit-及其后代"><a href="#撤销某个-commit-及其后代" class="headerlink" title="撤销某个 commit 及其后代"></a>撤销某个 commit 及其后代</h3><p>如果想要撤销某个 commit 及以后的所有改动，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/strip">strip</a>，需要先开启扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">strip =</span><br></pre></td></tr></table></figure><p>然后这样使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除单个</span></span><br><span class="line">&gt; hg strip -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个</span></span><br><span class="line">&gt; hg strip -r 9487 9488</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 commit，但保留改动</span></span><br><span class="line">&gt; hg strip -r 9487--keep</span><br></pre></td></tr></table></figure><p>注意：该操作不属于修改历史，可用于已发布的 commit。</p><h3 id="修改前一次提交"><a href="#修改前一次提交" class="headerlink" title="修改前一次提交"></a>修改前一次提交</h3><p>如果我们在提交一次 commit 后，想要修改 commit 信息，或者想要再做一些改动，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: first commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改一下</span></span><br><span class="line">&gt; hg commit --amend</span><br></pre></td></tr></table></figure><h3 id="修改前-N-次提交"><a href="#修改前-N-次提交" class="headerlink" title="修改前 N 次提交"></a>修改前 N 次提交</h3><p>如果要支持更复杂的修改历史操作，我们可以使用 <a href="https://www.mercurial-scm.org/wiki/HisteditExtension">histedit</a> 扩展，类似于 <code>git rebase -i</code>，使用它能够实现：</p><ul><li>修改某个 commit 的 commit 信息</li><li>移除某个提交</li><li>合并多次提交</li><li>等等..</li></ul><p>需要在 <code>.hgrc</code> 开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">histedit =</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>每次修改后 changeset 都会改变。</li></ul><p>假设，我们现在有下面几个提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg <span class="built_in">log</span> -b . --style compact</span><br><span class="line"></span><br><span class="line">5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br><span class="line"></span><br><span class="line">4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-02</span><br><span class="line"></span><br><span class="line">3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br><span class="line"></span><br><span class="line">2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br></pre></td></tr></table></figure><p>如果只是修改最后一个 commit 信息，我们可以使用 <code>hg commit --amend</code>，如果要修改前几个的 commit 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要修改倒数第三个的 commit 信息</span></span><br><span class="line">&gt; hg histedit 8719f541d5d8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑内容：</span></span><br><span class="line">pick 8719f541d5d8 3 feat: feature-v1.1-00</span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br><span class="line"><span class="comment"># Edit history between 8719f541d5d8 and 288d0414598d</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commits are listed from least to most recent</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can reorder changesets by reordering the lines</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but allow edits before making new commit</span></span><br><span class="line"><span class="comment">#  m, mess = edit commit message without changing commit content</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  b, base = checkout changeset and apply further changesets from there</span></span><br><span class="line"><span class="comment">#  d, drop = remove commit from history</span></span><br><span class="line"><span class="comment">#  f, fold = use commit, but combine it with the one above</span></span><br><span class="line"><span class="comment">#  r, roll = like fold, but discard this commit&#x27;s description and date</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据描述，如果我们只是想要修改 commit 信息，我们可以直接在这里改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ mess 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>但是如果想要修改这个 commit 的改动内容，比如新增一个文件，我们改成这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>这时候就可以改动文件内容，最后再进行提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&#x27;new&#x27;</span> &gt; new-file.txt</span><br><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: feat: feature-v1.1-00(changed)&quot;</span></span><br><span class="line">created new head</span><br><span class="line"></span><br><span class="line">&gt; hg histedit --<span class="built_in">continue</span> <span class="comment"># 你也可以使用 hg histedit --abort 来终止本次操作</span></span><br></pre></td></tr></table></figure><p>如果要移除某个 commit：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ drop 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>如果要合并多个 commit，并且保留所有提交信息：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick 8719f541d5d8 3 feat: feature-v1.1-00  # 只能合并到第一个 commit</span><br><span class="line"><span class="deletion">- pick d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="deletion">- pick 288d0414598d 5 feat: feature-v1.1-03</span></span><br><span class="line"><span class="addition">+ fold d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="addition">+ fold 288d0414598d 5 feat: feature-v1.1-03</span></span><br></pre></td></tr></table></figure><p>如果要合并多个 commit，并且不保留提交信息（直接采用第一个 commit 信息），只需要将 <code>fold</code> 改成 <code>roll</code>。</p><h2 id="查找历史"><a href="#查找历史" class="headerlink" title="查找历史"></a>查找历史</h2><h3 id="查看-commit-的信息"><a href="#查看-commit-的信息" class="headerlink" title="查看 commit 的信息"></a>查看 commit 的信息</h3><p>使用 <a href="https://www.mercurial-scm.org/repo/hg/help/log">log</a> 命令某个提交的信息，通常我们使用 source tree 能够满足大部分日常需求。</p><p>但 log 还支持很多高阶操作，这里举几个最常使用的，推荐配合别名使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支的的 log</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -b .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更清晰地查看 log 历史</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --template <span class="string">&quot;&#123;label(&#x27;custom.rev&#x27;, rev)&#125;\t&#123;label(&#x27;custom.node&#x27;,node|short)&#125; &#123;label(&#x27;custom.phase&#x27;,phase)&#125; \t&#123;label(&#x27;custom.age&#x27;,date|age)&#125;\t&#123;desc|firstline&#125; &#123;label(&#x27;custom.user&#x27;, author|user)&#125; &#123;label(&#x27;custom.branch&#x27;,branch)&#125; &#123;label(&#x27;custom.tag&#x27;,tags)&#125; &#123;label(&#x27;custom.book&#x27;,bookmarks)&#125;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个提交的信息以及文件改动</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -p -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息</span></span><br><span class="line">&lt; hg <span class="built_in">log</span> package.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息（包括删除）</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --remove package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个目录的改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -M src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看多个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 -L package2.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看未发布的提交</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r <span class="string">&quot;draft()&quot;</span></span><br></pre></td></tr></table></figure><h3 id="查看某个文件每一行的最后改动者"><a href="#查看某个文件每一行的最后改动者" class="headerlink" title="查看某个文件每一行的最后改动者"></a>查看某个文件每一行的最后改动者</h3><p>可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/annotate">annotate</a> 命令查看文件中每一行的最后改动者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg annotate -ulc package.json</span><br></pre></td></tr></table></figure><p>ps：该命令还有另一个别名 blame。</p><h3 id="二分法定位出问题的-commit"><a href="#二分法定位出问题的-commit" class="headerlink" title="二分法定位出问题的 commit"></a>二分法定位出问题的 commit</h3><p>如果想知道哪一次代码提交引入了错误，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/bisect">bisect</a> 命令。</p><p>具体操作看阮一峰老师的这篇文章： <a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">《git bisect 命令教程》</a> 。</p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><h3 id="diff-tool-差异对比工具"><a href="#diff-tool-差异对比工具" class="headerlink" title="diff tool 差异对比工具"></a>diff tool 差异对比工具</h3><p>使用一个称手的 diff 工具可帮助你提高很多效率，比如：</p><ul><li>快速对比两个版本的差异</li><li>快速对比两个文件、文件夹的差异</li></ul><p>我个人使用 <a href="https://www.scootersoftware.com/index.php">Beyond Compare</a>，不过这个软件略贵，也可以使用其它同类工具，例如：<a href="https://apps.kde.org/en/kdiff3">KDiff3</a>、<a href="https://winmerge.org/">WinMergeU</a>、<a href="https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge">P4Merge 等。</a></p><p>下面以 Beyond Compare 为例进行配置，其实基本大同小异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line"><span class="comment"># uncomment the lines below to enable some popular extensions</span></span><br><span class="line"><span class="comment"># (see &#x27;hg help extensions&#x27; for more info)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">extdiff =</span><br><span class="line">hgext.extdiff =</span><br><span class="line"></span><br><span class="line">[extdiff]</span><br><span class="line">cmd.bcomp = bcomp</span><br><span class="line">opts.bcomp = -leftreadonly -solo</span><br><span class="line"></span><br><span class="line">[merge-tools]</span><br><span class="line">bcomp.executable = Applications/Beyond Compare.app/Contents/MacOS/bcomp</span><br><span class="line">bcomp.priority=-1</span><br><span class="line">bcomp.args=<span class="variable">$local</span> <span class="variable">$other</span> <span class="variable">$base</span> /mergeoutput=<span class="variable">$output</span> /ro /lefttitle=<span class="built_in">local</span> /centertitle=base /righttitle=other /outputtitle=merged /automerge /reviewconflicts /solo</span><br><span class="line">bcomp.premerge=False</span><br><span class="line">bcomp.regname=ExePath</span><br><span class="line">bcomp.gui=True</span><br><span class="line">bcomp.diffargs=/lro /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /righttitle=<span class="string">&#x27;$clabel&#x27;</span> /solo /expandall <span class="variable">$parent</span> <span class="variable">$child</span></span><br><span class="line">bcomp.diff3args=<span class="variable">$parent1</span> <span class="variable">$parent2</span> <span class="variable">$child</span> /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /centertitle=<span class="string">&#x27;$clabel&#x27;</span> /righttitle=<span class="string">&#x27;$plabel2&#x27;</span> /solo /ro</span><br><span class="line">bcomp.dirdiff=True</span><br><span class="line">bcomp.binary=True</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比某个版本与当前工作区</span></span><br><span class="line">&gt; hg bcomp -r 9816 -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本、分支</span></span><br><span class="line">&gt; hg bcomp -r 9646 -r 9677</span><br><span class="line">&gt; hg bcomp -r default -r 9677</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本的某个文件、文件夹</span></span><br><span class="line">&gt; hg bcomp -r 9552 -r 9553 filepath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个文件夹</span></span><br><span class="line">&gt; bcomp dir-a dir-b</span><br></pre></td></tr></table></figure><p>Beyond Compare 还支持三路比较、合并，就是比较 A 版本、B 版本、C 版本（两者共同祖先），不过要支持这个功能价格就更贵了。</p><h3 id="vscode-hg"><a href="#vscode-hg" class="headerlink" title="vscode-hg"></a>vscode-hg</h3><p>在使用 VSCode 的同学，推荐使用 <a href="https://marketplace.visualstudio.com/items?itemName=mrcrowl.hg">vscode-hg</a> 这个扩展，可支持大部分 hg 操作。</p><p>如果遇到 Mercurial installation not found. 报错 ，在 settings.json 添加配置并重启：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hg.path&quot;</span>: <span class="string">&quot;/opt/homebrew/bin/hg&quot;</span> <span class="comment">// 可通过 which hg 查看 hg 的可执行脚本路径</span></span><br></pre></td></tr></table></figure><p>另外推荐开启  <code>hg.lineAnnotationEnabled</code> ，即可轻松查看当前文件每一行最后改动，类似于 GitLens 扩展。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vcs </tag>
            
            <tag> hg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第2期：珍惜和平</title>
      <link href="//post/weekly-02.html"/>
      <url>//post/weekly-02.html</url>
      
        <content type="html"><![CDATA[<h2 id="俄乌战争"><a href="#俄乌战争" class="headerlink" title="俄乌战争"></a>俄乌战争</h2><p>这是一个技术、踩坑记录、日常吐槽的博客，我本不想给它蒙上太多政治色彩，但原谅我实在是憋不住了。</p><p>2022年2月24号，俄罗斯入侵乌拉克，与此同时，国内的媒体出现了铺天盖地的假信息、在微博、抖音上网友们更是发表了各种极度令人恶心的言论，让我备受震撼。</p><p>你们到底有没有意识到，这可是战争，是要死很多人的！或许你们认为这不关你的事、或许你们认为这只是开开玩笑、又或许你们认为这本就是一场正义的战争。</p><p>每个人都可以有自己的政治立场，但我希望你们积点口德，不要拿这种事情来口嗨。</p><p>我想在此引用几句在网上看到的几句话，也正是我想说的：</p><blockquote><p>我们，强烈反对俄罗斯对乌克兰发动的战争。无论俄罗斯有千种理由，万般借口，以武力入侵一个主权国家都是对以联合国宪章为基础的国际关系准则的践踏，是对现有国际安全体系的破坏。<br /><br>我们，坚决支持乌克兰人民保家卫国的行动。我们担忧俄罗斯的武力行为将导致欧洲乃至整个世界局势的动荡，引发更大范围的人道主义灾难。<br /><br>我们，强烈呼吁俄罗斯政府和普京总统停止战争，用谈判解决纠纷。强权不仅会使文明进步的成果和国际正义的原则毁于一旦，还会给俄罗斯民族带来巨大的耻辱和灾难。<br /><br>和平始于人心的渴望。我们，反对不义战争。</p></blockquote><blockquote><p>没有任何一个战争的挑衅者，值得歌颂。<br /><br>也没有任何一个战争的发起者，值得赞扬。<br /><br>民族主义在现实世界值得提倡，但沦为民粹时就会反噬自己。<br /><br>宏大叙事是审美的一种需要，但如果全民歌颂将让集体万劫不复。<br /></p></blockquote><p>根据 The Kyiv Independent 报道，下面是目前双方的战损情况：</p><div style="display: flex;">    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142093.jpeg">    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142529.jpeg"></div><p>这一串数字的背后，是无数家庭的血和泪！</p><p>请珍惜来之不易的和平，任何为战争欢呼的人都是傻逼！</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="Yes-I-can-connect-to-a-DB-in-CSS"><a href="#Yes-I-can-connect-to-a-DB-in-CSS" class="headerlink" title="Yes, I can connect to a DB in CSS"></a><a href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">Yes, I can connect to a DB in CSS</a></h3><p><em>原文地址：<a href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">《Yes, I can connect to a DB in CSS》 | kamelåså</a></em></p><p><img src="https://www.leemeichin.com/img/yes-i-can-connect-to-a-db-in-css/tweet.jpg"></p><blockquote><p>招聘人员会说：</p><p>我们正在寻找可以使用 CSS 连接到数据库的人。</p></blockquote><p>这能做到吗？是的，这篇文章的作者就做到了。</p><p>首先需要了解两个东西：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini">CSS Houdini</a>：可以通过 JavaScript 访问并控制 CSS 模型，其最大的特点就是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PaintWorklet">PaintWorklet</a>，它可以以编程方式生成一个图像，也与我们所熟悉的 Canvas 类似。</li><li><a href="https://sql.js.org/">sql.js</a>：它是一个 JS 库，允许你在浏览器中创建并查询一个关系型数据库，使用一个存储在浏览器内的虚拟数据库文件，所以数据的存储和修改都不是持久化的；不过它还支持将 SQLite 编译成 Wasm，也就意味着可以在浏览器访问现有的 SQLite 数据库文件。</li></ul><p>做法就是：在 JS 中通过 Houdini 获取 CSS 变量，然后传递给 SQLite 的 DB 实例。</p><p>最终效果看这里：<a href="https://sqlcss.xyz/">https://sqlcss.xyz</a></p><h3 id="我为什么说-Vim-比-VSCode-更好用"><a href="#我为什么说-Vim-比-VSCode-更好用" class="headerlink" title="我为什么说 Vim 比 VSCode 更好用"></a><a href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">我为什么说 Vim 比 VSCode 更好用</a></h3><p><em>原文地址：<a href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">《Why Vim is better than VSCode》 | Sean</a></em></p><p>随着微软开始全面拥抱开源世界，推出了一个又一个大型开源项目，例如 VSCode，就已经在代码编辑器中占据了一个重要的位置，并且随着 <a href="https://github.com/features/codespaces">Codespaces</a> 和 <a href="https://github.com/gitpod-io/openvscode-server">Open VSCode Server</a> 的推出，可以轻松在浏览器上进行远程开发。</p><p>除此之外，微软还开源了一个项目叫做 <a href="https://github.com/xtermjs/xterm.js/">xterm.js</a>，用于 VSCode 的终端，这也让浏览器实现终端功能变得更加简单。</p><p>作者认为相比于 VSCode，还是 Vim更胜一筹，因为它轻巧快熟，可以在服务器上通过 SSH 写代码，所有事情都可以在终端中完成，可移植性和可配置性都非常高，并且基于 xterm.js 也可以轻松实现在浏览器上使用 Vim 进行远程开发。</p><p>它并不像很多人想象得那么难以上手，它甚至让代码写起来就像打游戏一样，因为它的控制方式与游戏相似，都是通过各种命令的组合操作。</p><p>大多数命令有两个、三个或四个部分。三部分结构的一个版本是这样的：操作符（operator）-文本对象（text object）-动作（motion）。</p><p>操作符包括删除（delete）、更改（change）、视觉选择（visual select）和替换（replace），每次选一个使用。</p><p>所以可以这样组合：</p><ul><li>di’ —— 删除（delete）“单引号”内（inside）的内容。</li><li>da” —— 删除“双引号”周围（around）的内容。</li><li>dit —— 删除 html 标签（tag）内的内容。</li><li>ci[ —— 改变（change）[方括号] 内的内容。</li></ul><h5 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h5><p>对于 Vim，我一直在想要学习、放弃之间反复横跳，以至于到现在也只会一些简单的编辑，没有感受过 Vim 命令组合的强大。</p><p>但此文只是举了几个例子，就让我更加了解 Vim 的命令组合，重新燃起我想要学习 Vim 的热情。</p><h2 id="CSS-not-伪类选择器已支持复杂参数"><a href="#CSS-not-伪类选择器已支持复杂参数" class="headerlink" title="CSS :not()伪类选择器已支持复杂参数"></a><a href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">CSS :not()伪类选择器已支持复杂参数</a></h2><p><em>原文地址：<a href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">《CSS :not()伪类选择器已支持复杂参数》 | 张鑫旭</a></em></p><p>新特性：</p><ul><li>支持多个选择器：<code>:not(.a, .b)</code></li><li>权重的区别：无论 :not() 内部有多少个选择器，最终只计算 :not() 本身这一个标签选择器</li></ul><h2 id="Facebook-工程师文化独特之处"><a href="#Facebook-工程师文化独特之处" class="headerlink" title="Facebook 工程师文化独特之处"></a><a href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">Facebook 工程师文化独特之处</a></h2><p><em>原文地址：<a href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">《Facebook 工程师文化独特之处》 | Cat Chen</a></em></p><p>作者在 Facebook 工作了 7 年，结合 Facebook 之前和之后的其它公司的经验， 本文就分享了一些作者觉得属于 Facebook 的独特文化的地方。</p><ul><li>工程师对产品结果负责任<ul><li>工程师考评不只看技术，从高级工程师开始，考评主要看对产品结果的产出</li><li>假如产品的留存率没有得到提高，则工程师、产品经理的考评都会得到惩罚</li><li>鼓励下属自行定义「什么叫做成功」，而不是告诉下属「做什么才能成功」</li></ul></li><li>基础架构被视为内部产品<ul><li>基础架构在公司内部推广</li></ul></li><li>救火比防火更容易获得回报<ul><li>如果你做的事无法量化，即便它是非常有用的，公司也会认为这是无意义的</li><li>举个例子：如果在小镇未发生火灾前，即便消防队长在背后默默做了很多事情防范，大家也不会认为这是你的功劳；相反，只有在发生过一次非常严重的火灾后，你做的事才能体现价值。</li><li>这就是为什么 Facebook 内部那么多问题处于起火状态，因为不起火就没有救火英雄。</li></ul></li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://npm.runkit.com/">NPM RunKit</a>：直接在浏览器中尝试任何 npm 软件包，如果你也曾有过与我一样的经历，想尝试一下某个库的运行结果，由于无法直接在浏览器 console 中运行，最终只能选择在项目内随便找个地方运行的话，那就可以试试这个工具，非常简单快捷，只需在 url 后面补上你想要的 npm 包名，如 <a href="https://npm.runkit.com/dayjs">dayjs</a>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊第1期：搬新家了</title>
      <link href="//post/weekly-01.html"/>
      <url>//post/weekly-01.html</url>
      
        <content type="html"><![CDATA[<h2 id="我为什么要写周刊"><a href="#我为什么要写周刊" class="headerlink" title="我为什么要写周刊"></a>我为什么要写周刊</h2><p>前几天特地写了篇文章来分享一下我为什么要办这个周刊：《<a href="/post/weekly-idea.html">我为什么要写周刊</a>》。</p><h2 id="我搬新家了"><a href="#我搬新家了" class="headerlink" title="我搬新家了"></a>我搬新家了</h2><p>在去年《<a href="/post/2021-summary.html">2021 年度总结</a>》有提到，我曾有过一段开小电动车上班的时光，通勤时间极短，幸福感倍高，但由于公司地址搬迁，就再也没有享受过这样的日子了，即便后来跳槽到新公司，通勤时间缩短了一半，但也要 40 分钟左右的通勤时间，所以，在租房合同到期后，我决定搬到公司附近。</p><p>但搬家真的好累，而且广州这几天连续不断地下雨，心情也变得烦躁起来，搬家过程不太顺利，期间还遗漏了物品在楼下没带上车，幸好楼下的邻居平时关系比较好，愿意帮我保管，第二天又跑回去拿。</p><p>但从明天开始就可以享受极短通勤距离的好处，想想还是蛮开心的。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些我本周阅读过的好文章、以及我的总结和启发；非常建议你阅读原文，而不是只看这些摘要，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错误的。</p></blockquote><h3 id="我对-Svelte-的看法"><a href="#我对-Svelte-的看法" class="headerlink" title="我对 Svelte 的看法"></a><a href="https://lutaonan.com/blog/svelte/">我对 Svelte 的看法</a></h3><p><em>原文地址：<a href="https://lutaonan.com/blog/svelte/">《我对 Svelte 的看法》 | Randy’s Blog</a></em></p><p>简单来说 Svelte 是一个在编译时实现了 Reactivity (反应式) 的框架。</p><p>如何不用 <code>defineProperty</code> 实现 Reactivity：</p><ol><li>只要在每次赋值的时候，手动执行 <code>update</code> 方法</li><li>Svelte 在编译阶段自动帮我们做了这件事</li><li>Svelte 使用了一个 <code>label</code> 语法（$:），实现类似于 Vue 的 <code>computed</code> 功能。</li></ol><p>Svelte 的跨组件通讯：</p><ul><li>通过在变量名前面加一个 $ 实现自动订阅<ul><li>不是黑魔法，只是针对 $ 开头的变量自动转换成 <code>subscribe</code></li></ul></li></ul><p>Svelte 所有功能都在编译阶段完成，并且可以写更少的代码，它相对于 React 和 Vue 更简单，不需要学太多额外的 API 和新语法。</p><p>目前的适用场景：</p><ul><li>适用做来做活动页。</li></ul><h5 id="我的启发"><a href="#我的启发" class="headerlink" title="我的启发"></a>我的启发</h5><p>学习一个框架或者一个语言，并不一定非要把它用到生产上才算真的有用。更多地是因为想看看在面对同一个问题的时候，不同的人解决问题的思路是怎样的，从而帮助我们提高自己的视野，这才是学习框架和语言真正的魅力。</p><h3 id="Svelte-的异步更新实现原理"><a href="#Svelte-的异步更新实现原理" class="headerlink" title="Svelte 的异步更新实现原理"></a><a href="https://lutaonan.com/blog/how-svelte-set-state-works/">Svelte 的异步更新实现原理</a></h3><p><em>原文地址：<a href="https://lutaonan.com/blog/how-svelte-set-state-works/">《Svelte 的异步更新实现原理》 | Randy’s Blog</a></em></p><p>如何异步更新：<strong>将所有导致 UI 更新的操作统一放到一个微任务里执行。</strong></p><p>Svelte 的实际做法：</p><ol><li>一个组件会被编译成一个 fragment</li><li>更新操作通过 <code>$$invalidate</code> 包裹</li><li>触发 <code>schedule_update()</code> ，通知框架需要被更新，框架会维护一个 <code>dirty_components</code> 数组。</li><li>在微任务更新时会统一遍历 <code>dirty_components</code> 数组里的任务，触发组件的更新方法。</li></ol><h3 id="开发模式-“Development-Mode”-是如何工作的？"><a href="#开发模式-“Development-Mode”-是如何工作的？" class="headerlink" title="开发模式 “Development Mode” 是如何工作的？"></a><a href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">开发模式 “Development Mode” 是如何工作的？</a></h3><p><em>原文地址：<a href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">《开发模式 “Development Mode” 是如何工作的？》 | Dan Abramov</a></em></p><p><code>process.env.NODE_ENV</code> 实际上是一个常量，在构建时会被替换成一个字符串，所以判断条件最终是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In development:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;development&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">true</span></span><br><span class="line">  doSomethingDev(); // 👈</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In production:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;production&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">false</span></span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd(); // 👈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上判断条件会被「死码消除」给优化，不被执行的代码将被移除。</p><p>但是，如果写成这样，则不会奏效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mode = <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (mode !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  // 🔴 not guaranteed to be eliminated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 JavaScript 并没有智能到这种程度。</p><h5 id="我的启发-1"><a href="#我的启发-1" class="headerlink" title="我的启发"></a>我的启发</h5><p>以前看 Vue 源码的时候发现很多文件都会重复好几次这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;something error message&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好奇为什么不重构成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">const</span> warn = <span class="function">(<span class="params">condition, message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// something.js</span></span><br><span class="line">warn(xxx, <span class="string">&#x27;something error message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在知道为什么了，因为前者被「死码消除」后，所有相关代码都会被移除，</p><p>而后者，相当于调用了一个空的 <code>warn</code> 方法。</p><p>但没想到在 Vue3 中已经这么做了：<a href="https://github.com/vuejs/core/blob/main/packages/compiler-core/src/errors.ts#L16">defaultOnWarn</a>。</p><p>延伸阅读：<a href="https://segmentfault.com/a/1190000041469096">高效实现框架和 JS 库瘦身</a></p><h3 id="通俗易懂的代数效应"><a href="#通俗易懂的代数效应" class="headerlink" title="通俗易懂的代数效应"></a><a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">通俗易懂的代数效应</a></h3><p><em>原文地址：<a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">《通俗易懂的代数效应》 | Dan Abramov</a></em></p><p>代数效应是什么：</p><ul><li>类似于 try…catch 语法，无论我们在多少层里面 throw 一个错误，外层的 catch 都能捕获到。</li><li>如果内层的 throw 还可以接受从 catch 发送的数据，这就是代数效应。</li><li>使用 async、await 的缺点是我们内部定义了 async、则会影响该函数底部所有的调用者。</li></ul><p>React 中的代数效应：</p><ul><li>JS 并没有一个类似于 try…handle 的语法，但仅在 React 内部可以通过其它方式实现类似的效果。</li><li>典型的场景是：某个组件的渲染是异步的，需要等数据请求返回后再回过来继续渲染。</li></ul><h3 id="防御性-CSS"><a href="#防御性-CSS" class="headerlink" title="防御性 CSS"></a><a href="https://ishadeed.com/article/defensive-css/">防御性 CSS</a></h3><p><em>原文地址：<a href="https://ishadeed.com/article/defensive-css/">《防御性 CSS》 | ishadeed</a></em></p><ol><li>确保 flex 布局能够换行</li><li>确保文字过长时的间距以及换行处理</li><li>防止图片被拉伸或压缩</li><li>弹窗锁定滚动</li><li>CSS 变量回退</li><li>尽量使用 min-height 固定宽度和高度</li><li>确保重置 <code>background-repeat</code></li><li>使用 <code>gap</code> 设置 flex 布局间距</li><li>给图片设置一个 background-color，以确保图片上方的文字能够正常显示</li><li>使用 <code>overflow: auto</code></li><li>图片 <code>object-fit: cover</code></li><li>分组选择器只要有一个无效，则所有选择器不生效</li></ol><h5 id="我的启发-2"><a href="#我的启发-2" class="headerlink" title="我的启发"></a>我的启发</h5><p>了解常用的防御性 CSS ，可以避免很多开发中没有意识到的问题。</p><h3 id="SSR、SSG、ISR、DPR-有什么区别？"><a href="#SSR、SSG、ISR、DPR-有什么区别？" class="headerlink" title="SSR、SSG、ISR、DPR 有什么区别？"></a><a href="http://www.yyyweb.com/5407.html">SSR、SSG、ISR、DPR 有什么区别？</a></h3><p><em>原文地址：<a href="http://www.yyyweb.com/5407.html">《SSR、SSG、ISR、DPR 有什么区别？》 | 前端里</a></em></p><ul><li>CSR（Client Side Rendering）: 客户端渲染<ul><li>缺点：SPA 应用不利于 SEO</li></ul></li><li>SSR（Server Side Rendering）: 服务端渲染<ul><li>优点：利于 SEO</li><li>缺点：需要更多的服务器计算资源和运维成本</li></ul></li><li>SSG（Static Site Generation）: 静态网站生成<ul><li>常年不变的直接生成为静态页面，页面中的动态内容使用 CSR</li><li>缺点：对于网页数量极多的页面，生成一次需要花费很长时间</li></ul></li><li>ISR（Incremental Site Rendering）: 增量式网站渲染<ul><li>关键性页面预渲染，缓存至 CDN；非关键性页面先显示 fallback，再使用 CSR渲染，并且缓存至 CDN</li><li>缺点：需要先显示 fallback 内容，用户体验不好</li></ul></li><li>DPR（Distributed Persistent Rendering）: 分布式持续渲染<ul><li>基于 ISR 的基础上去除 fallback，并且使用「按需构建器」来响应未渲染的页面</li></ul></li></ul><h3 id="不优雅的-React-Hooks"><a href="#不优雅的-React-Hooks" class="headerlink" title="不优雅的 React Hooks"></a><a href="https://zhuanlan.zhihu.com/p/455317250">不优雅的 React Hooks</a></h3><p><em>原文地址：<a href="https://zhuanlan.zhihu.com/p/455317250">《不优雅的 React Hooks》 | 蚂蚁 RichLab 前端团队</a></em></p><p>「奇怪的」规矩：</p><ul><li>命名：react hooks 要求 hooks 命名以 use 开头，作者觉得破坏了语义，应该以 _ 或者 $ 开头</li><li>调用时序：react hooks 区分不同的 state 是通过 hooks 的调用顺序，在内部维护一个链表，这个做法是相对简单粗暴的，所以这就是为什么 hooks 不能条件分支中使用，作者认为这种要求完全需要依赖开发者的经验或者 lint 工具，并不符合直觉。</li><li>useRef 的「排除万难」：useRef 仅在组件 mount 阶段初始化，后面 update 时引用同一个变量，但是作者这样多少有点违反 react hooks 的设计初衷，也即 useRef 并不函数式。</li></ul><p>有缺陷的生命周期：</p><ul><li>构造时：Class Component 和 Function Component 之间存在一个很大的区别，那就是后者每次 re-render 时都在重新调用自身，所以它并没有 constructor 来做某些仅执行一次的操作。</li><li>设计混乱的 useEffect：它实际上只监听能够触发 re-render 的变量，也就是 state，但是它接受的参数 deps 又不做任何限制，很难不让人认为是设计缺陷。</li></ul><p>useCallback：</p><ul><li>性能问题？无限套娃✓：使用 useCallback 是为了解决每次渲染都会创建一个新的回调函数，从而导致重新渲染的问题，但是使用 useCallback 也会引发一个更大的问题，那就是当useCallback之前存在依赖关系时，它们的引用维护也变得复杂。调用某个函数时要小心翼翼，你需要考虑它有没有引用过时的问题，如有遗漏又没有将其加入依赖数组，就会产生 Bug。</li></ul><p>小结：</p><ul><li>本文没有鼓吹 Class Component 拒绝使用 React Hooks 的意思，反而是希望通过细致地比对二者，从而更深入理解 Hooks。</li><li>React Hooks 的各种奇怪之处，也正是潜在症结之所在。</li><li>在 Hooks 之前，Function Component 都是 Stateless 的，小巧、可靠但功能有限。Hooks 为 Function Component 赋予了 State 能力并提供了生命周期，使 Function Component 的大规模使用成为了可能。</li><li>Hooks 的「优雅」来自向函数式的致敬，但useRef的滥用让 Hooks 离「优雅」相去甚远。</li><li>大规模实践 React Hooks 仍然有诸多问题，无论是从语义理解抑或是封装的必要性。</li><li>创新不易，期待 React 官方之后会有更好的设计吧。</li></ul><h3 id="DevTools-实现原理"><a href="#DevTools-实现原理" class="headerlink" title="DevTools 实现原理"></a><a href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">DevTools 实现原理</a></h3><p><em>原文地址：<a href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">《DevTools 实现原理》 | vivo 互联网浏览器内核团队</a></em></p><p>DevTools 架构：</p><ul><li>Chrome：TCP + CDP<ul><li>CDP（Chrome DevTools Protocol） 本质上是一个 JSON 协议，目前使用 Puppeteer 实现</li></ul></li><li>使用 WebSocket</li><li>Android：利用 ADB forward 端口转发能力连接 PC 和 Android 的网络访问</li></ul><p>内核实现</p><ul><li>Server 层，用于接收外部网络发过来的操作请求。</li><li>Agent 层，对于 Server 层发过来的请求，进行拆解，根据操作的类型不同，再分发给不同的 Agent 来处理。</li><li>Session 层，Session 是对不同的业务模块进行了一层抽象。过了 Session 层后，将会进入不同的业务模块，可以到达 V8， Blink 等。</li><li>业务层，就是具体的功能模块，比如 V8 模块，主要负责 JavaScript 的调试相关能力的支撑。</li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://devtool.tech/tree">Tree 树形目录可视化生成器</a>：我们都知道 <code>tree</code> 这个命令，可以打印输出现有目录的树形结构，但现实中还存在一种情况，那就是需要输出并不存在的目录结构，这种需求在写开发设计文档时尤为常见，所以除了构造一个临时的目录，还可以使用这个工具直接生成树形目录结构。</p></li><li><p><a href="https://zh.z-lib.org/">Z-Library</a>：世界上最大的数字图书馆，在这里可以找到大量的电子书籍，格式包括：pdf、epub、mobi 等，对于我这种不爱看实体书的人来说，简直是神器。但需要注意每天一个 ip 会限制下载数量，未注册用户是 5 次，注册用户是 10 次，当然也可以通过捐赠来提高下载次数的限制。</p></li><li><p><a href="https://www.iizhi.cn/">毕方铺</a>：网盘搜索神器，个人认为是所有网盘搜索神器中最好的一个，所有资源都为用户自愿分享，下载需要耗费金币，你也可以上传你想要的分享的资源，别人购买你就能获取金币，当然到达一定金币后就可以提现。</p></li><li><p><a href="https://createfeed.fivefilters.org/index-mergefeeds.php?url%5B%5D=https://medium.com/feed/tag/open-source&max=20&order=feed">Feed Creator</a>：制作 RSS 源的工具，包括网页生成 RSS、合并多个 RSS 等功能；相信有些同学知道 <a href="https://docs.rsshub.app/">RSSHub</a> 这个开源项目，显然这个项目更加强大，但并不是所有场景都需要用到 RSSHub，这时候就可以使用 Feed Creator。分享一下我个人会在什么场景下使用 Feed Creator 而不是 RSSHub：对于某些访问需要科学上网的网站，我们可以直接通过它生成一个国内可以直接访问的 RSS 源。</p></li><li><p><a href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">Microsoft 的 Rust 入门教程</a>：要说这两年前端最新的技术莫过于 Rust 了，大量的前端基础设施都通过 Rust 重写了一遍，哪怕笔者这种学不动的人也需要学一些 Rust 的知识，但无奈一直没有找到满意的 Rust 教程，前段时间听闻微软出了一个 Rust 教程，第一次打开后就直接跟着学了两个星期，根本停不下来，真心不错。xdm，Rust 学起来吧！</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么要写周刊</title>
      <link href="//post/weekly-idea.html"/>
      <url>//post/weekly-idea.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么想写周刊"><a href="#为什么想写周刊" class="headerlink" title="为什么想写周刊"></a>为什么想写周刊</h2><p>自从养成了阅读 RSS 的习惯以后，作为我获取信息的主要渠道，我每天都会花费 1 - 2 个小时去阅读大量的 RSS 订阅源，这其中的大部分基本都是只瞄一眼标题，或者快速阅读一下内容，而对于一些吸引我注意的标题，才会通过浏览器打开原文仔细阅读，当然这么多文章是无法一次性读完的，这时候会通过 <a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">OneTab</a> 扩展先保存起来，也就是充当稍后阅读的工具（题外话：我在 OneTab 上常年保存着 200+ 以上的标签页），如果读到觉得不错的文章，就会通过 <a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm">Save to Notion</a> 这个扩展保存到我的 Notion 页面中，使用这个扩展可以很方便地对文章进行分类、原文剪藏，方便后续快速索引。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121723977.png?imageMogr2/format/webp"></p><p>但是后面我发现，大部分文章读完就忘了，能记下来的往往只有少部分，这是因为我没有针对文章的内容做总结，也就是用自己的话去输出这些文章的核心内容、以及一些更深入的思考，以此加深自己的理解。</p><p>于是，我又开了一个 Notion 页面，利用 Relation 字段去关联文章，大概长这样：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121826436.png?imageMogr2/format/webp"></p><p>但就这样「单机」玩，很难坚持下去，所以就索性把这个 Weekly 挂在 Blog 上，虽然也是基本没人看：）</p><p>但这意义就不一样了呀！无论是对保持更新频率、提高博客逼格都能提到一些帮助（不是吗？）。</p><p>所以，你会发现在 Blog 的顶部菜单栏里面多一个 Weekly 的栏目，当然也提供了 RSS 订阅。</p><h2 id="只是记录阅读吗"><a href="#只是记录阅读吗" class="headerlink" title="只是记录阅读吗"></a>只是记录阅读吗</h2><p>以上的确是我想办这个周刊的初衷，但我并不会局限于此，如果只是分享我阅读过的文章就未免显得过于学术性（流水账），我还是希望我这个周刊既有专业性的内容、也有我个人的一些思考在里面，毕竟有一些琐碎的事情不想专门开一篇文章来长篇大论，就特别适合写在我的周刊里面。还是那句话，我这个周刊的主要读者是我自己，所以这里也充当我一个定时输出我不成熟观点的地方。</p><p>其实已经有不少人在做这件事，就国内而言，最著名的莫过于阮一峰老师的 <a href="https://www.ruanyifeng.com/blog/weekly/">《科技爱好者周刊》</a>，截止本文编写之时，已经更新到 194 期了，几乎坚持每周一更（没有经过仔细核实）。虽然他是一个相对有争议的人，但我还是非常敬佩他，相信很多人和我一样，是通过他的文章来入门前端技术的，所以尊称他一声老师并不为过。</p><p>我不是他最早的一批读者，这当然是因为我比较年轻：），但是我曾经把他博客上所有的文章从头开始读了一遍，从 03 年最早一篇文章开始（可能还是更早），这么多年写作风格自然也有很大的转变，从以前一名愤青，写作文章主要都是关注一些社会、文学、经济等问题，到后来开始转行计算机，主要写一些技术入门、科技新闻的文章。但无论如何，就从他坚持做这件事二十年来看，这种态度非常值得我们学习。</p><p>也有人和我一样，刚刚开始做这件事，这不，前几天就看到了这个：<a href="https://www.codedump.info/post/20220116-weekly-1/">周刊第 1 期：开刊，数字化生活数据</a>。</p><p>总之，我希望和他们一样，通过这种方式来分享自己看到的东西、观点，多给自己一个与外界沟通的渠道。</p><h2 id="开刊日"><a href="#开刊日" class="headerlink" title="开刊日"></a>开刊日</h2><p>由于之前的比较零散，就从 2022 年 2 月 14 号这一天作为这个周刊的开始吧。</p><p>因为这一天意义非凡，首先当然是情人节，另外也是计算机的生日，不过更重要的是这一天也是我生日：）</p><p>可惜我们老家那边普遍过农历生日，所以要每隔 19 年才会碰上同一天生日，这周刊开在三年前就更有意义了。</p><p>不过每次想起我诞生于本世纪第一个情人节，还跟计算机同一天生日，想必我是一个无论在计算机还是感情方面都应该会有很高造诣的人，然而事实证明是我在这两方面都非常菜。</p><p>感谢阅读。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 年度总结</title>
      <link href="//post/2021-summary.html"/>
      <url>//post/2021-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021 已经走到尽头，在这一年中，世界上发生了很多事情，疫情仍在持续，国际形势在不断发生改变，就连娱乐圈你也不知道第二天睡醒后会吃出什么大瓜，总而言之，这又是不平凡的一年。</p><p>但是，仍然有无数像我一样的平凡人在过着平凡的生活，每天生活三点一线，为了生计奔波忙碌。</p><p>本文就记录一个平凡人如何度过他平凡的一年，以此给 2021 年画上一个平凡的句号。</p><p>：）抱歉你可能已经不认识「平凡」这两个字了 </p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><h3 id="Q1：团队解散，找工作"><a href="#Q1：团队解散，找工作" class="headerlink" title="Q1：团队解散，找工作"></a>Q1：团队解散，找工作</h3><p>去年《<a href="https://4ark.me/posts/2020-summary.html#%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%88%90%E9%95%BF">2021 年度总结</a>》中有提到年末时我选择了离开广州，并回到我老家清远，与一位师兄组建了一个创业团队，然而还是太年轻，远远低估了创业这条道路的艰辛和风险，不到三个月团队就解散了。</p><p>深刻反省一下当时做这个决定真的不够慎重，压根没有结合自身情况来考虑这件事情。</p><p>这段时间也并非全无收获，我感觉到在四线城市的生活节奏要相对缓慢一些，比起大城市，我更喜欢这里，因为我这里有家的感觉，她属于我，我也属于她。</p><p>但当务之急就是尽快入职来维持收入，不过这个四线城市没有多少互联网公司，也只能选择广州了，所以最终是在 BOSS 直聘上面海投简历，由于当时正值金三银四的时候，招聘的公司也很多，所以不到两天就把一个星期的面试安排给排满了，当然也是因为我对公司并没多少要求，所以约我面试的公司也没几家算得上是心仪的，总之最终入职了一家郊区的小公司，并在附近租了个房子，这段经历在《<a href="https://4ark.me/post/2021-03-04-2020-feb-summary.html">二月总结</a>》中有提到。</p><h3 id="Q2：那一段悠闲的时光"><a href="#Q2：那一段悠闲的时光" class="headerlink" title="Q2：那一段悠闲的时光"></a>Q2：那一段悠闲的时光</h3><p>虽然大部分公司 HR 在面试的时候都会说公司基本不会加班，但大家懂的都懂：）</p><p>我之前也是待过小公司的，上班时间不会比大公司短，但我入职后，惊讶地发现大家几乎都在晚上六点准时下班。</p><p>由于我住的地方离公司比较近，通勤时间简直可以忽略不计，相当于每天工作只需要 6.5 个小时，我负责的工作内容就是写一些小程序、APP 内嵌的活动页，基本没有什么难度可言，经常会出现一天时间把活干完，剩下几天没事可干的情况。所以上班摸鱼也就习以为常了。但摸了不到一个月觉得这样下去自己迟早会废掉，索性将摸鱼的时间花在读源码上，于是又用了一个月时间把 Vue 生态库的源码都读了一遍，还顺便产出了一些笔记：</p><ul><li><a href="https://4ark.me/post/vuex-score-code.html">《vuex 源码解析》</a></li><li><a href="https://4ark.me/post/composition-api-score-code.html">《composition-api 源码解析》</a></li><li><a href="https://4ark.me/post/vue-router-score-code.html">《vue-router 源码解析》</a></li></ul><p>所以那段时间我的生活写照是这样的：每天睡到九点，起床吃早餐去公司，如果没有工作就自己整点活，主要是看源码，摸到晚上六点就下班去买菜自己回家煮饭，接着看一个小时左右《史记》，在本博客输出一些自己不太成熟的读书感悟：</p><ul><li><a href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">《从思辨中学历史》</a></li><li><a href="https://4ark.me/post/about-si-ma-qian.html">《司马迁是一个什么样的人？》</a></li></ul><p>这可以说是我工作以后过得最悠闲的日子了。</p><h3 id="Q3：那一段痛苦的时光"><a href="#Q3：那一段痛苦的时光" class="headerlink" title="Q3：那一段痛苦的时光"></a>Q3：那一段痛苦的时光</h3><p>可惜好景不长，迎来了一个不好的消息，公司要搬迁，从原本的郊区搬到市中心地段，美名其曰乡巴佬进城了，但我的通勤时间从原本五分钟变成了七十分钟，这无疑是非常痛苦的，通勤时间如此之长足以让任何一份神仙工作的优势荡然无存。</p><p>当然我是可以选择搬家的，说实话我当时也已经在看房了，但突然有一天我破防了，起因是有一天与一个老同学闲聊，得知他跳槽后的薪资已比我高一倍，这让我的焦虑感瞬间就上来了，我自认在学校的时候能力并不比他差，所以我不断反思毕业这两年到底干了些什么？那几天睡觉前都在思考几个问题，是否我现在过得太安逸了？是否我的能力已经早已远远低于别人？我是否应该作出某些改变？</p><p>后面慢慢清醒起来，承认这样的自己并不成熟，我没必要跟任何人比较，虽说工资的高低确实可以从某种程度看出能力的差距，但不代表我现在拿的薪资就是我个人能力真正的写照，因为我这几个月确实可以说是在躺平。</p><p>但我还是有了一些想法，我需要出去面试证明自己的能力，从而让我内心平衡一些，于是我开始复习、刷题。原本的计划是一边复习一边面试，一直到明年的金三银四，再试着挑战一下大厂。然而有一件事打破了我的计划，公司开始延迟发放工资，足足拖了二十天，这自然能从侧面看到目前公司现金流不足，这时候就只能及时止损了。</p><p>于是只能赶鸭子上架出去面试，这一次我没有选择胡乱海投，而是先选择心仪的公司再进行投递，但由于简历上存在不少硬伤，学历低、频繁跳槽，目前 base 低却要求涨幅过高，所以很多公司都不给面试机会，有些公司的 HR 也会拿简历上的硬伤来说事，以此压低薪资，所幸还是有几家比较满意的，这才让我稍微恢复了一些自信。</p><p>最终我选择了一家做科技媒体的公司，因为我本身就是该媒体的读者，并且参与研发的产品也是我比较感兴趣的。</p><h3 id="Q4：那一段充实的时光"><a href="#Q4：那一段充实的时光" class="headerlink" title="Q4：那一段充实的时光"></a>Q4：那一段充实的时光</h3><p>新公司的通勤时间相对上一家要短一半，终于不用每天早起，生活、工作又开始慢慢回到正轨。</p><p>相对上一家公司的悠闲，这里的工作量还是比较饱和的，也逐渐开始习惯。除了完成日常的工作任务以外，也开始整了一点活，比如这个：</p><ul><li><a href="https://github.com/gd4Ark/husky/pull/1">support mercurial repo by gd4Ark</a></li></ul><p>另外还花了一个星期写了一篇技术文章：</p><ul><li><a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a></li></ul><p>值得一提的是，这篇文章在掘金上发布后，被评为每周精选文章，收到奖品：一个马克杯和帆布袋。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615563.image?imageMogr2/format/webp"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615795.png?imageMogr2/format/webp"></p><p style="text-align:center;">懒得拍了，网上找的图</p><p>总的来说，这段时间相对比较充实，不过也有一些习惯被落下了，明年需要重新拾起来。</p><p>再晒一下公司送的新年礼品：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291618945.png?imageMogr2/format/webp"></p><h2 id="年度盘点"><a href="#年度盘点" class="headerlink" title="年度盘点"></a>年度盘点</h2><h3 id="最喜欢的书"><a href="#最喜欢的书" class="headerlink" title="最喜欢的书"></a>最喜欢的书</h3><p>今年看过的书不多，其中比较喜欢的这几本：</p><ul><li><strong>《最初的爱情，最后的仪式》</strong></li><li><strong>《不平等的尸体》</strong></li><li><strong>《人间失格》</strong></li><li><strong>《丑陋的中国人》</strong></li></ul><h3 id="最喜欢的音乐"><a href="#最喜欢的音乐" class="headerlink" title="最喜欢的音乐"></a>最喜欢的音乐</h3><p>今年我从网易云音乐转到了 Spotify，终于可以实现听歌自由了。</p><p>今年最喜欢的音乐：</p><ul><li><strong>《梵高先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/572mdcKFCEMVgtSELmoIuU?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《差不多先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/6fADwOnsMmCM70OAxDF3fc?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《夕阳之歌》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/5tVzG4tw3M9VLkcQ0fOtgF?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><h3 id="最喜欢的电影（电视剧）"><a href="#最喜欢的电影（电视剧）" class="headerlink" title="最喜欢的电影（电视剧）"></a>最喜欢的电影（电视剧）</h3><p>今年喜欢在 Netflix 看剧，所以看了不少的经典高分剧；另外用我的黑群晖下载了一些经典电影。</p><p>为此，我还特地用 notion 做了一个<a href="https://4ark.notion.site/4b4180c7bf3249c2b47bc9127150b240?v=3df58ff87655451c9873a8aadd9a72db">页面</a>，来记录我看过的那些电影（电视剧）。</p><p>这里盘点一下我今年最喜欢的几部电影：</p><ul><li><strong>《杀人回忆》</strong></li><li><strong>《拯救大兵瑞恩》</strong></li><li><strong>《触不可及》</strong></li><li><strong>《指环王系列》</strong></li><li><strong>《金福南杀人事件》</strong></li><li><strong>《出租车司机》</strong>（是罗伯特·德尼罗主演， “Are You Talking to Me?” 那部</li></ul><p>下面是我今年最喜欢的电视剧：</p><ul><li><strong>《权利的游戏》</strong>（如果不烂尾的话多好</li><li><strong>《请回答 1988》</strong></li><li><strong>《性爱自修室》</strong></li><li><strong>《绝命毒师》</strong>、<strong>《风骚律师》</strong></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这就是我平凡的一年，是一个年轻人迷茫的一年，我开始接受自己只是一个极其普通的平凡人，接受自己并不优秀的事实，我也并没有雄心壮志去改变世界，有时候甚至连改变自己都无法做到，我只想好好地活下去，做我喜欢做的事情。</p><p>我很喜欢罗翔老师的这几句话：</p><blockquote><p>人最大的痛苦就是在于无法跨越知道和做到的那个鸿沟。笛卡尔说：“我思故我在”，这个很对，但是，“我思故我在”会经常让我们沉浸于一种幻想之中，就是我们只要思考到了，我们就能做到。但其实不是这样。</p></blockquote><blockquote><p>因为人要接受事与愿违啊。我们太有限了，我们只能做我们觉得对的事情，然后，接受它的事与愿违。</p></blockquote><blockquote><p>我们登上并非我们所选择的舞台，演出并非我们选择的剧本。我们自己一生中能够决定的东西很少，可能只有百分之五的剧本，百分之九十五的东西是我们决定不了的。我们决定不了我们的出身，决定不了我们的智商，更决定不了我们一生中的贵人相助。很多时候我们经常会羡慕别人剧本，但是没有谁的剧本值得羡慕，很多人的剧本就是专门演给别人看的。而你要做的就是演好属于自己的剧本。如果你不幸遇到了某些挫折，你有两种选择，一种是弃演，一种是把既定的剧本演好，即使过程会痛苦，但一定很独特并很精彩。</p></blockquote><p>所以，就算「有人出生在罗马，有人生来是牛马」，我们也不要轻易放弃自己，即便我们并不优秀，你也要去接受，这就是属于你的剧本，无论你的选择是躺平还是奋斗，那是你的自由，没有人可以谴责你。</p><p>最后，以一首西城男孩演唱《平凡之路》，来结束这平凡的 2021。</p><iframe src="//player.bilibili.com/player.html?aid=592381368&bvid=BV17q4y1B7BR&cid=463084542&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2022？"><a href="#2022？" class="headerlink" title="2022？"></a>2022？</h2><p>好好活着。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行 Object.keys() 引发的血案</title>
      <link href="//post/how-object-keys-work.html"/>
      <url>//post/how-object-keys-work.html</url>
      
        <content type="html"><![CDATA[<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>有一天上线后大佬在群里反馈了一个问题，他刚发的动态在生成分享卡片的时候，卡片底部的小程序码丢失了，然而其他小伙伴都表示在自己手机上运行正常。事实上大佬也说除了这条动态以外，其它都是正常的。</p><p>说明这个 BUG 需要特定的动态卡片 + 特定的设备才能复现，所幸坐我对面的小姐姐手机与大佬是同款，也能复现 BUG，避免了作为社恐的我要去找大佬借手机测试的尴尬。</p><p>先交代一下项目背景，这是一个微信小程序项目，其中生成分享卡片功能用到的是一个叫 <a href="https://github.com/wg-front/wxml2canvas">wxml2canvas</a> 的库，然而该库目前看上去已经「年久失修」，上面所说的 BUG 就是因为这个库，本文主要对其进行「鞭尸」之余，顺便分享一下排查该 BUG 的过程、以及如何从 ECMAScript 规范中找到关于 <code>Object.keys()</code> 返回顺序的规范定义，最后介绍一下在 V8 引擎中是如何处理对象属性的。</p><p>希望大家在阅读本文后，不会再因为搞不懂  <code>Object.keys()</code> 输出的顺序而犯错导致产生莫名其妙的 BUG。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><blockquote><p>浪费读者的时间是可耻的。———— 鲁迅</p></blockquote><p>本文很长，如果你不想阅读整篇文章，可以阅读这段摘要；如果你打算阅读整篇文章，那么你完全可以跳过本段。</p><p>如果阅读摘要时未能帮助你理解，可以跳转到对应章节进行详细阅读。</p><p>摘要：</p><ol><li>这个 BUG 是如何产生的？</li></ol><ul><li><code>wxml2canvas</code> 在绘制的时候，会根据一个叫做 <code>sorted</code> 的对象对它的 keys 进行遍历，该对象的 key 为节点的 top 值，value 为节点元素；问题就是出在这里，该库作者误以为 <code>Object.keys()</code> 总是会按照实际创建属性的顺序返回，<strong>然而当 key 为正整数的时候</strong>，返回顺序就不符合原本的预期了，会出现了绘制顺序错乱，从而导致这个 BUG 的产生。</li><li>源码：<a href="https://github.com/wg-front/wxml2canvas/blob/master/src/index.js#L1146">src/index.js#L1146</a> 和 <a href="https://github.com/wg-front/wxml2canvas/blob/master/src/index.js#L829">src/index.js#L829</a></li></ul><ol start="2"><li>如何解决这个 BUG</li></ol><ul><li>由于对象的 key 是一个数字，那么 key 有可能会是整数，也有可能是浮点数。但是预期行为是希望  <code>Object.keys()</code> 按照属性实际创建的顺序返回，那只要将所有 key 都强制转换为浮点数就好了。</li></ul><ol start="3"><li><code>Object.keys()</code> 是按照什么顺序返回值的？</li></ol><ul><li><code>Object.keys()</code> 返回顺序与遍历对象属性时的顺序一样，调用的是 <code>[[OwnPropertyKeys]]()</code> 内部方法。</li><li>根据 <a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys">ECMAScript 规范</a>，在输出 keys 时会<strong>先将所有 key 为数组索引类型（正整数）从小到大的顺序排序，然后将所有字符串类型（包括负数、浮点数）的 key 按照实际创建的顺序来排序</strong>。</li></ul><ol start="4"><li>V8 内部是如何处理对象属性的？</li></ol><ul><li>V8 在存储对象属性时，为了提高访问效率，会分为<strong>常规属性(properties)</strong> 和 <strong>排序属性(elements)</strong><ul><li><strong>排序属性(elements)</strong> ，就是数组索引类型的属性（也就是正整数类型）。</li><li><strong>常规属性(properties)</strong> ，就是字符串类型的属性（也包括负数、浮点数）。</li><li>以上两种属性都会存放在线性结构中，称为<strong>快属性</strong>。</li><li>然而这样每次查询都有一个间接层，会影响效率，所以 V8 引入<strong>对象内属性(in-object-properties)</strong>  。</li></ul></li><li>V8 会为每一个对象关联一个隐藏类，用于记录该对象的形状，相同形状的对象会共用同一个隐藏类。<ul><li>当对象添加、删除属性的时候，会创建一个新的对应的<strong>隐藏类</strong>，并重新关联。</li></ul></li><li><strong>对象内属性</strong>会将部分<strong>常规属性</strong>直接放在对象第一层，所以它访问效率是最高的。<ul><li>当<strong>常规属性</strong>的数量<strong>少于对象初始化时的属性数量</strong>时，<strong>常规属性</strong>会直接作为<strong>对象内属性</strong>存放。</li></ul></li><li>虽然<strong>快属性</strong>访问速度快，但是从线性结构中添加或删除时执行效率会非常低，因此如果属性特别多、或出现添加和删除属性时，就会将<strong>常规属性</strong>从线性存储改为字典存储，这就是<strong>慢属性</strong>。</li></ul><p>可以看一下这两张图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/object-keys.jpeg"></p><p style="text-align:center;">V8 常规属性和排序属性</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/v8-object-keys.jpeg"></p><p style="text-align:center;">V8 对象内属性、快属性和慢属性</p><p style="text-align:center;"><a href="https://time.geekbang.org/column/intro/100048001">图片出处：《图解 Google V8》 —— 极客时间</a></p><h2 id="如何解决该-BUG"><a href="#如何解决该-BUG" class="headerlink" title="如何解决该 BUG"></a>如何解决该 BUG</h2><p>由于是特定的动态 + 特定的设备才能复现问题，可以很轻易地排除掉网络原因，通过在 <code>wxml2canvas</code> 输出绘制的节点列表，也能看到小程序码相关的节点。</p><p>既然 <code>wxml2canvas</code> 已经接收到小程序码的节点，却没有绘制出来，那么问题自然就出在 <code>wxml2canvas</code>  内部，不过已经见怪不怪了，在我加入项目以后就已经多次因为这操蛋的 <code>wxml2canvas</code> 出现各种问题而搞得头皮发麻，有机会一定要替换掉这个库，但由于已经有很多页面在依赖这个库，现在也只能硬着头皮上。</p><p>首先怀疑是小程序码节点的坐标位置不太对，通过对比，发现位置相差不大，排除该原因。</p><p>然后对比所有节点的绘制顺序，发现了一个不太寻常的点，在复现 BUG 的手机上，绘制小程序码节点的时机是比较靠前的，但由于它在卡片底部，所以在正常情况下，应该是比较靠后才对。</p><p>于是通过查看相关代码，果然发现了其中的玄机：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/WechatIMG100.jpeg"></p><p>在绘制的时候，通过遍历 <code>sorted</code> 对象，从上往下、从左到右依次绘制，但是通过对比两台手机的 <code>Object.keys()</code>，发现了它们的输出是不一样的，这时候我就明白怎么回事了。</p><p>先来说说这个 <code>sorted</code> 对象，它是一个 key 为节点 top 值，value 为所有相同 top 值（同一行）的元素数组。</p><p>下面是生成它的代码：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/Snipaste_2021-12-08_00-07-16.png"></p><p>问题就发生在前面所说的 <code>Object.keys()</code> 这里，我们先来看个 🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sorted = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted[<span class="number">300</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">200</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">100</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(sorted)) <span class="comment">// 输出什么呢？</span></span><br></pre></td></tr></table></figure><p>相信大部分同学都知道答案是：[‘100’, ‘200’, ‘300’]。</p><p>如果在有浮点数的情况呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sorted = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted[<span class="number">300</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">100</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">200</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">50.5</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(sorted)) <span class="comment">// 这次又输出什么呢？</span></span><br></pre></td></tr></table></figure><p>会不会有同学以为答案是：[‘50.5’, ‘100’, ‘200’, ‘300’] 呢？</p><p>但正确的答案应该是：[‘100’, ‘200’, ‘300’,’50.5’]。</p><p>所以我合理地猜测 <code>wxml2canvas</code> 的作者就是犯了这样的错误，他可能以为 <code>Object.keys</code>  会根据 key 从小到大的顺序返回，因此满足从上往下绘制的逻辑。但是他却没有考虑浮点数的情况，所以当某个节点 top 值为整数的时候，会比其他 top 值为浮点数的节点更早地绘制，导致绘制后面的节点时覆盖了前面的节点。</p><p>于是，当我把代码改成这样后，分享卡片的小程序码就正常绘制出来了：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Object</span><br><span class="line">  .keys(sorted)</span><br><span class="line"><span class="addition">+ .sort((a, b)=&gt; a - b)</span></span><br><span class="line">  .forEach((top, topIndex) =&gt; &#123;</span><br><span class="line">    //  do something</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OK，搞定收工。</p><p><strong>测试小姐姐</strong>：慢着！影响到其它地方了。</p><p>我一看，果然。于是再次经过对比，发现原来大部分情况下，top 值都会是浮点数，而本次出 BUG 的卡片小程序码只是非常凑巧地为整数，导致绘制顺序不对。</p><p>我才发现 <code>wxml2canvas</code> 原本的逻辑是想根据 <code>sorted</code> 创建的顺序来绘制，但是没有考虑 key 为整数的情况。</p><p>所以，最后这样修改解决问题：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_sortListByTop (list = []) &#123;</span><br><span class="line">    let sorted = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 粗略地认为2px相差的元素在同一行</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line"><span class="deletion">-       let top = item.top;</span></span><br><span class="line"><span class="addition">+       let top = item.top.toFixed(6); // 强制添加小数点，将整数转为浮点数</span></span><br><span class="line">        if (!sorted[top]) &#123;</span><br><span class="line">            if (sorted[top - 2]) &#123;</span><br><span class="line">                top = top - 2;</span><br><span class="line">            &#125;else if (sorted[top - 1]) &#123;</span><br><span class="line">                top = top - 1;</span><br><span class="line">            &#125; else if (sorted[top + 1]) &#123;</span><br><span class="line">                top = top + 1;</span><br><span class="line">            &#125; else if (sorted[top + 2]) &#123;</span><br><span class="line">                top = top + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sorted[top] = [];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[top].push(item);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，是因为 <code>wxml2canvas</code> 作者对 <code>Object.keys()</code> 返回顺序的机制不了解，才导致出现这样的 BUG。</p><p>不知道是否也有同学犯过同样的错误，为避免再次出现这样的情况，非常有必要深入、全面地介绍一下 <code>Object.keys()</code> 的执行机制。 </p><p>所以接下来就跟随我一探究竟吧。</p><h2 id="深入理解-Object-keys"><a href="#深入理解-Object-keys" class="headerlink" title="深入理解 Object.keys()"></a>深入理解 Object.keys()</h2><p>可能会有同学说： <code>Object.keys()</code> 又不是什么新出的 API， Google 一下不就行了，何必大费周章写一篇文章来介绍呢？</p><p>的确通过搜索引擎可以很快就能知道 <code>Object.keys()</code> 的返回顺序是怎样的，但是很多都只流于表面，甚至我还见过这样片面的回答：数字排前面，字符串排后面。</p><p>所以这次我想试着追本溯源，通过第一手资料来获取信息，轻易相信口口相传得来的信息，都极有可能是片面的、甚至是错误的。</p><p>PS：其实不光技术，我们在对待其它不了解的事物都应保持同样的态度。 </p><p>我们先来看看在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">MDN</a> 上关于 <code>Object.keys()</code> 的描述：</p><blockquote><p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p></blockquote><p>emmm… 并没有直接告诉我们输出顺序是什么，不过我们可以看看上面的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys#polyfill">Polyfill</a> 是怎么写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty,</span><br><span class="line">        hasDontEnumBug = !(&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;).propertyIsEnumerable(<span class="string">&#x27;toString&#x27;</span>),</span><br><span class="line">        dontEnums = [</span><br><span class="line">          <span class="string">&#x27;toString&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;toLocaleString&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;valueOf&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;hasOwnProperty&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;isPrototypeOf&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;propertyIsEnumerable&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;constructor&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        dontEnumsLength = dontEnums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">&#x27;function&#x27;</span> || obj === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object.keys called on non-object&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasOwnProperty.call(obj, prop)) result.push(prop);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasDontEnumBug) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; dontEnumsLength; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasOwnProperty.call(obj, dontEnums[i])) result.push(dontEnums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是利用 <code>for...in</code> 来进行遍历，接下来我们可以再看看关于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a> 的文档，然而里面也没有告诉我们顺序是怎样的。</p><p>既然 MDN 上没有，那我们可以直接看 ECMAScript 规范，通常 MDN 上都会附上关于这个 API 的规范链接，我们直接点开最新（Living Standard）的那个，下面是关于 Object.keys 的<a href="https://tc39.es/ecma262/#sec-object.keys">规范定义</a>：</p><blockquote><p>When the keys function is called with argument <em>O</em>, the following steps are taken:</p><ol><li> Let <em>obj</em> be ? <a href="https://tc39.es/ecma262/#sec-toobject">ToObject</a>(<em>O</em>).</li><li> Let <em>nameList</em> be ? <a href="https://tc39.es/ecma262/#sec-enumerableownpropertynames">EnumerableOwnPropertyNames</a>(<em>obj</em>, key).</li><li> Return <a href="https://tc39.es/ecma262/#sec-createarrayfromlist">CreateArrayFromList</a>(<em>nameList</em>).</li></ol></blockquote><p>对象属性列表是通过 <code> EnumerableOwnPropertyNames</code> 获取的，这是它的<a href="https://tc39.es/ecma262/#sec-enumerableownpropertynames">规范定义</a>：</p><blockquote><p>The abstract operation EnumerableOwnPropertyNames takes arguments O (an Object) and kind (key, value, or key+value). It performs the following steps when called:</p><ol><li><p>Let ownKeys be ? O.<a href="">[OwnPropertyKeys]</a>.</p></li><li><p>Let properties be a new empty List.</p></li><li><p>For each element key of ownKeys, do<br> a. If Type(key) is String, then</p><ol><li>Let desc be ? O.<a href="key">[GetOwnProperty]</a>.</li><li>If desc is not undefined and desc.[[Enumerable]] is true, then<br> a. If kind is key, append key to properties.<br> b. Else,<ol><li>Let value be ? Get(O, key).</li><li>If kind is value, append value to properties.</li><li>Else<br> i. Assert: kind is key+value.<br> ii. Let entry be ! CreateArrayFromList(« key, value »).<br> iii. Append entry to properties.</li></ol></li></ol></li><li><p>Return properties.</p></li></ol></blockquote><p><strong>敲黑板！</strong> 这里有个细节，请同学们多留意，后面会考。</p><p>我们接着探索，<code>OwnPropertyKeys</code> 最终返回的 <code>OrdinaryOwnPropertyKeys</code>：</p><blockquote><p>The [[OwnPropertyKeys]] internal method of an ordinary object O takes no arguments. It performs the following steps when called:</p><ol><li>Return ! <a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">OrdinaryOwnPropertyKeys(O)</a>.</li></ol></blockquote><p>重头戏来了，关于 keys 如何排序就在 <code>OrdinaryOwnPropertyKeys</code> 的<a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">定义</a>中：</p><blockquote><p>The abstract operation OrdinaryOwnPropertyKeys takes argument O (an Object). It performs the following steps when called:</p><ol><li>Let keys be a new empty List.</li><li>For each own property key P of O such that P is an array index, in ascending numeric index order, do<br> a. Add P as the last element of keys.</li><li>For each own property key P of O such that Type(P) is String and P is not an array index, in ascending chronological order of property creation, do<br> a. Add P as the last element of keys.</li><li>For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do<br> a. Add P as the last element of keys.</li><li>Return keys.</li></ol></blockquote><p>到这里，我们已经知道我们想要的答案，这里总结一下：</p><ol><li>创建一个空的列表用于存放 keys</li><li>将所有<strong>合法的数组索引</strong>按升序的顺序存入</li><li>将所有<strong>字符串类型索引</strong>按属性创建时间以升序的顺序存入</li><li>将所有 <strong><code>Symbol</code> 类型索引</strong>按属性创建时间以升序的顺序存入</li><li>返回 keys</li></ol><p>这里顺便也纠正一个普遍的误区：有些回答说将所有属性为数字类型的 key 从小到大排序，其实不然，还必须要符合<strong>「合法的数组索引」</strong>，也即只有<strong>正整数</strong>才行，负数或者浮点数，一律当做字符串处理。</p><p>PS：严格来说对象属性没有数字类型的，无论是数字还是字符串，都会被当做字符串来处理。</p><p>我们结合上面的规范，来思考一下下面这段代码会输出什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">testObj[-<span class="number">1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="number">1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="number">1.1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="number">1</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(testObj))</span><br></pre></td></tr></table></figure><p>请认真思考后，在这里核对你的答案是否正确：</p><details>  <summary>查看结果</summary>    <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;<span class="number">1</span>&#x27;, &#x27;<span class="number">2</span>&#x27;, &#x27;<span class="number">-1</span>&#x27;, &#x27;<span class="number">1.1</span>&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure><p>  是否与你想象的一致？你可能会奇怪为什么没有 <code>Symbol</code> 类型。</p><p>  还记得前面敲黑板让同学们留意的地方吗，因为在 <code>EnumerableOwnPropertyNames</code> 的规范中规定了返回值只应包含字符串属性（上面说了数字其实也是字符串）。</p><p>  所以 Symbol 属性是不会被返回的，可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">MDN</a> 上关于 <code>Object.getOwnPropertyNames()</code> 的描述。</p><p>  如果要返回 Symbol 属性可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>。</p></details><p>看完 ECMAScript 的规范定义，相信你不会再搞错 <code>Object.keys()</code> 的输出顺序了。但是你好奇 V8 是如何处理对象属性的吗，下一节我们就来讲讲。</p><h2 id="V8-是如何处理对象属性的"><a href="#V8-是如何处理对象属性的" class="headerlink" title="V8 是如何处理对象属性的"></a>V8 是如何处理对象属性的</h2><p>在 V8 的官方博客上有一篇文章<a href="https://v8.dev/blog/fast-properties">《Fast properties in V8》</a>（<a href="https://blog.crimx.com/2018/11/25/v8-fast-properties/">中译版</a>），非常详细地向我们解释了 V8 内部如何处理 JavaScript 的对象属性，强烈推荐阅读。</p><p>另外再推荐一下极客时间上的课程《<a href="https://time.geekbang.org/column/intro/100048001">图解 Google V8</a>》（毕竟本文借用了里面的图片，怎么好意思不推荐）。</p><p>本节内容主要参考这两个地方，下面我们来总结一下。</p><p>首先，V8 为了提高对象属性的访问效率，将属性分为两种类型：</p><ul><li><p><strong>排序属性(elements)</strong> ，就是符合数组索引类型的属性（也就是正整数）。</p></li><li><p><strong>常规属性(properties)</strong> ，就是字符串类型的属性（也包括负数、浮点数）。</p></li></ul><p>所有的<strong>排序属性</strong>都会存放在一个线性结构中，线性结构的特点就是支持通过索引随机访问，所以能加快访问速度，对于存放在线性结构的属性都称为<strong>快属性</strong>。</p><p><strong>常规属性</strong>也会存放在另一个线性结构中，可以看下面这张图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/object-keys.jpeg" alt="img"></p><p style="text-align:center;">V8 排序属性和常规属性</p><p>但是<strong>常规属性</strong>还需要做一些额外的处理，这里我们要先介绍一下什么是<strong>隐藏类</strong>。</p><p>由于 JavaScript 在运行时是可以修改对象属性的，所以在查询的时候会比较慢，可以看回上面那张图，每次访问一个属性的时候都需要经过多一层的访问，而像 C++ 这类静态语言在声明对象之前需要定义这个对象的结构（形状），经过编译后每个对象的形状都是固定的，所以在访问的时候由于知道了属性的偏移量，自然就会比较快。</p><p>V8 采用的思路就是将这种机制应用在 JavaScript 对象中，所以引入了<strong>隐藏类</strong>的机制，你可以简单的理解<strong>隐藏类</strong>就是描述这个对象的形状、包括每个属性对应的位置，这样查询的时候就会快很多。</p><p>关于<strong>隐藏类</strong>还有几点要补充：</p><ol><li>对象的第一个字段指向它的<strong>隐藏类</strong>。</li><li>如果两个对象的形状是完全相同的，会共用同一个<strong>隐藏类</strong>。</li><li>当对象添加、删除属性的时候，会创建一个新的对应的<strong>隐藏类</strong>，并重新指向它。</li><li>V8 有一个转换树的机制来创建隐藏类，不过本文不赘述，有兴趣可以看<a href="https://v8.dev/blog/fast-properties#hiddenclasses-and-descriptorarrays">这里</a>。</li></ol><p>解释完隐藏类，我们再回头来讲讲<strong>常规属性</strong>，通过上面那张图我们很容易发现一个问题，那就是每次访问一个属性的时候，都需要经过一个间接层才能访问，这无疑降低了访问效率，为了解决这个问题，V8 又引入了一个叫做<strong>对象内属性</strong>，顾名思义，它会将某些属性直接存放在对象的第一层里，它的访问是最快的，如下图所示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/%E4%B8%8B%E8%BD%BD.jpeg"></p><p style="text-align:center;">V8 对象内属性</p><p>但要注意，<strong>对象内属性</strong>只存放<strong>常规属性</strong>，排序属性依旧不变。而且需要常规属性的数量<strong>小于</strong>某个数量的时候才会直接存放<strong>对象内属性</strong>，那这个数量是多少呢？</p><p>答案是取决于<strong>对象初始化时的大小</strong>。</p><p>PS：有些文章说是少于 10 个属性时才会存放对象内属性，<strong>别被误导了</strong>。</p><p>除了<strong>对象内属性</strong>、<strong>快属性</strong>以外，还有一个<strong>慢属性</strong>。</p><p>为什么会有<strong>慢属性</strong>呢？<strong>快属性</strong>虽然访问很快，但是如果要从对象中添加或删除大量属性，则可能会产生大量时间和内存开销来维护<strong>隐藏类</strong>，所以在<strong>属性过多或者反复添加、删除属性时</strong>会将<strong>常规属性</strong>的存储方式从线性结构变成字典，也就是降级到<strong>慢属性</strong>，而由于<strong>慢属性</strong>的信息不会再存放在<strong>隐藏类</strong>中，所以它的访问会比<strong>快属性</strong>要慢，但是可以高效地添加和删除属性。可以通过下图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/v8-object-keys.jpeg" alt="img"></p><p style="text-align:center;">V8 慢属性</p><p>写到这里，我觉得自己对 V8 的快属性、慢属性这些知识已经非常了解，简直要牛逼到上天了。</p><p>但当我看到这段代码的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFastProperties</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*jshint -W027*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    f.prototype = obj;</span><br><span class="line">    ASSERT(<span class="string">&quot;%HasFastProperties&quot;</span>, <span class="literal">true</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">    <span class="built_in">eval</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的心情是这样的：</p><img src="https://ozinparis.com/wp-content/uploads/2016/04/jon-snow-know-nothing-e1461048094110-1.jpg" style="text-align: left; margin-left: 0;" /><p>关于这段代码是如何能让 V8 使用对象<strong>快属性</strong>的可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/25069272">开启 V8 对象属性的“fast”模式</a>。</p><p>另外也可以看一下这段代码：<a href="https://github.com/sindresorhus/to-fast-properties/blob/main/index.js">to-fast-properties/index.js</a>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当在开发时遇到一个简单的错误，通常可以很快地利用搜索引擎解决问题，但如果只是面向 Google 编程，可能在技术上很难会有进步，所以我们不光要能解决问题，还要理解这个产生问题的背后的原因到底是什么，也就是知其然更知其所以然。</p><p>真的非常建议每个 JavaScript 开发者都应该去了解一些关于 V8 或其它 JavaScript 引擎的知识，无论你是通过什么途径（真的没有打广告），这样能保证我们在编写 JavaScript 代码时出现问题可以更加地得心应手。</p><p>最后，本文篇幅有限，部分细节难免会有遗漏，非常建议有兴趣深入了解的同学可以延伸阅读下面的列表。</p><p>感谢阅读。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://v8.dev/blog/fast-properties">Fast properties in V8</a><ul><li><a href="https://blog.crimx.com/2018/11/25/v8-fast-properties/">中译版</a></li></ul></li><li><a href="https://time.geekbang.org/column/intro/100048001">《图解 Google V8》 —— 极客时间</a></li><li><a href="https://blog.dashlane.com/how-is-data-stored-in-v8-js-engine-memory/">How is data stored in V8 JS engine memory?</a></li><li><a href="https://z3rog.tech/blog/2020/fast-properties.html">V8 中的快慢属性与快慢数组</a></li><li><a href="https://zhuanlan.zhihu.com/p/25069272">开启 V8 对象属性的“fast”模式</a></li><li><a href="https://262.ecma-international.org/6.0/">ECMAScript® 2015 Language Specification</a></li><li><a href="https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order">Does JavaScript guarantee object property order? —— stackoverflow</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router 源码解析</title>
      <link href="//post/vue-router-score-code.html"/>
      <url>//post/vue-router-score-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是针对 vue-router <a href="https://github.com/vuejs/vue-router/releases/tag/v3.5.2">v3.5.2</a> 版本的一次源码解析，由于水平有限，有些地方写得比较混乱，还望多多包涵。</p><p>希望本文能够给那些想阅读 vue-router 源代码却又不知从何上手的同学们给予一些帮助。</p><h2 id="一、-new-Router-时发生了什么？"><a href="#一、-new-Router-时发生了什么？" class="headerlink" title="一、 new Router 时发生了什么？"></a>一、 new Router 时发生了什么？</h2><p>对应源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src/index.js</a>，下面讲一下它做了哪些操作：</p><h3 id="1-声明一些变量"><a href="#1-声明一些变量" class="headerlink" title="1. 声明一些变量"></a>1. 声明一些变量</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前实例</span></span><br><span class="line"><span class="built_in">this</span>.app = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 存在多实例的话则保存</span></span><br><span class="line"><span class="built_in">this</span>.apps = []</span><br><span class="line"><span class="comment">// 传入的配置</span></span><br><span class="line"><span class="built_in">this</span>.options = options</span><br><span class="line"><span class="comment">// 存放已注册的一些导航守卫</span></span><br><span class="line"><span class="built_in">this</span>.beforeHooks = []</span><br><span class="line"><span class="built_in">this</span>.resolveHooks = []</span><br><span class="line"><span class="built_in">this</span>.afterHooks = []</span><br><span class="line"><span class="comment">// 创建 matcher</span></span><br><span class="line"><span class="built_in">this</span>.matcher = createMatcher(options.routes || [], <span class="built_in">this</span>)</span><br></pre></td></tr></table></figure><h3 id="2-创建-matcher"><a href="#2-创建-matcher" class="headerlink" title="2. 创建 matcher"></a>2. 创建 <code>matcher</code></h3><p><code>createMatcher</code> 的源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-matcher.js">src/create-matcher.js</a>，这个方法的整体是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  router: VueRouter</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span>(<span class="params">routes</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span>(<span class="params">parentOrRoute, route</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getRoutes</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    raw: RawLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">    currentRoute?: Route,</span></span></span><br><span class="line"><span class="params"><span class="function">    redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">redirect</span>(<span class="params">record: RouteRecord, location: Location</span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">alias</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    record: RouteRecord,</span></span></span><br><span class="line"><span class="params"><span class="function">    location: Location,</span></span></span><br><span class="line"><span class="params"><span class="function">    matchAs: string</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    record: ?RouteRecord,</span></span></span><br><span class="line"><span class="params"><span class="function">    location: Location,</span></span></span><br><span class="line"><span class="params"><span class="function">    redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是两点：</p><ol><li>根据传入的路由配置生成三张表：<code>pathList</code>、 <code>pathMap</code>、 <code>nameMap</code>，这样后面就可以更高效地访问路由表。</li><li>返回一些方法，让它可以获取，操作这三张表。</li></ol><h3 id="3-根据路由配置生成三张表"><a href="#3-根据路由配置生成三张表" class="headerlink" title="3. 根据路由配置生成三张表"></a>3. 根据路由配置生成三张表</h3><p><code>createRouteMap</code> 的源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-route-map.js">src/create-route-map.js</a>，可以点开来对照看。</p><p>我们先不管其它逻辑，只关注它在第一次时是如何生成这三张表的，其核心逻辑是如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  addRouteRecord(pathList, pathMap, nameMap, route, parentRoute)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里给循环调用了 <code>addRouteRecord</code> 方法，它就在同一个文件中，总结一下它做了如下操作：</p><ol><li> 首先检查是否有配置 <code>pathToRegexpOptions</code> 参数，这个属性值是路由高级匹配模式中（<code>path-to-regexp</code>）的参数。</li><li> 调用 <code>normalizePath</code> 将 <code>path</code> 标准化，比较重要的是这里会将子路由的 <code>path</code> 父路由的 <code>path</code> 拼接在一起。</li><li> 处理 <code>caseSensitive</code> 参数，它也是 <code>path-to-regexp</code> 中的参数。</li><li> 声明一个 <code>RouteRecord</code> ，主要代码：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> record: RouteRecord = &#123;</span><br><span class="line">  <span class="attr">path</span>: normalizedPath,</span><br><span class="line">  <span class="comment">// 用于匹配该路由的正则</span></span><br><span class="line">  <span class="attr">regex</span>: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><br><span class="line">  <span class="comment">// 该路由对应的组件，注意这里与 &lt;router-view&gt; 的 name 有关联</span></span><br><span class="line">  <span class="attr">components</span>: route.components || &#123; <span class="attr">default</span>: route.component &#125;,</span><br><span class="line">  <span class="comment">// 路由别名</span></span><br><span class="line">  <span class="attr">alias</span>: route.alias</span><br><span class="line">    ? <span class="keyword">typeof</span> route.alias === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">      ? [route.alias]</span><br><span class="line">      : route.alias</span><br><span class="line">    : []</span><br><span class="line">  <span class="comment">// other property</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 如果该路由存在子路由，则递归调用 <code>addRouteRecord</code> 添加路由记录。</li><li> 将这条 <code>RouteRecord</code> 存入 <code>pathList</code> 。</li><li> 将这条记录以 <code>path</code> 作为 <code>key</code> 存入 <code>pathMap</code> 。</li><li> 如果存在 <code>alias</code> ，则用 <code>alias</code> 作为 <code>path</code> 再添加一条路由记录。</li><li> 如果存在 <code>name</code> ，则以 <code>name</code> 作为 <code>key</code> 存入 <code>nameMap</code>。</li></ol><p>到这里，已经搞懂如何生成这三张表了。</p><h3 id="4-使用一些方法来操作这三张表"><a href="#4-使用一些方法来操作这三张表" class="headerlink" title="4. 使用一些方法来操作这三张表"></a>4. 使用一些方法来操作这三张表</h3><p>接着我们回到 <code>createMatcher</code> 方法内部，可以看到它返回的一些方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  router: VueRouter</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部无非就是根据这三张表来做一些匹配或者改动而已，后面也基本会提到，这里就先略过。<br>​</p><p>到这里 <code>createMatcher</code> 的操作就基本讲完了，下面我们回到 <code>new Router</code> 本身。</p><h3 id="5-检查-mode-，使用对应的路由模式"><a href="#5-检查-mode-，使用对应的路由模式" class="headerlink" title="5. 检查 mode ，使用对应的路由模式"></a>5. 检查 <code>mode</code> ，使用对应的路由模式</h3><p>根据传入的路由配置创建一系列的数据表后，下面就要根据不同的 <code>mode</code> 来做不同的操作，核心代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知，hash 是默认值</span></span><br><span class="line"><span class="keyword">let</span> mode = options.mode || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用了 history 但不支持 pushState 的情况也需要回退到 hash</span></span><br><span class="line"><span class="built_in">this</span>.fallback =</span><br><span class="line">  mode === <span class="string">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.fallback) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非浏览器环境(比如SSR)，则使用 abstract</span></span><br><span class="line"><span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;abstract&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.mode = mode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的 mode 构建不同的 history</span></span><br><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="built_in">this</span>, options.base, <span class="built_in">this</span>.fallback)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于三种 mode 有何不同下面会讲。</p><p>到这里， <code>new Router()</code> 的整个过程就基本讲完了。</p><h2 id="二、-use-Router-时发生了什么？"><a href="#二、-use-Router-时发生了什么？" class="headerlink" title="二、 use Router 时发生了什么？"></a>二、 use Router 时发生了什么？</h2><p>我们知道仅仅通过 <code>new Router()</code> 来构造一个 vue-router 实例后，还需要通过 <code>Vue.use(router)</code> 才能真正在项目中使用它，下面就来讲讲这过程到底发生了什么？</p><h3 id="1-Vue-use-源码"><a href="#1-Vue-use-源码" class="headerlink" title="1. Vue.use 源码"></a>1. Vue.use 源码</h3><p>在这之前，我们先来看看 Vue.use 做了哪些操作，它的源码在 <a href="https://github1s.com/vuejs/vue/blob/HEAD/src/core/global-api/use.js">src/core/global-api/use.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins =</span><br><span class="line">      <span class="built_in">this</span>._installedPlugins || (<span class="built_in">this</span>._installedPlugins = [])</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不长，就是接受一个 <code>plugin</code> ，这个 <code>plugin</code> 要么是一个函数，要么就是一个有 <code>install</code> 方法的对象，然后 Vue 会调用这方法，并且将当前 Vue 作为参数传入，以便插件对 Vue 来进行扩展，最后将 <code>plugin</code> 传入 <code>installedPlugins</code> 中，防止重复调用。</p><h3 id="2-安装-Router"><a href="#2-安装-Router" class="headerlink" title="2. 安装 Router"></a>2. 安装 Router</h3><p>然后我们看看在 Vue 安装 VueRouter 时，VueRouter 会做哪些操作，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/install.js">src/install.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;./components/view&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;./components/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止重复执行</span></span><br><span class="line">  <span class="keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="keyword">return</span></span><br><span class="line">  install.installed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 Vue 存起来并 export 供其它文件使用</span></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function">(<span class="params">v</span>) =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="comment">// router-view 才有 registerRouteInstance 属性</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isDef(i) &amp;&amp;</span><br><span class="line">      isDef((i = i.data)) &amp;&amp;</span><br><span class="line">      isDef((i = i.registerRouteInstance))</span><br><span class="line">    ) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册一个全局 mixin</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="built_in">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._routerRoot = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">this</span>._router = <span class="built_in">this</span>.$options.router</span><br><span class="line">        <span class="comment">// 调用 router.init()，后面会讲</span></span><br><span class="line">        <span class="built_in">this</span>._router.init(<span class="built_in">this</span>)</span><br><span class="line">        <span class="comment">// 使 _router 变成响应式</span></span><br><span class="line">        Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;_route&#x27;</span>, <span class="built_in">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经初始化，继承父组件的 _routerRoot</span></span><br><span class="line">        <span class="built_in">this</span>._routerRoot = (<span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent._routerRoot) || <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册实例，实际上是挂载 &lt;router-view&gt;</span></span><br><span class="line">      registerInstance(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 离开时卸载</span></span><br><span class="line">      registerInstance(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 $router 和 $route 挂载到 Vue 原型上，这样就能在任意 Vue 实例中访问</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._router</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$route&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterView&#x27;</span>, View)</span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterLink&#x27;</span>, Link)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 Vue 合并策略新增几个相关的生命周期</span></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.beforeRouteEnter =</span><br><span class="line">    strats.beforeRouteLeave =</span><br><span class="line">    strats.beforeRouteUpdate =</span><br><span class="line">      strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到它调用了 <code>router.init()</code> 这个方法，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src/index.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">    <span class="comment">// 开发环境下检查是否已安装</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      assert(</span><br><span class="line">        install.installed,</span><br><span class="line">        <span class="string">`not installed. Make sure to call \`Vue.use(VueRouter)\` `</span> +</span><br><span class="line">          <span class="string">`before creating root instance.`</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前 app 实例</span></span><br><span class="line">    <span class="built_in">this</span>.apps.push(app)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 app 销毁时需要在 apps 中移除，由 issue #2639 提出</span></span><br><span class="line">    app.$once(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// clean out app from this.apps array once destroyed</span></span><br><span class="line">      <span class="keyword">const</span> index = <span class="built_in">this</span>.apps.indexOf(app)</span><br><span class="line">      <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) <span class="built_in">this</span>.apps.splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// ensure we still have a main app or null if no apps</span></span><br><span class="line">      <span class="comment">// we do not release the router so it can be reused</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.app === app) <span class="built_in">this</span>.app = <span class="built_in">this</span>.apps[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.app) <span class="built_in">this</span>.history.teardown()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.app) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.app = app</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的 history，由之前 new Router 时根据不同 mode 来创建</span></span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.history</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History || history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">      <span class="keyword">const</span> handleInitialScroll = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = history.current</span><br><span class="line">        <span class="keyword">const</span> expectScroll = <span class="built_in">this</span>.options.scrollBehavior</span><br><span class="line">        <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">          handleScroll(<span class="built_in">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> setupListeners = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">        handleInitialScroll(routeOrError)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">      history.transitionTo(</span><br><span class="line">        history.getCurrentLocation(),</span><br><span class="line">        setupListeners,</span><br><span class="line">        setupListeners</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line">    <span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.apps.forEach(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>相信现在对安装 VueRouter 时的大致流程已经很清楚了，我们还看到了它会调用一些很重要的方法，这些方法会从后面的问题中继续深入探讨。</p><h2 id="三、-切换路由时发生了什么"><a href="#三、-切换路由时发生了什么" class="headerlink" title="三、 切换路由时发生了什么"></a>三、 切换路由时发生了什么</h2><p>下面我们看看 vue-router 在切换路由时做了哪些操作，首先回想一下我们平时使用 vue-router 时有哪些操作可以切换路由？</p><h4 id="切换路由的几种方式"><a href="#切换路由的几种方式" class="headerlink" title="切换路由的几种方式"></a>切换路由的几种方式</h4><p>我们可以通过以下方式切换不同的路由：</p><ol><li>手动触发 URL 更新</li><li>点击 <code>router-link</code></li><li>通过 <code>this.$router</code> 的 <code>push</code> 、<code>replace</code> 等方法</li></ol><h5 id="1-手动触发-URL-更新"><a href="#1-手动触发-URL-更新" class="headerlink" title="1. 手动触发 URL 更新"></a>1. 手动触发 URL 更新</h5><p>只要我们更新了 <code>URL</code> ，vue-router 都会相应执行切换路由的逻辑，能更新 <code>URL</code> 操作有以下：</p><ul><li>如支持 <code>history</code> api<ul><li>history.pushState</li><li>history.replaceState</li><li>history.back</li><li>history.go</li></ul></li><li><code>location.href = &#39;xxx&#39;</code></li><li><code>location.hash = &#39;xxx&#39;</code></li></ul><p>vue-router 是如何监听这些操作的呢？其实只要监听 <code>popstate</code> 或者 <code>hashchange</code> 就可以了，不过这部分留到后面讲 <code>history</code> 实现时再仔细讲，这里先略过。</p><h5 id="2-通过-router-link-切换"><a href="#2-通过-router-link-切换" class="headerlink" title="2. 通过 router-link 切换"></a>2. 通过 <code>router-link</code> 切换</h5><p>还有就是通过 <code>router-link</code> 组件的方式来切换，这个组件相信大家已经很熟悉了，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/link.js">src/components/link.js</a>，我们直接看最关键的部分：<br>​</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件处理，不一定是 click，取决于用户传入的 event</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断用户触发该事件时的行为，具体看下面的 guardEvent 方法</span></span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="comment">// 使用不同的方式来切换路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.replace) &#123;</span><br><span class="line">      router.replace(location, noop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location, noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="keyword">const</span> on = &#123; <span class="attr">click</span>: guardEvent &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.event)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.event.forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    on[e] = handler</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  on[<span class="built_in">this</span>.event] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不处理有媒体键的情况</span></span><br><span class="line">  <span class="comment">// 比如 a 标签可以通过按住 shift 点击链接在新窗口打开，这时候原本的窗口不做任何处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 调用了 preventDefault 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.defaultPrevented) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果是 button，并且不是使用左键单击也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.button !== <span class="literal">undefined</span> &amp;&amp; e.button !== <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果给 a 标签设置了 _blank 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = e.currentTarget.getAttribute(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\b_blank\b/i</span>.test(target)) <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消默认行为，这里要判断是因为在诸如 weex 环境中没有该方法</span></span><br><span class="line">  <span class="keyword">if</span> (e.preventDefault) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显， <code>router-link</code> 本质上也是通过 router 的方法来切换路由，那下面就来看看 router 的方法。</p><h5 id="3-通过-router-的方法切换"><a href="#3-通过-router-的方法切换" class="headerlink" title="3. 通过 router 的方法切换"></a>3. 通过 router 的方法切换</h5><p>通过 router 方法来切换路由主要是三个：</p><ol><li><code>push</code></li><li><code>replace</code></li><li><code>go</code></li></ol><p>当然还有其它的，比如 <code>resolve</code> ，但这个方法并不是切换路由，但只是把对应路由信息返回过来，这里就不谈了。</p><p>其实不同的 <code>mode</code> 它们的实现是不一样的，这里我们就拿最常用的 <code>hash</code> 模式来讲，其它 <code>mode</code> 的方法实现会在后面将不同的 <code>mode</code> 的差异时讨论。</p><p>下面是这些方法在 <code>hash</code> 模式下的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>.transitionTo(</span><br><span class="line">    location,</span><br><span class="line">    <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      replaceHash(route.fullPath)</span><br><span class="line">      handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;,</span><br><span class="line">    onAbort</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.history.go(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了 <code>go</code> 之外（它是通过事件监听器），都是在调用 <code>transitionTo</code> 这个方法，下面我们就看看这个方法的内部。</p><h4 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h4><h5 id="1-调用-transitionTo-方法"><a href="#1-调用-transitionTo-方法" class="headerlink" title="1. 调用 transitionTo 方法"></a>1. 调用 transitionTo 方法</h5><p>前面我们得知切换路由实际上都在调用 <code>transitionTo</code> ，它是一个 <code>History</code> 基类的方法，三种 <code>mode</code> 都是共用的同一个，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">transitionTo</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> route</span><br><span class="line">  <span class="comment">// 这里要 try 一下是因为 match 方法内部会在有 redirect 属性时调用它</span></span><br><span class="line">  <span class="comment">// 但用户提供的 redirect 方法可能会发生报错，所以这里需要捕获到错误回调方法</span></span><br><span class="line">  <span class="comment">// 具体看 issues #3201</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这是根据当前位置匹配路由，下面会讲</span></span><br><span class="line">    route = <span class="built_in">this</span>.router.match(location, <span class="built_in">this</span>.current)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">this</span>.errorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      cb(e)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 依然要抛出异常，让用户得知</span></span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录之前的路由，后面会用到</span></span><br><span class="line">  <span class="keyword">const</span> prev = <span class="built_in">this</span>.current</span><br><span class="line">  <span class="comment">// 这个才是真正切换路由的方法，下面会讲</span></span><br><span class="line">  <span class="built_in">this</span>.confirmTransition(</span><br><span class="line">    <span class="comment">// 传入准备切换的路由</span></span><br><span class="line">    route,</span><br><span class="line">    <span class="comment">// 切换之后的回调</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line">      <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">      <span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      <span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line">      <span class="built_in">this</span>.ensureURL()</span><br><span class="line">      <span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line">      <span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">        hook &amp;&amp; hook(route, prev)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">        <span class="built_in">this</span>.readyCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          cb(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发生错误的回调</span></span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onAbort 回调</span></span><br><span class="line">      <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">        onAbort(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onError 回调</span></span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; !<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">        <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">        <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">        <span class="keyword">if</span> (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) &#123;</span><br><span class="line">          <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">          <span class="built_in">this</span>.readyErrorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段方法中我们得知，要切换路由首先调用 <code>match</code> 方法来匹配到待切换的路由，下面我们看看实现。</p><h5 id="2-调用-match-方法匹配路由"><a href="#2-调用-match-方法匹配路由" class="headerlink" title="2. 调用 match 方法匹配路由"></a>2. 调用 <code>match</code> 方法匹配路由</h5><p>在 <code>transitionTo</code> 中调用的是 <code>router</code> 的 <code>match</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match (raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.matcher.match(raw, current, redirectedFrom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它实际上是调用了 <code>matcher</code> 的 <code>match</code> 方法，这个方法我们之前在 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">创建 match</a> 这一小节有提到过，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 待切换的路由，取值为 字符串 或者 Location 对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  raw: RawLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 当前的路由</span></span></span></span><br><span class="line"><span class="params"><span class="function">  currentRoute?: Route,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 使用重定向方式切换时才会传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">  redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将待切换的路由转换成一个标准的 Location 对象</span></span><br><span class="line">  <span class="comment">// 例如：path 补全、合并 params 等</span></span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(raw, currentRoute, <span class="literal">false</span>, router)</span><br><span class="line">  <span class="comment">// 待切换路由的 name</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="comment">// 有 name 属性的时候直接通过 nameMap 获取，根本无需遍历，非常高效</span></span><br><span class="line">    <span class="keyword">const</span> record = nameMap[name]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      warn(record, <span class="string">`Route with name &#x27;<span class="subst">$&#123;name&#125;</span>&#x27; does not exist`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该路由不存在，创建一个空的路由记录</span></span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    <span class="comment">// 获取可以从父路由中继承的 param 参数</span></span><br><span class="line">    <span class="keyword">const</span> paramNames = record.regex.keys</span><br><span class="line">      .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !key.optional)</span><br><span class="line">      .map(<span class="function">(<span class="params">key</span>) =&gt;</span> key.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  params 需要为对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> location.params !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      location.params = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承父路由的 param 参数</span></span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; <span class="keyword">typeof</span> currentRoute.params === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> currentRoute.params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> location.params) &amp;&amp; paramNames.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          location.params[key] = currentRoute.params[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 path 和 param 合并为 URL</span></span><br><span class="line">    location.path = fillParams(</span><br><span class="line">      record.path,</span><br><span class="line">      location.params,</span><br><span class="line">      <span class="string">`named route &quot;<span class="subst">$&#123;name&#125;</span>&quot;`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建路由记录</span></span><br><span class="line">    <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.path) &#123;</span><br><span class="line">    <span class="comment">// 如果是通过 path 跳转，则需要通过遍历 pathList 匹配对应的路由</span></span><br><span class="line">    location.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pathList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = pathList[i]</span><br><span class="line">      <span class="keyword">const</span> record = pathMap[path]</span><br><span class="line">      <span class="comment">// 检查路径与当前遍历到的路由是否匹配，该方法下面会讲</span></span><br><span class="line">      <span class="keyword">if</span> (matchRoute(record.regex, location.path, location.params)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找不到匹配的则创建一条空的路由记录</span></span><br><span class="line">  <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是通过 <code>path</code> 的方式跳转，由于 <code>path</code> 可能会携带一些 <code>params</code> 的信息，前面我们已经提到过<a href="#%E4%B8%80%E3%80%81-new-router-%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">初始化路由</a>信息时，会为每条路由生成一个正则表达式，所以这里就可以根据这个正则来检查是否符合当前路由，也就是上面提到 <code>matchRoute</code> 作用，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchRoute</span>(<span class="params">regex: RouteRegExp, path: string, params: <span class="built_in">Object</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = path.match(regex)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">    <span class="comment">// 不匹配则直接退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!params) &#123;</span><br><span class="line">    <span class="comment">// 如果匹配并且该路由没有声明 param 参数，则匹配成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将使用正则匹配到的 param 参数放入 params 对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = m.length; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = regex.keys[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      <span class="comment">// Fix #1994: using * with props: true generates a param named 0</span></span><br><span class="line">      params[key.name || <span class="string">&#x27;pathMatch&#x27;</span>] =</span><br><span class="line">        <span class="keyword">typeof</span> m[i] === <span class="string">&#x27;string&#x27;</span> ? decode(m[i]) : m[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，关于如何匹配对应的路由已经讲完了，下面我们讲讲匹配到之后它还会做什么？</p><h5 id="3-调用-confirmTransition-方法"><a href="#3-调用-confirmTransition-方法" class="headerlink" title="3. 调用 confirmTransition 方法"></a>3. 调用 confirmTransition 方法</h5><p>前面我们在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 时讲到它拿到匹配的路由之后，就会调用 <code>confirmTransition</code> 方法，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为待跳转路由有可能是一个异步组件，所以设计成有回调的方法</span></span><br><span class="line"><span class="function"><span class="title">confirmTransition</span>(<span class="params">route: Route, onComplete: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 跳转前的的路由（from）</span></span><br><span class="line">  <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">  <span class="comment">// 待跳转的路由（to）</span></span><br><span class="line">  <span class="built_in">this</span>.pending = route</span><br><span class="line">  <span class="comment">// 错误时的回调</span></span><br><span class="line">  <span class="keyword">const</span> abort = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// changed after adding errors with</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span></span><br><span class="line">    <span class="comment">// redirect and aborted navigation would produce an err == null</span></span><br><span class="line">    <span class="keyword">if</span> (!isNavigationFailure(err) &amp;&amp; isError(err)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.errorCbs.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          cb(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="literal">false</span>, <span class="string">&#x27;uncaught error during route navigation:&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onAbort &amp;&amp; onAbort(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lastRouteIndex = route.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> lastCurrentIndex = current.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 判断是否相同路径</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isSameRoute(route, current) &amp;&amp;</span><br><span class="line">    <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">    lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">    route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 依旧切换</span></span><br><span class="line">    <span class="built_in">this</span>.ensureURL()</span><br><span class="line">    <span class="comment">// 报一个重复导航的错误</span></span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 from 和 to的 matched 数组拿到新增、更新、销毁的部分，以便执行组件的生命周期</span></span><br><span class="line">  <span class="comment">// 该方法下面会仔细讲</span></span><br><span class="line">  <span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">    <span class="built_in">this</span>.current.matched,</span><br><span class="line">    route.matched</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line">  <span class="comment">// 这里的顺序可以看回前面讲的完整的导航解析流程，具体实现下面会讲</span></span><br><span class="line">  <span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">    <span class="comment">// in-component leave guards</span></span><br><span class="line">    extractLeaveGuards(deactivated),</span><br><span class="line">    <span class="comment">// global before hooks</span></span><br><span class="line">    <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">    <span class="comment">// in-component update hooks</span></span><br><span class="line">    extractUpdateHooks(updated),</span><br><span class="line">    <span class="comment">// in-config enter guards</span></span><br><span class="line">    activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter),</span><br><span class="line">    <span class="comment">// async components</span></span><br><span class="line">    resolveAsyncComponents(activated)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line">  <span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">    <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">    <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">      hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">        <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">        <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">          <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(createNavigationAbortedError(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">          <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">          (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || typeofto.name === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">          abort(createNavigationRedirectedError(current, route))</span><br><span class="line">          <span class="comment">// 判断切换类型</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replace(to)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.push(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">          <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">          next(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      abort(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行队列，下面仔细讲</span></span><br><span class="line">  runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">    <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line">    <span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">        <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          handleRouteEntered(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-构造导航守卫队列"><a href="#4-构造导航守卫队列" class="headerlink" title="4. 构造导航守卫队列"></a>4. 构造导航守卫队列</h5><p>我们知道在切换路由时需要执行一系列的导航守卫和路由相关的生命周期，下面就讲讲它的实现，其实也是在 <code>confirmTransition</code> 这个方法中。<br>​</p><p>第一步就是构造队列，关于它们执行的顺序可以看回文档。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line"><span class="comment">// 注意：这里只是完整迭代导航解析流程中的 2~6 步</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">  <span class="comment">// 调用此次失活的部分组件的 beforeRouteLeave</span></span><br><span class="line">  extractLeaveGuards(deactivated),</span><br><span class="line">  <span class="comment">// 全局的 before 钩子</span></span><br><span class="line">  <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">  <span class="comment">// 调用此次更新的部分组件的 beforeRouteUpdate</span></span><br><span class="line">  extractUpdateHooks(updated),</span><br><span class="line">  <span class="comment">// 调用此次激活的路由配置的 beforeEach</span></span><br><span class="line">  activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter),</span><br><span class="line">  <span class="comment">// 解析异步组件</span></span><br><span class="line">  resolveAsyncComponents(activated)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还记得前面我们讲了 <code>updated, deactivated, activated</code> 这三个数组是从 <code>resolveQueue</code> 方法中获取：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">  <span class="built_in">this</span>.current.matched,</span><br><span class="line">  route.matched</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  current: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  next: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): </span>&#123;</span><br><span class="line">  <span class="attr">updated</span>: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  activated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(current.length, next.length)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current[i] !== next[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">updated</span>: next.slice(<span class="number">0</span>, i),</span><br><span class="line">    <span class="attr">activated</span>: next.slice(i),</span><br><span class="line">    <span class="attr">deactivated</span>: current.slice(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理很简单，只需要对比 <code>current</code> 和 <code>next</code> 的 <code>match</code> 数组，就能拿到以下数组：</p><ol><li><code>updated</code>：有交集的部分</li><li><code>activated</code>：next 有并且 current 没有的部分</li><li><code>deactivated</code>：current 有并且 next 没有的部分</li></ol><p>下面是队列中各项的实现</p><ol><li>调用 <code>extractLeaveGuards(deactivated)</code> 执行销毁的组件 <code>beforeRouteLeave</code> 生命周期：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractLeaveGuards</span>(<span class="params">deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个参数为 true 是因为这个生命周期要倒序执行，先执行子路由的再执行父路由的</span></span><br><span class="line">  <span class="keyword">return</span> extractGuards(deactivated, <span class="string">&#x27;beforeRouteLeave&#x27;</span>, bindGuard, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用全局的 <code>beforeHooks</code> ，其实也就是存放用户通过 <code>beforeEach</code> 注册的数组：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeEach (fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> registerHook(<span class="built_in">this</span>.beforeHooks, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用 <code>extractUpdateHooks(updated)</code> 执行更新的组件：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractUpdateHooks</span>(<span class="params">updated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extractGuards(updated, <span class="string">&#x27;beforeRouteUpdate&#x27;</span>, bindGuard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用所有激活组件的 <code>beforeEnter</code> 生命周期：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter)</span><br></pre></td></tr></table></figure><ol start="5"><li>调用 <code>resolveAsyncComponents(activated)</code> 来解析异步组件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponents</span>(<span class="params">matched: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个队列钩子函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于标记是否异步组件</span></span><br><span class="line">    <span class="keyword">let</span> hasAsync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 待加载的组件数量</span></span><br><span class="line">    <span class="keyword">let</span> pending = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否加载错误</span></span><br><span class="line">    <span class="keyword">let</span> error = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法下面会讲，主要作用是依次遍历传入的 matched 数组相关的 component</span></span><br><span class="line">    flatMapComponents(matched, <span class="function">(<span class="params">def, _, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否异步组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">&#x27;function&#x27;</span> &amp;&amp; def.cid === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        hasAsync = <span class="literal">true</span></span><br><span class="line">        pending++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件的 chunk 后执行</span></span><br><span class="line">        <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">resolvedDef</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (isESModule(resolvedDef)) &#123;</span><br><span class="line">            resolvedDef = resolvedDef.default</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将它变成一个 vue 组件</span></span><br><span class="line">          <span class="comment">// save resolved on async factory in case it&#x27;s used elsewhere</span></span><br><span class="line">          def.resolved =</span><br><span class="line">            <span class="keyword">typeof</span> resolvedDef === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">              ? resolvedDef</span><br><span class="line">              : _Vue.extend(resolvedDef)</span><br><span class="line">          <span class="comment">// 把解析好的组件更新到当前路由记录中</span></span><br><span class="line">          match.components[key] = resolvedDef</span><br><span class="line">          pending--</span><br><span class="line">          <span class="comment">// 如果已经加载完则调用 next 进入下一个队列</span></span><br><span class="line">          <span class="keyword">if</span> (pending &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            next()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件失败后执行</span></span><br><span class="line">        <span class="keyword">const</span> reject = once(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 报个错</span></span><br><span class="line">          <span class="keyword">const</span> msg = <span class="string">`Failed to resolve async component <span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;reason&#125;</span>`</span></span><br><span class="line">          process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(<span class="literal">false</span>, msg)</span><br><span class="line">          <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            error = isError(reason) ? reason : <span class="keyword">new</span> <span class="built_in">Error</span>(msg)</span><br><span class="line">            next(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是调用 webpack 方法加载这个组件，返回的是一个 Promise</span></span><br><span class="line">          res = def(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">          <span class="comment">// 这里才真正加载这个组件</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> res.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            res.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// new syntax in Vue 2.3</span></span><br><span class="line">            <span class="keyword">const</span> comp = res.component</span><br><span class="line">            <span class="keyword">if</span> (comp &amp;&amp; <span class="keyword">typeof</span> comp.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              comp.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是异步则直接 next</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAsync) next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步加载这一块其实涉及比较多，深入讲的话还要讲 <code>webpack</code> ，所以这里只讲大概的流程，以后有机会的话再深入讲解。</p><p>可以看到执行导航守卫都是通过调用一个 <code>extractGuards</code> 方法，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// records: routerRecord 数组</span></span><br><span class="line"><span class="comment">// name 钩子的名字</span></span><br><span class="line"><span class="comment">// bind 就是 bindGuard 方法，下面会讲</span></span><br><span class="line"><span class="comment">// reverse 是否倒序执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuards</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  records: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  name: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  bind: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reverse?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> guards = flatMapComponents(records, <span class="function">(<span class="params">def, instance, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> guard = extractGuard(def, name)</span><br><span class="line">    <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(guard)</span><br><span class="line">        ? guard.map(<span class="function">(<span class="params">guard</span>) =&gt;</span> bind(guard, instance, match, key))</span><br><span class="line">        : bind(guard, instance, match, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> flatten(reverse ? guards.reverse() : guards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仔细讲这个方法内部逻辑前，要先搞清楚这三个方法的内部： <code>extractGuard</code> 、 <code>bindGuard</code> 、 <code>flatMapComponents</code> ：</p><p><code>extractGuard</code> 很简单，其实就是获取 vue 组件实例中特定的生命周期：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuard</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  def: <span class="built_in">Object</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: string</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">NavigationGuard</span> | <span class="title">Array</span>&lt;<span class="title">NavigationGuard</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> def !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// extend now so that global mixins are applied.</span></span><br><span class="line">    def = _Vue.extend(def)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> def.options[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bindGuard</code> 的作用就是返回一个函数，这个函数会调用组件特定生命周期，给后续执行队列时调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guard：某个生命周期钩子</span></span><br><span class="line"><span class="comment">// instance：执行的 vue 实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindGuard</span>(<span class="params">guard: NavigationGuard, instance: ?_Vue</span>): ?<span class="title">NavigationGuard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 这时只是返回这个方法，没有立即调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">boundRouteGuard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用这个钩子</span></span><br><span class="line">      <span class="keyword">return</span> guard.apply(instance, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>flatMapComponents</code> 顾名思义就是跟组件相关的，它的作用是依次遍历传入的 <code>matched</code> 数组相关的组件，并调用传入的回调的返回值作为自己的返回值，所以它的返回值是调用者决定的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatMapComponents</span>(<span class="params">matched, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flatten(</span><br><span class="line">    matched.map(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(m.components).map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(m.components[key], m.instances[key], m, key)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在再回过头来看 <code>extractGuards</code> 就很清晰了，它的作用就是通过 <code>flatMapComponents</code> 遍历所有 <code>match</code> 数组中的组件，并通过 <code>extractGuard</code> 拿到这些组件的特定生命周期，然后通过 <code>bindGuard</code> 返回一个可以调用这个生命周期的函数，然后利用 <code>flatten</code> 将它们扁平化，根据 <code>reverse</code> 决定是否倒序返回这些函数数组。</p><p>最后这些函数全部放在 <code>queue</code> 中，这就是构造整个队列的过程了。</p><h5 id="5-执行队列"><a href="#5-执行队列" class="headerlink" title="5. 执行队列"></a>5. 执行队列</h5><p>构造完队列，下面就要开始执行这个队列了，在这之前我们先来看看 <code>runQueue</code> 的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  fn: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cb: <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也不复杂，首先从 0 开始按顺序遍历 <code>queue</code> 中的每一项，在调用 <code>fn</code> 时作为第一个参数传入，当使用者调用了第二个参数的回调时，才进入下一次项，最后遍历完 <code>queue</code> 中所有的项后，调用 <code>cb</code> 回到参数。</p><p>下面是执行这个队列的过程：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行队列</span></span><br><span class="line"><span class="comment">// queue 就是上面那个队列</span></span><br><span class="line"><span class="comment">// iterator 传入 to、from、next，只有执行 next 才会进入下一项</span></span><br><span class="line"><span class="comment">// cb 回调函数，当执行完整个队列后调用</span></span><br><span class="line">runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">  <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">  <span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line">  <span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">  runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    onComplete(route)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">      <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleRouteEntered(route)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>iterator</code> 的定义在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 这一小节中已经有提到了，这里拷贝一份过来：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">  <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">  <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">    hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">      <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">      <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">        <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(createNavigationAbortedError(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(to)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">        <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">          (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || typeofto.name === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">        abort(createNavigationRedirectedError(current, route))</span><br><span class="line">        <span class="comment">// 判断切换类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">          <span class="built_in">this</span>.replace(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.push(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">        <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">        next(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    abort(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们留意到这里其实是嵌套执行了两次 <code>runQueue</code> ，这是因为我们前面构造的 <code>queue</code> 只是 vue-router 完整的导航解析流程中的 第 2<del>6 步，而接下来就要执行第 7</del>9 步：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这时候异步组件已经解析完成</span></span><br><span class="line"><span class="comment">// 下面是构造 beforeRouteEnter 和 beforeResolve 守卫的队列</span></span><br><span class="line"><span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line"><span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 这里是调用 transitionTo 传入的 onComplete 回调</span></span><br><span class="line">  <span class="comment">// 在这里会做一些更新路由、URL、调用 afterHooks、onReady 等回调，下面就讲</span></span><br><span class="line">  onComplete(route)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">    <span class="comment">// 下次更新 DOM 时触发 handleRouteEntered</span></span><br><span class="line">    <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO 不太明白这个方法的内部</span></span><br><span class="line">      handleRouteEntered(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="6-执行-confirmTransition-后的操作"><a href="#6-执行-confirmTransition-后的操作" class="headerlink" title="6. 执行 confirmTransition 后的操作"></a>6. 执行 <code>confirmTransition</code> 后的操作</h5><p>到这里 <code>confirmTransition</code> 方法就已经执行完了，最后会调用 <code>transitionTo</code> 传入的 <code>onComplete</code> 方法，之前就有提到：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line"><span class="built_in">this</span>.updateRoute(route)</span><br><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; onComplete(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="built_in">this</span>.ensureURL()</span><br><span class="line"><span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line"><span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">  hook &amp;&amp; hook(route, prev)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">  <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">  <span class="built_in">this</span>.readyCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    cb(route)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了几步：更新当前路由、调用传入的 <code>onComplete</code> 、更新 <code>URL</code> 、调用 <code>afterHooks</code> 、 <code>onReady</code> 钩子。</p><p>而如果 <code>confirmTransition</code> 执行失败的话，则会执行传入的 <code>onAbort</code> ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">  onAbort(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (err &amp;&amp; !<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">  <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">  <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isNavigationFailure(err, NavigationFailureType.redirected) ||</span><br><span class="line">    prev !== START</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.readyErrorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      cb(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是调用传入的 <code>onAbort</code> 回调，执行 <code>onError</code> 钩子。</p><p>到这里整个 <code>transitionTo</code> 方法的执行过程已经讲完了，导航守卫和一些钩子函数也已经全部执行完毕。<br>​</p><h5 id="7-更新路由信息"><a href="#7-更新路由信息" class="headerlink" title="7. 更新路由信息"></a>7. 更新路由信息</h5><p>接着我们看看它是如何更新当前路由信息的，也就是 <code>updateRoute</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateRoute</span>(<span class="params">route: Route</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = route</span><br><span class="line">    <span class="built_in">this</span>.cb &amp;&amp; <span class="built_in">this</span>.cb(route)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是更新一下 <code>current</code> 的指向，接着调用 <code>cb</code> 这个回调函数并且将当前路由传入，那这个 <code>cb</code> 是什么东西呢？它是在 <code>listen</code> 方法中被赋值的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span>(<span class="params">cb: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而哪里调用了这个 <code>listen</code> 方法呢？我们看回之前在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时初始化那里的一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line"><span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">history.listen(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以到这里，我们通过 <code>this.$route</code> 拿到的路由就已经变成跳转的路由了。<br>​</p><h5 id="8-更新-URL"><a href="#8-更新-URL" class="headerlink" title="8. 更新 URL"></a>8. 更新 URL</h5><p>接着就是更新 <code>URL</code> 了，在 <code>transitionTo</code> 这里它是先调用了 <code>onComplete</code> 方法，然后再调用 <code>ensureURL</code> 方法来更新浏览器上的 <code>URL</code> ，对应源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; onComplete(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="built_in">this</span>.ensureURL()</span><br></pre></td></tr></table></figure><p>由于我们这里是以 <code>hash</code> 模式来展开的，所以我们看看它的 <code>push</code> 方法里传入的 <code>onComplete</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>pushHash</code> 这里实际到后面已经可以更新 <code>URL</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于：src/util/push-state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">  saveScrollPosition()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = extend(&#123;&#125;, history.state)</span><br><span class="line">      stateCopy.key = getStateKey()</span><br><span class="line">      history.replaceState(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: setStateKey(genStateKey())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    pushState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以后面再执行 <code>ensureURL</code> 时就不需要再更新一遍了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ensureURL</span>(<span class="params">push ? : boolean</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.current.fullPath</span><br><span class="line">    <span class="keyword">if</span> (getHash() !== current) &#123;</span><br><span class="line">        push ? pushHash(current) : replaceHash(current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难道这个 <code>ensureURL</code> 就是多此一举吗？也不是，在其他地方调用就会更新 <code>URL</code> 的，比如 <code>transitionTo</code> 检查是否跳转至相同路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  isSameRoute(route, current) &amp;&amp;</span><br><span class="line">  <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">  lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">  route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">this</span>.ensureURL()</span><br><span class="line">  <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新了 <code>URL</code> 以后，还会调用 <code>handleScroll</code> 来滚动相关的操作，如：保存当前滚动位置、根据传入的 <code>scrollBehavior</code> 设置当前滚动位置，不过这里就不展开讲了。</p><p>另外，更新 <code>URL</code> 这部分行为也是根据不同的路由模式有所区别，后面的章节会详情讲解。</p><h5 id="9-渲染对应的路由视图"><a href="#9-渲染对应的路由视图" class="headerlink" title="9. 渲染对应的路由视图"></a>9. 渲染对应的路由视图</h5><p>除了更新 <code>URL</code> 以外，我们还要渲染当前路由对应的视图，那这又是如何做到的呢？我们知道 vue-router 是通过一个叫 <code>router-view</code> 的组件来渲染，下面看看它的实现，它的源码在：<a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/view.js">src/components/view.js</a>，我们先粗略看一下它的 <code>render</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params">_, &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    props,</span></span></span><br><span class="line"><span class="params"><span class="function">    children,</span></span></span><br><span class="line"><span class="params"><span class="function">    parent,</span></span></span><br><span class="line"><span class="params"><span class="function">    data</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// used by devtools to display a router-view badge</span></span><br><span class="line">    data.routerView = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// directly use parent context&#x27;s createElement() function</span></span><br><span class="line">    <span class="comment">// so that components rendered by router-view can resolve named slots</span></span><br><span class="line">    <span class="keyword">const</span> h = parent.$createElement</span><br><span class="line">    <span class="keyword">const</span> name = props.name</span><br><span class="line">    <span class="comment">// 拿到当前路由</span></span><br><span class="line">    <span class="keyword">const</span> route = parent.$route</span><br><span class="line">    <span class="comment">// 缓存路由视图，keepAlive 时会用到</span></span><br><span class="line">    <span class="keyword">const</span> cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determine current view depth, also check to see if the tree</span></span><br><span class="line">    <span class="comment">// has been toggled inactive but kept-alive.</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">        <span class="keyword">const</span> vnodeData = parent.$vnode ? parent.$vnode.data : &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.routerView) &#123;</span><br><span class="line">            depth++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) &#123;</span><br><span class="line">            inactive = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    data.routerViewDepth = depth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是渲染已经缓存的视图</span></span><br><span class="line">    <span class="keyword">if</span> (inactive) &#123;</span><br><span class="line">        <span class="keyword">const</span> cachedData = cache[name]</span><br><span class="line">        <span class="keyword">const</span> cachedComponent = cachedData &amp;&amp; cachedData.component</span><br><span class="line">        <span class="keyword">if</span> (cachedComponent) &#123;</span><br><span class="line">            <span class="comment">// #2301</span></span><br><span class="line">            <span class="comment">// pass props</span></span><br><span class="line">            <span class="keyword">if</span> (cachedData.configProps) &#123;</span><br><span class="line">                fillPropsinData(</span><br><span class="line">                    cachedComponent,</span><br><span class="line">                    data,</span><br><span class="line">                    cachedData.route,</span><br><span class="line">                    cachedData.configProps</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> h(cachedComponent, data, children)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// render previous empty view</span></span><br><span class="line">            <span class="keyword">return</span> h()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到对应的视图组件</span></span><br><span class="line">    <span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line">    <span class="keyword">const</span> component = matched &amp;&amp; matched.components[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render empty node if no matched route or no config component</span></span><br><span class="line">    <span class="keyword">if</span> (!matched || !component) &#123;</span><br><span class="line">        cache[name] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache component</span></span><br><span class="line">    cache[name] = &#123;</span><br><span class="line">        component</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach instance registration hook</span></span><br><span class="line">    <span class="comment">// this will be called in the instance&#x27;s injected lifecycle hooks</span></span><br><span class="line">    data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// val could be undefined for unregistration</span></span><br><span class="line">        <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">        <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">            matched.instances[name] = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also register instance in prepatch hook</span></span><br><span class="line">    <span class="comment">// in case the same component instance is reused across different routes</span></span><br><span class="line">    ;</span><br><span class="line">    (data.hook || (data.hook = &#123;&#125;)).prepatch = <span class="function">(<span class="params">_, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        matched.instances[name] = vnode.componentInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register instance in init hook</span></span><br><span class="line">    <span class="comment">// in case kept-alive component be actived when routes changed</span></span><br><span class="line">    data.hook.init = <span class="function">(<span class="params">vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            vnode.data.keepAlive &amp;&amp;</span><br><span class="line">            vnode.componentInstance &amp;&amp;</span><br><span class="line">            vnode.componentInstance !== matched.instances[name]</span><br><span class="line">        ) &#123;</span><br><span class="line">            matched.instances[name] = vnode.componentInstance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the route transition has already been confirmed then we weren&#x27;t</span></span><br><span class="line">        <span class="comment">// able to call the cbs during confirmation as the component was not</span></span><br><span class="line">        <span class="comment">// registered yet, so we call it here.</span></span><br><span class="line">        handleRouteEntered(route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> configProps = matched.props &amp;&amp; matched.props[name]</span><br><span class="line">    <span class="comment">// save route and configProps in cache</span></span><br><span class="line">    <span class="keyword">if</span> (configProps) &#123;</span><br><span class="line">        extend(cache[name], &#123;</span><br><span class="line">            route,</span><br><span class="line">            configProps</span><br><span class="line">        &#125;)</span><br><span class="line">        fillPropsinData(component, data, route, configProps)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染组件</span></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>router-view</code> 是通过 <code>$route</code> 变量来获取当前组件的，而在前面 <a href="#_7-%E6%9B%B4%E6%96%B0%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF">7. 更新路由信息</a> 时有提到会更新 <code>_route</code> 变量，而它在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时就已经用 <code>$route</code> 包装成响应式了，这里自然也就可以渲染对应的组件了。</p><h2 id="四、-动态添加路由实现"><a href="#四、-动态添加路由实现" class="headerlink" title="四、 动态添加路由实现"></a>四、 动态添加路由实现</h2><p>我们在开发时可能会遇到一些比较复杂的场景，需要动态添加路由，最常见的例子就是根据后端返回的不同用户角色去配置不同的前端路由，那下面就讲讲它在 vue-router 内部是如何实现的。<br>​</p><p>我们只需要使用 <code>router.addRoute</code> 方法就能新增一条路由记录，之前我们在讲 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">2. 创建 matcher</a> 有看到这个方法的定义，下面是它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRoute</span>(<span class="params">parentOrRoute, route</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否有传入父路由，有则取，无则 undefined</span></span><br><span class="line">  <span class="keyword">const</span> parent =</span><br><span class="line">    <span class="keyword">typeof</span> parentOrRoute !== <span class="string">&#x27;object&#x27;</span> ? nameMap[parentOrRoute] : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 插入一条路由，由于这里可能只会传入一个参数，所以需要判断一下</span></span><br><span class="line">  createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有父路由并且父路由存在别名的情况下，需要给这个别名路由也新增一条子路由</span></span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    createRouteMap(</span><br><span class="line">      <span class="comment">// $flow-disable-line route is defined if parent is</span></span><br><span class="line">      parent.alias.map(<span class="function">(<span class="params">alias</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">path</span>: alias,</span><br><span class="line">        <span class="attr">children</span>: [route]</span><br><span class="line">      &#125;)),</span><br><span class="line">      pathList,</span><br><span class="line">      pathMap,</span><br><span class="line">      nameMap,</span><br><span class="line">      parent</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较重要的是调用 <code>createRouteMap</code> 来创建路由，它的实现之前在 <a href="#_3-%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%B8%89%E5%BC%A0%E8%A1%A8">3. 根据路由配置生成三张表</a> 有提到，不过当时只关注它如何生成三张表，在现在这种情况下调用它的区别在于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三张表都无需新增，直接拿之前的</span></span><br><span class="line"><span class="keyword">const</span> pathList: <span class="built_in">Array</span>&lt;string&gt; = oldPathList || []</span><br><span class="line"><span class="keyword">const</span> pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>好了，可以看到新增一条路由规则十分简单，只需要对 <code>pathList</code> 、 <code>pathMap</code> 、 <code>nameMap</code> 进行改动就好了。</p><h2 id="五、-三种路由模式的实现"><a href="#五、-三种路由模式的实现" class="headerlink" title="五、 三种路由模式的实现"></a>五、 三种路由模式的实现</h2><p>vue-router 的核心逻辑已经讲得差不多了，就剩下三种路由模式之间的差异，这一小节就来仔细讲讲它们各自的内部实现。<br>​</p><h4 id="相同的部分"><a href="#相同的部分" class="headerlink" title="相同的部分"></a>相同的部分</h4><p>我们知道三种路由模式都是 <code>History</code> 的派生类，源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/history/base.js">src/history/base.js</a>，我们先来看看它们一些比较重要的公用方法：</p><ul><li>onReady</li><li>onError</li><li>transitionTo</li><li>confirmTransition</li><li>updateRoute</li></ul><p>其实这些方法在前文中已经或多或少有提到了，其余的那些也只是做一些更新变量的操作，这里也不谈了。</p><p>其实还有一个非常重要的就是构造函数，它主要是做一些实例变量的初始化，这里混个眼熟就好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.router = router</span><br><span class="line">    <span class="built_in">this</span>.base = normalizeBase(base)</span><br><span class="line">    <span class="comment">// start with a route object that stands for &quot;nowhere&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.current = START</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.ready = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.readyCbs = []</span><br><span class="line">    <span class="built_in">this</span>.readyErrorCbs = []</span><br><span class="line">    <span class="built_in">this</span>.errorCbs = []</span><br><span class="line">    <span class="built_in">this</span>.listeners = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就讲讲它们不同的地方。</p><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>hash 应该是最常用的一种模式了，它也是浏览器环境下的默认模式，至于它的特点相信大家也很熟悉了，就是利用 <code>URL</code> 中的 <code>hash</code> 值来做路由，这种模式兼容性是最好的。<br>​</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>我们先来看看它在初始化时会做哪些操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string, fallback : boolean</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// check history fallback deeplinking</span></span><br><span class="line">    <span class="keyword">if</span> (fallback &amp;&amp; checkFallback(<span class="built_in">this</span>.base)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureSlash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不多，首先是检查是否因为回退而使用 hash 模式，如果是的话则调用 <code>checkFallback</code> 检查它的返回值，如果为 <code>true</code> 则不调用 <code>ensureSlash</code> 。<br>​</p><p>下面是 <code>checkFallback</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFallback</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个方法位于 src/history/html5.js，用于获取 URL 中的路径部分</span></span><br><span class="line">  <span class="comment">// http://a.com/user/routes =&gt; /user/routes</span></span><br><span class="line">  <span class="comment">// http://a.com/#/user/routes =&gt; /#/user/routes</span></span><br><span class="line">  <span class="keyword">const</span> location = getLocation(base)</span><br><span class="line">  <span class="comment">// 检查是否以 /## 开头，如果不是，则重定向至以 /## 开头</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\/#/</span>.test(location)) &#123;</span><br><span class="line">    <span class="comment">// http://a.com/user/routes =&gt; http://a.com/#/user/routes</span></span><br><span class="line">    <span class="built_in">window</span>.location.replace(cleanPath(base + <span class="string">&#x27;/#&#x27;</span> + location))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说当我们使用了 <code>history</code> 模式但由于不支持需要回退到 <code>hash</code> 模式时，它会自动重定向到符合 <code>hash</code> 模式下的 <code>url</code> ，接着再执行 <code>ensureSlash</code> 方法。</p><p>下面是 <code>ensureSlash</code> 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://a.com/#/user/routes =&gt; /user/routes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHash</span>(<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We can&#x27;t use window.location.hash here because it&#x27;s not</span></span><br><span class="line">  <span class="comment">// consistent across browsers - Firefox will pre-decode it!</span></span><br><span class="line">  <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> index = href.indexOf(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">  <span class="comment">// empty path</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  href = href.slice(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> href</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureSlash</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = getHash()</span><br><span class="line">  <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  replaceHash(<span class="string">&#x27;/&#x27;</span> + path)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是判断一下 <code>hash</code> 部分是否以 <code>/</code> 开头，如果不是则要重定向到以 <code>/</code> 开头的 <code>URL</code> 。<br>​</p><p>这样就能解释我们在使用 vue-router 开发项目时，为什么打开调试页面 <a href="http://localhost:8080/">http://localhost:8080</a> 后会自动把 url 修改为 <a href="http://localhost:8080/#/">http://localhost:8080/#/</a> 了。</p><h5 id="push-和-replace"><a href="#push-和-replace" class="headerlink" title="push 和 replace"></a>push 和 replace</h5><p><code>hash</code> 模式的 <code>push</code> 方法我们在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节已经提到过了，其实 <code>replace</code> 也是大同小异，下面是这两个方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            replaceHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>replace</code> 方法跟 <code>push</code> 方法不同的地方是它调用的是 <code>replaceHash</code> 而不是 <code>pushHash</code> ，下面是 <code>replaceHash</code> 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法在 src/util/push-state.js 中</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">  saveScrollPosition()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = extend(&#123;&#125;, history.state)</span><br><span class="line">      stateCopy.key = getStateKey()</span><br><span class="line">      history.replaceState(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: setStateKey(genStateKey())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">replaceState</span>(<span class="params">url?: string</span>) </span>&#123;</span><br><span class="line">  pushState(url, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以它们在更新 <code>URL</code> 时的区别在于调用的是 <code>push</code> 还是 <code>replace</code> 方法。<br>​</p><h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>而 <code>go</code> 方法就更直接了，实际上就是调用 <code>history.go</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家会不会疑惑，这里没有调用 <code>transitionTo</code> 方法， <code>vue-router</code> 是如何知道需要更新路由的呢？<br>​</p><p>这就是就得不得说一下 <code>setupListeners</code> 这个方法了。</p><h5 id="setupListeners"><a href="#setupListeners" class="headerlink" title="setupListeners"></a>setupListeners</h5><p>还记得在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节的 <code>init</code> 方法里有这么一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line"><span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History || history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">  <span class="keyword">const</span> handleInitialScroll = <span class="function">(<span class="params">routeOrError</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = history.current</span><br><span class="line">    <span class="keyword">const</span> expectScroll = <span class="built_in">this</span>.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">      handleScroll(<span class="built_in">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> setupListeners = <span class="function">(<span class="params">routeOrError</span>) =&gt;</span> &#123;</span><br><span class="line">    history.setupListeners()</span><br><span class="line">    handleInitialScroll(routeOrError)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">  history.transitionTo(</span><br><span class="line">    history.getCurrentLocation(),</span><br><span class="line">    setupListeners,</span><br><span class="line">    setupListeners</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>history</code> 或者 <code>hash</code> 模式下初始化时也会调用一下 <code>transitionTo</code> ，而这里传入的 <code>onComplete</code> 回调就会调用 <code>setupListeners</code> 方法，为什么要这么做呢？我们直接看 <code>setupListeners</code> 里面是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setupListeners</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">        <span class="built_in">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">        <span class="comment">// 检查当前 URL 是否符合 hash 模式的规则，如果符合会直接重定向一下</span></span><br><span class="line">        <span class="comment">// 由于重定向后还是会再触发一下当前方法，这次就没必要执行了</span></span><br><span class="line">        <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.transitionTo(getHash(), <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">                handleScroll(<span class="built_in">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">                replaceHash(route.fullPath)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventType = supportsPushState ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    <span class="built_in">this</span>.listeners.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是做了两件事情：</p><ol><li>监听 <code>popstate</code> 或者 <code>hashchange</code> 事件，触发时会执行一下 <code>transitionTo</code>​</li><li>在 <code>listeners</code> 中存入两个回调：处理滚动相关、取消监听第 1 点中的事件</li></ol><p>也就是说 vue-router 除了调用 <code>push</code> 或者 <code>replece</code> 这些方法以外，它也支持通过其它方式来切换路由，只要这个操作会触发 <code>popstate</code> 或者 <code>hashchange</code> 事件，比如下面这些方式：</p><ul><li>如支持 <code>history</code> api<ul><li>history.pushState</li><li>history.replaceState</li><li>history.back</li><li>history.go</li></ul></li><li><code>location.hash = &#39;#/a&#39;</code></li></ul><p>当然这个事件监听器会在应用实例销毁时取消监听，避免产生副作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// clean up event listeners</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/2341</span></span><br><span class="line">    <span class="built_in">this</span>.listeners.forEach(<span class="function"><span class="params">cleanupListener</span> =&gt;</span> &#123;</span><br><span class="line">        cleanupListener()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.listeners = []</span><br><span class="line">    <span class="comment">// reset current history route</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/3294</span></span><br><span class="line">    <span class="built_in">this</span>.current = START</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><p><code>history</code> 模式是基于 HTML5 History API 实现的，不过在生产环境上使用它还需要在服务器上配置路由转发才行，不过这仍是大部分项目的选择，毕竟这样比较好看，不像 hash 模式这么奇葩。</p><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>我们看看 <code>history</code> 模式在初始化时会做哪些操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// getLocation 方法在前面已经讲过，主要用于获取 URL 中的路径部分</span></span><br><span class="line">    <span class="built_in">this</span>._startLocation = getLocation(<span class="built_in">this</span>.base)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是初始化了一个 <code>_startLocation</code> 变量，这个变量的作用后面会讲到。<br>​</p><h5 id="push-和-replace、go"><a href="#push-和-replace、go" class="headerlink" title="push 和 replace、go"></a>push 和 replace、go</h5><p>其实 <code>history</code> 模式的这几个方法与 <code>hash</code> 模式是一模一样的，区别是它们在调用 <code>pushState</code> 时传入的 <code>URL</code> 不一样而已，关于 <code>pushState</code> 方法的定义前面已经讲过了。</p><h5 id="setupListeners-1"><a href="#setupListeners-1" class="headerlink" title="setupListeners"></a>setupListeners</h5><p><code>setupListeners</code> 与 <code>hash</code> 模式也是大同小异，区别在于它在判断 <code>URL</code> 与当前路由是否一致时有点不同：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handleRoutingEvent = () =&gt; &#123;</span><br><span class="line">  const current = this.current</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  if (!ensureSlash()) &#123;</span></span><br><span class="line"><span class="deletion">-    return</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="addition">+  const location = getLocation(this.base)</span></span><br><span class="line"><span class="addition">+  if (this.current === START &amp;&amp; location === this._startLocation) &#123;</span></span><br><span class="line"><span class="addition">+    return</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">  this.transitionTo(location, (route) =&gt; &#123;</span><br><span class="line">    if (supportsScroll) &#123;</span><br><span class="line">      handleScroll(router, route, current, true)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a>abstract 模式</h4><p><code>abstract</code> 我们可能用得比较少，它主要是用在 <code>node</code> 环境下，也就是说在该模式下不会调用一切与浏览器相关的 <code>api</code> ，那它就只能用别的地方去维护当前 <code>URL</code> 与路由历史，由于不是很长，我直接放在一起讲了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHistory</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="attr">index</span>: number</span><br><span class="line">  <span class="attr">stack</span>: <span class="built_in">Array</span>&lt;Route&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ?string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// 堆栈，用于维护路由历史</span></span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">    <span class="comment">// 当前所在路由在 stack 中的索引</span></span><br><span class="line">    <span class="built_in">this</span>.index = -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由存入栈中，index + 1</span></span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index + <span class="number">1</span>).concat(route)</span><br><span class="line">        <span class="built_in">this</span>.index++</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由替换之前路由所在的位置，index 不变</span></span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index).concat(route)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = <span class="built_in">this</span>.index + n</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span> || targetIndex &gt;= <span class="built_in">this</span>.stack.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.stack[targetIndex]</span><br><span class="line">    <span class="built_in">this</span>.confirmTransition(</span><br><span class="line">      route,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = <span class="built_in">this</span>.current</span><br><span class="line">        <span class="comment">// 将跳转至的路由索引指向 index</span></span><br><span class="line">        <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">        <span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">          hook &amp;&amp; hook(route, prev)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNavigationFailure(err, NavigationFailureType.duplicated)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getCurrentLocation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> current ? current.fullPath : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">ensureURL</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// noop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文完，感谢阅读。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composition-api 源码解析</title>
      <link href="//post/composition-api-score-code.html"/>
      <url>//post/composition-api-score-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>本文是针对 composition-api <a href="https://github.com/vuejs/composition-api/releases/tag/v1.0.0-rc.6">v1.0.0-rc.6</a> 版本的一次源码解析，主要是想探析以下两点：</p><ol><li>Vue 在安装 composition-api 时做了些什么？</li><li>Vue 在执行每个组件的 <code>setup</code> 方法时做了什么？</li></ol><p>好了，废话不多说，我们直接开始。</p><h2 id="一、安装过程"><a href="#一、安装过程" class="headerlink" title="一、安装过程"></a>一、安装过程</h2><h3 id="1-检测是否已安装"><a href="#1-检测是否已安装" class="headerlink" title="1. 检测是否已安装"></a>1. 检测是否已安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/install.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isVueRegistered(Vue)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是检查是否重复安装，如果是则在开发环境中发出警告，主要是调用了 <code>isVueRegistered</code> 方法来进行检测，下面是它的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtimeContext.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PluginInstalledFlag = <span class="string">&#x27;__composition_api_installed__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isVueRegistered</span>(<span class="params">Vue: VueConstructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasOwn(Vue, PluginInstalledFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检测 Vue 的 <code>__composition_api_installed__</code>   这个属性来 <code>composition-api</code> 是否已经安装。</p><p>那很明显后来真正安装 composition-api 时会设置这个属性。</p><h3 id="2-检测-Vue-版本"><a href="#2-检测-Vue-版本" class="headerlink" title="2. 检测 Vue 版本"></a>2. 检测 Vue 版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue.version) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Vue.version[<span class="number">0</span>] !== <span class="string">&#x27;2&#x27;</span> || Vue.version[<span class="number">1</span>] !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`[vue-composition-api] only works with Vue 2, v<span class="subst">$&#123;Vue.version&#125;</span> found.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    warn(<span class="string">&#x27;[vue-composition-api] no Vue version found&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在开发环境中判断 Vue 的版本，必须是 2.x 的版本才能使用 composition-api。</p><h3 id="3-添加-setup-这个-option-api"><a href="#3-添加-setup-这个-option-api" class="headerlink" title="3. 添加 setup 这个 option api"></a>3. 添加 setup 这个 option api</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies.setup = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  child: <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedSetupFn</span>(<span class="params">props: any, context: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mergeData(</span><br><span class="line">      <span class="keyword">typeof</span> parent === <span class="string">&#x27;function&#x27;</span> ? parent(props, context) || &#123;&#125; : <span class="literal">undefined</span>,</span><br><span class="line">      <span class="keyword">typeof</span> child === <span class="string">&#x27;function&#x27;</span> ? child(props, context) || &#123;&#125; : <span class="literal">undefined</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过 Vue 的 <a href="https://cn.vuejs.org/v2/guide/mixins.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5">自定义选项合并策略</a> 来添加 <code>setup</code> 这个 api。</p><p>ps：是否还有同学不知道我们可以自定义 Vue 的 options 呢？可以尝试利用这个 api 来实现一个 <code>asyncComputed</code> 和 <code>multiWatch</code> 来玩玩哦！</p><h3 id="4-设置已安装标记"><a href="#4-设置已安装标记" class="headerlink" title="4. 设置已安装标记"></a>4. 设置已安装标记</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtimeContext.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PluginInstalledFlag = <span class="string">&#x27;__composition_api_installed__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setVueConstructor</span>(<span class="params">Vue: VueConstructor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; vueConstructor &amp;&amp; Vue.__proto__ !== vueConstructor.__proto__) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;[vue-composition-api] another instance of Vue installed&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  vueConstructor = Vue</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue, PluginInstalledFlag, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到过，就是在这里设置一个表示已经安装的标记。</p><h3 id="5-设置全局混合"><a href="#5-设置全局混合" class="headerlink" title="5. 设置全局混合"></a>5. 设置全局混合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  <span class="attr">beforeCreate</span>: functionApiInit</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后添加一个全局的 <code>mixin</code> ，在每个组件的 <code>beforeCreate</code> 生命周期执行一下 <code>functionApiInit</code> 方法。</p><p>以上就是安装 composition-api 做的事，关于 <code>functionApiInit</code> 的内容我们在下一小节中详细讲解 。</p><h2 id="二、执行-setup"><a href="#二、执行-setup" class="headerlink" title="二、执行 setup"></a>二、执行 setup</h2><p>我们知道  composition-api 主要是新增了一个 <code>setup</code> 选项，以及一系列 hooks，而 <code>steup</code> 也不是简单调用一下就完事，在这之前需要做一些事，比如传入的两个参数： <code>props</code> 、 <code>ctx</code> 是怎么来的，以及 <code>setup</code> 的返回值为何可以在 <code>template</code> 中使用等等。</p><p>前面讲了 compsition-api 会在每个组件的 <code>beforeCreate</code> 时执行一下 <code>functionApiInit</code> 方法 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  <span class="attr">beforeCreate</span>: functionApiInit</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面是这个方法主要做的事。</p><h3 id="1-检测是否有-render"><a href="#1-检测是否有-render" class="headerlink" title="1. 检测是否有 render"></a>1. 检测是否有 render</h3><p>第一步是检测是否定义 <code>render</code> 方法，如果有 <code>render</code> 方法，则修改它内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">const</span> $options = vm.$options</span><br><span class="line"><span class="keyword">const</span> &#123; setup, render &#125; = $options</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (render) &#123;</span><br><span class="line">  <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">  $options.render = <span class="function"><span class="keyword">function</span> (<span class="params">...args: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> activateCurrentInstance(vm, <span class="function">() =&gt;</span> render.apply(<span class="built_in">this</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>activateCurrentInstance</code> 的作用就是设置当前实例，所以我们可以在 <code>render</code> 中通过 <code>getCurrentInstance</code> 访问到当前实例。</p><p>ps：值得说明的是即便我们写的是 <code>template</code> ，但到了目前这个阶段这里它已经被转换成 <code>render</code> 函数了。</p><h3 id="2-检测是否有-setup"><a href="#2-检测是否有-setup" class="headerlink" title="2. 检测是否有 setup"></a>2. 检测是否有 setup</h3><p>如果没有定义 <code>setup</code> ，说明这个组件没有使用 <code>composition-api</code> ，这时候则直接跳过该组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!setup) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setup !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;The &quot;setup&quot; option should be a function that returns a object in component definitions.&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在-data-方法初始化-setup"><a href="#3-在-data-方法初始化-setup" class="headerlink" title="3. 在 data 方法初始化 setup"></a>3. 在 data 方法初始化 setup</h3><p>如果存在 <code>setup</code> ，就会修改这个组件的 <code>data</code> 方法，在初始化真正的 <code>data</code> 方法之前先初始化一下 <code>setup</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    data</span><br><span class="line">&#125; = $options</span><br><span class="line"><span class="comment">// wrapper the data option, so we can invoke setup before data get resolved</span></span><br><span class="line">$options.data = <span class="function"><span class="keyword">function</span> <span class="title">wrappedData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    initSetup(vm, vm.$props)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">        (data <span class="keyword">as</span>(<span class="built_in">this</span>: ComponentInstance, <span class="attr">x</span>: ComponentInstance) =&gt; object).call(</span><br><span class="line">            vm,</span><br><span class="line">            vm</span><br><span class="line">        ) :</span><br><span class="line">        data || &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得 Vue 初始化 <code>data</code> 的时机是什么时候吗？答案是在 <code>beforeCreate</code> 和 <code>created</code> 之间，所以 <code>setup</code> 也是一样。</p><h3 id="4-初始化-setup"><a href="#4-初始化-setup" class="headerlink" title="4. 初始化 setup"></a>4. 初始化 setup</h3><p><code>initSetup</code> 方法内部还做了挺多事的，下面是这个方法的全貌，先简单瞄一眼，我们后面会一步步拆解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initSetup</span>(<span class="params">vm: ComponentInstance, props: Record &lt; any, any &gt; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> setup = vm.$options.setup!</span><br><span class="line">        <span class="keyword">const</span> ctx = createSetupContext(vm)</span><br><span class="line">    <span class="comment">// fake reactive for `toRefs(props)`</span></span><br><span class="line">    def(props, <span class="string">&#x27;__ob__&#x27;</span>, createObserver())</span><br><span class="line">    <span class="comment">// resolve scopedSlots and slots to functions</span></span><br><span class="line">    <span class="comment">// @ts-expect-error</span></span><br><span class="line">    resolveScopedSlots(vm, ctx.slots)</span><br><span class="line">    <span class="keyword">let</span> binding: ReturnType &lt; SetupFunction &lt; Data, Data &gt;&gt; | <span class="literal">undefined</span> | <span class="literal">null</span></span><br><span class="line">    activateCurrentInstance(vm, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// make props to be fake reactive, this is for `toRefs(props)`</span></span><br><span class="line">        binding = setup(props, ctx)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!binding) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (isFunction(binding)) &#123;</span><br><span class="line">        <span class="comment">// keep typescript happy with the binding type.</span></span><br><span class="line">        <span class="keyword">const</span> bindingFunc = binding</span><br><span class="line">        <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">        vm.$options.render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// @ts-expect-error</span></span><br><span class="line">            resolveScopedSlots(vm, ctx.slots)</span><br><span class="line">            <span class="keyword">return</span> activateCurrentInstance(vm, <span class="function">() =&gt;</span> bindingFunc())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(binding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReactive(binding)) &#123;</span><br><span class="line">            binding = toRefs(binding) <span class="keyword">as</span> Data</span><br><span class="line">        &#125;</span><br><span class="line">        vmStateManager.set(vm, <span class="string">&#x27;rawBindings&#x27;</span>, binding)</span><br><span class="line">        <span class="keyword">const</span> bindingObj = binding</span><br><span class="line">        <span class="built_in">Object</span>.keys(bindingObj).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> bindingValue: any = bindingObj[name]</span><br><span class="line">            <span class="keyword">if</span> (!isRef(bindingValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isReactive(bindingValue)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isFunction(bindingValue)) &#123;</span><br><span class="line">                        bindingValue = bindingValue.bind(vm)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObject(bindingValue)) &#123;</span><br><span class="line">                        bindingValue = ref(bindingValue)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasReactiveArrayChild(bindingValue)) &#123;</span><br><span class="line">                        <span class="comment">// creates a custom reactive properties without make the object explicitly reactive</span></span><br><span class="line">                        <span class="comment">// NOTE we should try to avoid this, better implementation needed</span></span><br><span class="line">                        customReactive(bindingValue)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = ref(bindingValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            asVmProperty(vm, name, bindingValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        assert(</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="string">`&quot;setup&quot; must return a &quot;Object&quot; or a &quot;Function&quot;, got &quot;<span class="subst">$&#123;<span class="built_in">Object</span>.prototype.toString</span></span></span><br><span class="line"><span class="subst"><span class="string">        .call(binding)</span></span></span><br><span class="line"><span class="subst"><span class="string">        .slice(<span class="number">8</span>, -<span class="number">1</span>)&#125;</span>&quot;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-初始化-context"><a href="#4-1-初始化-context" class="headerlink" title="4.1. 初始化 context"></a>4.1. 初始化 context</h4><p>这个 <code>ctx</code> 是 <code>setup</code> 中接受的第二个参数，这个对象里面的内容是怎么生成的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = createSetupContext(vm)</span><br></pre></td></tr></table></figure><p>下面是 <code>createSetupContext</code> 所做的事，首先是定义 <code>ctx</code> 对象中所有的 <code>key</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    <span class="attr">slots</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">as</span> SetupContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propsPlain = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;refs&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;listeners&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;isServer&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ssrContext&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> propsReactiveProxy = [<span class="string">&#x27;attrs&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> methodReturnVoid = [<span class="string">&#x27;emit&#x27;</span>]</span><br></pre></td></tr></table></figure><p>接下来就是给这些属性利用 <code>Object.defineProperty</code> 做一层代理，当然它们都是只读的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">propsPlain.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> srcKey = <span class="string">`$<span class="subst">$&#123;key&#125;</span>`</span></span><br><span class="line">  proxy(ctx, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> vm[srcKey],</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      warn(<span class="string">`Cannot assign to &#x27;<span class="subst">$&#123;key&#125;</span>&#x27; because it is a read-only property`</span>, vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外两个 <code>propsReactiveProxy</code> 和 <code>methodReturnVoid</code> 也差不多，这里就略过了。</p><h4 id="4-2-响应式-props"><a href="#4-2-响应式-props" class="headerlink" title="4.2. 响应式 props"></a>4.2. 响应式 props</h4><p>接着就是将 <code>props</code> 对象进行一遍 Observer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def(props, <span class="string">&#x27;__ob__&#x27;</span>, createObserver())</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createObserver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> observe &lt; any &gt; &#123;&#125;.__ob__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>createObserver</code> 拿到一个把空对象经过 Vue. Observer 后的 <code>__ob__</code> 属性，也就是当前 <code>Observer</code> 实例对象，如果同学们对于 Vue Observer 的原理还不太熟悉，可以看这里 <a href="http://caibaojian.com/vue-design/art/7vue-reactive.html#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E7%9A%84-ob-%E5%B1%9E%E6%80%A7">数据对象的 </a>，本文就不赘述了。</p><p>然后给 <code>props</code> 新增一个 <code>__ob_</code> 属性，指向前面拿到的这个 <code>__ob__</code> 。</p><h4 id="4-3-解析-slots"><a href="#4-3-解析-slots" class="headerlink" title="4.3. 解析 slots"></a>4.3. 解析 slots</h4><p>接着就是把当前实例的 <code>slots</code> 给代理到前面定义的 <code>ctx.slots</code> 中，这时候它只是一个空对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolveScopedSlots(vm, ctx.slots)</span><br></pre></td></tr></table></figure><p>下面是 <code>resolveScopedSlots</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveScopedSlots</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vm: ComponentInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    slotsProxy: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        [x: string]: <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parentVNode = (vm.$options <span class="keyword">as</span> any)._parentVnode</span><br><span class="line">    <span class="keyword">if</span> (!parentVNode) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prevSlots = vmStateManager.get(vm, <span class="string">&#x27;slots&#x27;</span>) || []</span><br><span class="line">    <span class="keyword">const</span> curSlots = resolveSlots(parentVNode.data.scopedSlots, vm.$slots)</span><br><span class="line">    <span class="comment">// remove staled slots</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; prevSlots.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = prevSlots[index]</span><br><span class="line">        <span class="keyword">if</span> (!curSlots[key]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> slotsProxy[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy fresh slots</span></span><br><span class="line">    <span class="keyword">const</span> slotNames = <span class="built_in">Object</span>.keys(curSlots)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; slotNames.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = slotNames[index]</span><br><span class="line">        <span class="keyword">if</span> (!slotsProxy[key]) &#123;</span><br><span class="line">            slotsProxy[key] = createSlotProxy(vm, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vmStateManager.set(vm, <span class="string">&#x27;slots&#x27;</span>, slotNames)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是将父组件的 <code>slots</code> 数组（真正被使用的）代理到 <code>ctx.slots</code> 中，并且在这个 <code>slots</code> 数组有变化时 <code>ctx.slots</code> 也会相应地更新。</p><h4 id="4-4-执行-setup"><a href="#4-4-执行-setup" class="headerlink" title="4.4. 执行 setup"></a>4.4. 执行 setup</h4><p>终于到了最重要的关头，开始执行 <code>setup</code> 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activateCurrentInstance(vm, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// make props to be fake reactive, this is for `toRefs(props)`</span></span><br><span class="line">  binding = setup(props, ctx)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>activateCurrentInstance</code> 之前讲过了，就是使组件的 <code>setup</code> 内部可以通过 <code>getCurrentInstance</code> 访问当前实例，相信真正使用过 <code>composition-api</code> 的同学们都知道这个方法的便利性了，但不知道同学们是否遇到过 <code>getCurrentInstance</code> 方法返回 <code>null</code> 值的情况呢？如果想知道为什么，可以看这篇文章：<a href="https://4ark.me/post/87ba8d8b.html">《从 Composition API 源码分析 getCurrentInstance() 为何返回 null》</a>。</p><p>然后将前面得到的 <code>props</code> 和 <code>ctx</code> 传进去，最后将返回值赋值给 <code>binding</code> 。</p><h4 id="4-6-处理-setup-返回值"><a href="#4-6-处理-setup-返回值" class="headerlink" title="4.6. 处理 setup 返回值"></a>4.6. 处理 setup 返回值</h4><p>处理返回值前需要先对它进行类型判断，有三种条件分支：</p><ol><li>为空，直接返回</li><li>是一个函数，当成 <code>render</code> 方法处理</li><li>是一个普通对象，做一系列转换</li></ol><p>如果返回值是一个函数，则把它当成 <code>render</code> 方法处理，当然在这之前需要重新调用一下 <code>resolveScopedSlots</code> 检测 <code>slots</code> 的更新，并且调用 <code>activateCurrentInstance</code>  ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isFunction(binding)) &#123;</span><br><span class="line">  <span class="comment">// keep typescript happy with the binding type.</span></span><br><span class="line">  <span class="keyword">const</span> bindingFunc = binding</span><br><span class="line">  <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">  vm.$options.render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-expect-error</span></span><br><span class="line">    resolveScopedSlots(vm, ctx.slots)</span><br><span class="line">    <span class="keyword">return</span> activateCurrentInstance(vm, <span class="function">() =&gt;</span> bindingFunc())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：也可以直接在 <code>setup</code> 中返回 <code>JSX</code> 哦，因为 Babel 会把它变成一个函数。</p><p>但通常我们是在 <code>setup</code> 返回一个对象，然后可以直接在 <code>template</code> 中使用这个这些值，所以我们看看返回值是一个对象的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(binding)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isReactive(binding)) &#123;</span><br><span class="line">        binding = toRefs(binding) <span class="keyword">as</span> Data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmStateManager.set(vm, <span class="string">&#x27;rawBindings&#x27;</span>, binding)</span><br><span class="line">    <span class="keyword">const</span> bindingObj = binding</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(bindingObj).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bindingValue: any = bindingObj[name]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRef(bindingValue)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isReactive(bindingValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFunction(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = bindingValue.bind(vm)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObject(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = ref(bindingValue)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasReactiveArrayChild(bindingValue)) &#123;</span><br><span class="line">                    <span class="comment">// creates a custom reactive properties without make the object explicitly reactive</span></span><br><span class="line">                    <span class="comment">// NOTE we should try to avoid this, better implementation needed</span></span><br><span class="line">                    customReactive(bindingValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(bindingValue)) &#123;</span><br><span class="line">                bindingValue = ref(bindingValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        asVmProperty(vm, name, bindingValue)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先如果返回的对象是经过 <code>reactive</code> 的，则要调用 <code>toRefs</code> 将它的子属性变成 <code>ref</code> 包装过的，然后调用 <code>vmStateManager.set</code> 将这些属性存放起来，以供别的地方使用。</p><p>然后遍历这个对象，经过一系列类型判断和处理后，将它的子属性设置为当前实例的变量，这样我们就可以在 <code>templte</code> 或者通过 <code>this.xxx</code> 去访问这些变量。</p><p>这里的类型处理简单总结一下就是：</p><ol><li> 如果属性值是一个函数，则这个函数被调用时已经 <code>this</code> 就是当前实例</li><li> 如果属性值一个非对象非函数的值，则会自动经过 <code>ref</code> 包装</li><li> 如果属性值是一个普通对象且有子属性值为经过 <code>reactive</code> 后的数组，则要将这个普通对象也要转换为经过 <code>reactive</code> 包装才行，所以我们在开发时要避免如下情况：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">obj</span>: &#123;</span><br><span class="line">            <span class="attr">arr</span>: reactive([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在开发环境下判断返回值不是对象是抛出一个错误。到此 <code>setup</code> 函数的执行就完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 composition-api 的安装和执行过程就讲完了，下面我们来简单总结一下，composition-api 在安装时会做以下事情：</p><ol><li>通过检查 Vue 的 <code>__composition_api_installed__</code> 属性来判断是否重复安装</li><li>检查 Vue 版本是否 2.x</li><li>使用合并策略添加 <code>setup</code> api</li><li>标记安装</li><li>利用全局混入来对 <code>setup</code> 进行初始化</li></ol><p>而在执行 <code>setup</code> 时会做以下事情：</p><ol><li>检查当前组件是否使用 <code>render</code> 方法，如果有则在这之前标记当前实例，以便 <code>render</code> 方法内部可以通过 <code>getCurrentInstance</code> 方法访问到当前实例。</li><li>检查当前组件有 <code>setup</code> api，没有则直接返回，否则在初始化 <code>data</code> 时先初始化一下 <code>setup</code></li><li>而初始化 <code>setup</code> 做的事就是构造 <code>setup</code> 接受的两个参数：props、ctx</li><li>然后执行 <code>setup</code> ，根据它的返回值类型进行相应的处理</li></ol><p>当然，compsition-api 真正的魅力在于 hooks，下次我就来讲讲 composition-api 的一系列 hooks 是如何实现的，这也能帮助我们更好地利用这些 hooks 方法来编写更优雅、可复用的代码。</p><p>本文就到此，感谢你的阅读。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex 源码解析</title>
      <link href="//post/vuex-score-code.html"/>
      <url>//post/vuex-score-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>本文是针对 vuex <a href="https://github.com/vuejs/vuex/releases/tag/v3.6.2">v3.6.2</a> 版本的一次源码解析，主要是想研究以下几点：</p><ol><li>vuex 的初始化过程</li><li>vuex 的数据状态如何存放</li><li>调用一个 mutation 时做了什么</li><li>mapState、mapActions 这些绑定函数的实现</li></ol><h2 id="一、初始化过程"><a href="#一、初始化过程" class="headerlink" title="一、初始化过程"></a>一、初始化过程</h2><p>我们平时使用 vuex 的时候需要先通过 new 一个 <code>Vuex.Store</code> 来创建一个 store，下面我们就看看在构造一个 store 时需要经过哪些操作，我们先来看看它的构造函数，它的源码在 <a href="https://github1s.com/vuejs/vuex/blob/HEAD/src/store.js">src/store.js</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">    <span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">      install(<span class="built_in">window</span>.Vue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">      assert(</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">        <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">      )</span><br><span class="line">      assert(</span><br><span class="line">        <span class="built_in">this</span> <span class="keyword">instanceof</span> Store,</span><br><span class="line">        <span class="string">`store must be called with the new operator.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store internal state</span></span><br><span class="line">    <span class="built_in">this</span>._committing = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>._actionSubscribers = []</span><br><span class="line">    <span class="built_in">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">    <span class="built_in">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>._subscribers = []</span><br><span class="line">    <span class="built_in">this</span>._watcherVM = <span class="keyword">new</span> Vue()</span><br><span class="line">    <span class="built_in">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strict mode</span></span><br><span class="line">    <span class="built_in">this</span>.strict = strict</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init root module.</span></span><br><span class="line">    <span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line">    <span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">    installModule(<span class="built_in">this</span>, state, [], <span class="built_in">this</span>._modules.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line">    <span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">    resetStoreVM(<span class="built_in">this</span>, state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply plugins</span></span><br><span class="line">    plugins.forEach(<span class="function">(<span class="params">plugin</span>) =&gt;</span> plugin(<span class="built_in">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> useDevtools =</span><br><span class="line">      options.devtools !== <span class="literal">undefined</span> ? options.devtools : Vue.config.devtools</span><br><span class="line">    <span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">      devtoolPlugin(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不是很长，下面我们逐段分析一下这个构造函数中做了哪些操作。</p><h3 id="1-自动安装"><a href="#1-自动安装" class="headerlink" title="1. 自动安装"></a>1. 自动安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">    <span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">      install(<span class="built_in">window</span>.Vue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue</span><br><span class="line">  applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new Store</code> 的时候如果还未安装，并且已经有全局引入 Vue 的情况下，就会自动安装，但如果已经安装，则无需再次安装。</p><p>安装的时候会执行一下 <code>applyMixin</code> ，它的源码位在 <a href="https://github1s.com/vuejs/vuex/blob/HEAD/src/mixin.js">src/mixin.js</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      <span class="attr">beforeCreate</span>: vuexInit</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">    <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">    <span class="keyword">const</span> _init = Vue.prototype._init</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit</span><br><span class="line">      _init.call(<span class="built_in">this</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store =</span><br><span class="line">        <span class="keyword">typeof</span> options.store === <span class="string">&#x27;function&#x27;</span> ? options.store() : options.store</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是只做了一件事：将 store 挂载到 <code>$store</code> ，所以我们可以在 <code>vue</code> 组件中通过 <code>$store</code> 访问到 store。</p><h3 id="2-异常检测"><a href="#2-异常检测" class="headerlink" title="2. 异常检测"></a>2. 异常检测</h3><p>如果是在开发环境的话，就会做一些检查：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  assert(</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">    <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">  )</span><br><span class="line">  assert(<span class="built_in">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`store must be called with the new operator.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-初始化内部变量"><a href="#3-初始化内部变量" class="headerlink" title="3. 初始化内部变量"></a>3. 初始化内部变量</h3><p>然后定义了一系列内部变量，这些变量后面都会讲到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line"><span class="comment">// store internal state</span></span><br><span class="line"><span class="built_in">this</span>._committing = <span class="literal">false</span></span><br><span class="line"><span class="built_in">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>._actionSubscribers = []</span><br><span class="line"><span class="built_in">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line"><span class="built_in">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>._subscribers = []</span><br><span class="line"><span class="built_in">this</span>._watcherVM = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="built_in">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span></span><br><span class="line"><span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="built_in">this</span>.strict = strict</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state</span><br></pre></td></tr></table></figure><p>这里有几点比较值得关注的，下面来逐一讲讲。</p><h4 id="3-1-构造-modules"><a href="#3-1-构造-modules" class="headerlink" title="3.1. 构造 modules"></a>3.1. 构造 modules</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br></pre></td></tr></table></figure><p>它会通过 new 一个 ModuleCollection 并传入 options 得到 modules，ModuleCollection 内部会递归注册所有的子模块。</p><p>最终返回一个类似如下的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">_children</span>: &#123;</span><br><span class="line">        <span class="attr">subModule1</span>: Module &#123;</span><br><span class="line">            <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">_children</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">state</span>: &#123;</span><br><span class="line">                …&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">subModule2</span>: Module &#123;</span><br><span class="line">            <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">_children</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">state</span>: &#123;</span><br><span class="line">                …&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: &#123;</span><br><span class="line">            <span class="attr">subModule1</span>: &#123;</span><br><span class="line">                <span class="attr">state</span>: &#123;</span><br><span class="line">                    …&#125;,</span><br><span class="line">                <span class="attr">mutations</span>: &#123;</span><br><span class="line">                    …&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attr">subModule2</span>: &#123;</span><br><span class="line">                <span class="attr">state</span>: &#123;</span><br><span class="line">                    …&#125;,</span><br><span class="line">                <span class="attr">mutations</span>: &#123;</span><br><span class="line">                    …&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这里先不用太纠结，大概知道就好。</p><h4 id="3-2-包装-dispatch-和-commit"><a href="#3-2-包装-dispatch-和-commit" class="headerlink" title="3.2. 包装 dispatch 和 commit"></a>3.2. 包装 dispatch 和 commit</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span></span><br><span class="line"><span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之所以要把 <code>dispatch</code> 和 <code>commit</code> 方法包装一下，是为了确保无论如何调用这两个方法， <code>this</code> 始终指向 store 实例。</p><p>因为在 js 中，不管是有意或者无意，能够改变 <code>this</code> 指向的操作太多了，所以 <code>vuex</code> 考虑到了这一点。</p><h3 id="4-初始化-module"><a href="#4-初始化-module" class="headerlink" title="4. 初始化 module"></a>4. 初始化 module</h3><p>接着就会使用前面得到的 <code>_module</code>   来初始化 module，传入的是 <code>_module.root</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init root module.</span></span><br><span class="line"><span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line"><span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">installModule(<span class="built_in">this</span>, state, [], <span class="built_in">this</span>._modules.root)</span><br></pre></td></tr></table></figure><p>同样它只需要传入 root 模块，方法内会去检测如果存在子模块则会递归调用去初始化所有子模块。</p><p>下面是 <code>installModule</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store._modulesNamespaceMap[namespace] &amp;&amp; __DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;namespace&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="subst"><span class="string">          <span class="string">&#x27;/&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">        )&#125;</span>`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[vuex] state field &quot;<span class="subst">$&#123;moduleName&#125;</span>&quot; was overridden by a module with the same name at &quot;<span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="subst"><span class="string">              <span class="string">&#x27;.&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">            )&#125;</span>&quot;`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-初始化-root-模块"><a href="#4-1-初始化-root-模块" class="headerlink" title="4.1 初始化 root 模块"></a>4.1 初始化 root 模块</h4><p>由于这个方法是会递归调用的，我们先来看看它在初始化根模块时会执行的逻辑，首先它会调用 <code>makeLocalContext</code> 构造出属于当前模块的一个上下文，也就是我们平时在 <code>action</code> 中获取的那个 <code>ctx</code> 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br></pre></td></tr></table></figure><p>接着会处理当前模块的 <code>mutations</code> 、 <code>actions</code> 、 <code>getters</code> ，以及如果有子模块的话就递归调用 <code>installModule</code> 对子模块进行相同的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function"><span class="keyword">function</span> (<span class="params">mutation, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function"><span class="keyword">function</span> (<span class="params">action, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = action.root ? key : namespace + key</span><br><span class="line">  <span class="keyword">var</span> handler = action.handler || action</span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function"><span class="keyword">function</span> (<span class="params">getter, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> namespacedType = namespace + key</span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function"><span class="keyword">function</span> (<span class="params">child, key</span>) </span>&#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="4-2-初始化子模块"><a href="#4-2-初始化子模块" class="headerlink" title="4.2. 初始化子模块"></a>4.2. 初始化子模块</h4><p>而对于子模块，会额外执行一些其它逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set state</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">var</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">var</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">  store._withCommit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(</span><br><span class="line">          <span class="string">&#x27;[vuex] state field &quot;&#x27;</span> +</span><br><span class="line">            moduleName +</span><br><span class="line">            <span class="string">&#x27;&quot; was overridden by a module with the same name at &quot;&#x27;</span> +</span><br><span class="line">            path.join(<span class="string">&#x27;.&#x27;</span>) +</span><br><span class="line">            <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是将子模块的 <code>state</code> 设置到父模块的 <code>state</code> 中去，这也是为什么我们可以通过这种方式来获取子模块的 <code>state</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$store.state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">subModule1</span>: &#123;</span><br><span class="line">        <span class="attr">count1</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">subModule2</span>: &#123;</span><br><span class="line">        <span class="attr">count2</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-初始化命名空间模块"><a href="#4-3-初始化命名空间模块" class="headerlink" title="4.3. 初始化命名空间模块"></a>4.3. 初始化命名空间模块</h4><p>对于使用命名空间的情况，在这基础上还会执行额外的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace = store._modules.getNamespace(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register in namespace map</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store._modulesNamespaceMap[namespace] &amp;&amp; (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error((<span class="string">&quot;[vuex] duplicate namespace &quot;</span> + namespace + <span class="string">&quot; for the namespaced module &quot;</span> + (path.join(<span class="string">&#x27;/&#x27;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        store._modulesNamespaceMap[namespace] = <span class="built_in">module</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>getNamespace</code> 拿到命名空间的名称，其实就是在模块名后面加一个 <code>/</code> ，比如： <code>subModule/</code> ，当然如果没有开启 <code>namespaced</code> ，拿到的其实是空字符串。然后将它作为 <code>key</code> 存入 <code>_modulesNamespaceMap</code> 中，有什么作用后面会讲到。</p><h4 id="4-4-初始化-mutation、action、getter"><a href="#4-4-初始化-mutation、action、getter" class="headerlink" title="4.4. 初始化 mutation、action、getter"></a>4.4. 初始化 mutation、action、getter</h4><p>对于所有模块，初始化   <code>mutation</code> 、 <code>action</code> 、 <code>getter</code> 都是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先将每个 <code>mutation</code> 的 <code>key</code> 与当前模块的命名空间名称拼接在一起，然后调用 <code>registerMutation</code> 将整个 store、拼接后的 mutation key、mutation 方法、还有当前模块上下文传入，下面是 <code>registerMutation</code> 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将这些 <code>mutation</code> 通通传入 store.__mutations 这个数组中，不过这里你可能会好奇为什么 <code>_mutations[type]</code> 是一个数组，这是因为可能会不同模块中（没开启命名空间的情况）存在多个同名的 mutation，这时候需要调用所有同名的 mutation，其实 action 也是这样的。</p><p>这里的初始化仅仅只是包装一层使它们与命名空间的 key 关联在一起、以及在调用时自动传入一些模块上下文的参数而已。 同样的， <code>action</code> 和 <code>getter</code> 初始化过程都差不多，都是经过包装过存入 <code>_actions</code> 和 <code>_wrappedGetters</code> 中，当然由于 <code>action</code> 是支持异步的，所以需要额外处理一下 <code>Promise</code> 。</p><h3 id="5-初始化-state"><a href="#5-初始化-state" class="headerlink" title="5. 初始化 state"></a>5. 初始化 state</h3><p>初始化完 module 以后就会处理 <code>state</code> 里的数据，使它变成响应式，同时处理前面经过包装的 <code>getter</code> ，使它变成类似于 <code>computed</code> 意义的东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line"><span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">resetStoreVM(<span class="built_in">this</span>, state)</span><br></pre></td></tr></table></figure><p>下面是 <code>resetStoreVM</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store._vm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="comment">// reset local getters cache</span></span><br><span class="line">  store._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">    <span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">    computed[key] = partial(fn, store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line">  <span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line">  <span class="comment">// some funky global mixins</span></span><br><span class="line">  <span class="keyword">const</span> silent = Vue.config.silent</span><br><span class="line">  Vue.config.silent = <span class="literal">true</span></span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">$$state</span>: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new vm</span></span><br><span class="line">  <span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(<span class="function">() =&gt;</span> oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-处理-state"><a href="#5-1-处理-state" class="headerlink" title="5.1. 处理 state"></a>5.1. 处理 state</h4><p>原来 <code>vuex</code> 是直接 new 一个 Vue 实例来实现状态响应式，不过这样做无可厚非，毕竟 <code>vuex</code> 本来就是 Vue 专用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// silent 是取消 Vue 所有的日志与警告</span></span><br><span class="line"><span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line"><span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line"><span class="comment">// some funky global mixins</span></span><br><span class="line"><span class="keyword">const</span> silent = Vue.config.silent</span><br><span class="line">Vue.config.silent = <span class="literal">true</span></span><br><span class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">$$state</span>: state</span><br><span class="line">  &#125;,</span><br><span class="line">  computed</span><br><span class="line">&#125;)</span><br><span class="line">Vue.config.silent = silent</span><br></pre></td></tr></table></figure><h4 id="5-2-处理-getters"><a href="#5-2-处理-getters" class="headerlink" title="5.2. 处理 getters"></a>5.2. 处理 getters</h4><p>而 <code>getter</code> 的本质就是一个 <code>computed</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind store public getters</span></span><br><span class="line">store.getters = &#123;&#125;</span><br><span class="line"><span class="comment">// reset local getters cache</span></span><br><span class="line">store._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line"><span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">  <span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">  computed[key] = partial(fn, store)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="6-调用所有-plugin"><a href="#6-调用所有-plugin" class="headerlink" title="6. 调用所有 plugin"></a>6. 调用所有 plugin</h3><p>这个没什么好说的，就是把所有插件都调用一遍，传入 <code>this</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply plugins</span></span><br><span class="line">plugins.forEach(<span class="function">(<span class="params">plugin</span>) =&gt;</span> plugin(<span class="built_in">this</span>))</span><br></pre></td></tr></table></figure><h3 id="7-devtools"><a href="#7-devtools" class="headerlink" title="7. devtools"></a>7. devtools</h3><p>最后是一些 vue devtools 相关的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useDevtools =</span><br><span class="line">  options.devtools !== <span class="literal">undefined</span> ? options.devtools : Vue.config.devtools</span><br><span class="line"><span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">  devtoolPlugin(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/plugins/devtool.js</span></span><br><span class="line"><span class="keyword">const</span> target =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">    ? <span class="built_in">window</span></span><br><span class="line">    : <span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">    ? <span class="built_in">global</span></span><br><span class="line">    : &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">devtoolPlugin</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!devtoolHook) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  store._devtoolHook = devtoolHook</span><br><span class="line"></span><br><span class="line">  devtoolHook.emit(<span class="string">&#x27;vuex:init&#x27;</span>, store)</span><br><span class="line"></span><br><span class="line">  devtoolHook.on(<span class="string">&#x27;vuex:travel-to-state&#x27;</span>, <span class="function">(<span class="params">targetState</span>) =&gt;</span> &#123;</span><br><span class="line">    store.replaceState(targetState)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  store.subscribe(</span><br><span class="line">    <span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">      devtoolHook.emit(<span class="string">&#x27;vuex:mutation&#x27;</span>, mutation, state)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">prepend</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  store.subscribeAction(</span><br><span class="line">    <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">      devtoolHook.emit(<span class="string">&#x27;vuex:action&#x27;</span>, action, state)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">prepend</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是初始化 vuex 的整个过程了，不过有些地方只是粗略讲了一下，下面针对各种细节再深入探讨。</p><h2 id="二、调用-mutation-过程"><a href="#二、调用-mutation-过程" class="headerlink" title="二、调用 mutation 过程"></a>二、调用 mutation 过程</h2><p>下面讲讲调用某个  mutation 时会发生什么，比如我们使用如下代码调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;subModule1/increment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>首先会进入之前讲过的包装后的 <code>commit</code> ，它确保无论怎么调用 <code>this</code> 始终指向当前 store 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用真正的 <code>commit</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">commit</span>(<span class="params">_type, _payload, _options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        payload,</span><br><span class="line">        options</span><br><span class="line">    &#125; = unifyObjectStyle(</span><br><span class="line">        _type,</span><br><span class="line">        _payload,</span><br><span class="line">        _options</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> mutation = &#123;</span><br><span class="line">        type,</span><br><span class="line">        payload</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">            handler(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>._subscribers</span><br><span class="line">        .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub(mutation, <span class="built_in">this</span>.state))</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; options &amp;&amp; options.silent) &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class="line">            <span class="string">&#x27;Use the filter functionality in the vue-devtools&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面讲过可能会存在多个同名的 mutation，所以这里依次调用它们，但是为什么要先经过 <code>_withCommit</code> 方法呢？看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">_withCommit</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> committing = <span class="built_in">this</span>._committing</span><br><span class="line">    <span class="built_in">this</span>._committing = <span class="literal">true</span></span><br><span class="line">    fn()</span><br><span class="line">    <span class="built_in">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了严格模式，它会监听 state 值的变更，只要不是通过 mutation 内部来修改 state 值就会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  store._vm.$watch(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._data.$$state</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          store._committing,</span><br><span class="line">          <span class="string">`do not mutate vuex store state outside mutation handlers.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">sync</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、mapState、mapActions-这些绑定函数的实现"><a href="#三、mapState、mapActions-这些绑定函数的实现" class="headerlink" title="三、mapState、mapActions 这些绑定函数的实现"></a>三、mapState、mapActions 这些绑定函数的实现</h2><p>先来看看这四个方法的定义，它们的源码都在 src/helpers.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = normalizeNamespace(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = normalizeNamespace(<span class="function">(<span class="params">namespace, mutations</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = normalizeNamespace(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = normalizeNamespace(<span class="function">(<span class="params">namespace, actions</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>它们都先经过一个叫 <code>normalizeNamespace</code> 的方法处理，顾名思义这个方法是解析命名空间的，我们知道 <code>mapXXX</code> 这些方法可以接受一个或者两个参数，正常情况下第一个参数为 state module 的命名空间，第二个参数则是需要获取的内容，但是也支持只传入第一个参数，则这时候命名空间为 root。</p><p>所以这个方法的实现就简单了，只需要判断第一个参数是否为字符串，如果是的话则把它当成 map 处理，否则正常处理，并且在最后加上一个 <code>/</code> ，这个在前面初始化命名空间模块时就有提到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">      namespace += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这四个方法的实现都大同小异，这里就只记录 <code>mapState</code> 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = normalizeNamespace(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isValidMap(states)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;[vuex] mapState: mapper parameter must be either an Array or an Object&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> state = <span class="built_in">this</span>.$store.state</span><br><span class="line">      <span class="keyword">let</span> getters = <span class="built_in">this</span>.$store.getters</span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(<span class="built_in">this</span>.$store, <span class="string">&#x27;mapState&#x27;</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="built_in">module</span>.context.state</span><br><span class="line">        getters = <span class="built_in">module</span>.context.getters</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? val.call(<span class="built_in">this</span>, state, getters)</span><br><span class="line">        : state[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其核心原理就是将传入的 <code>states</code> 进行序列化，然后在当前命名空间对应的模块中获取到这些值，其中还要判断一下是否为函数，是的话则调用该函数并且传入当前模块中的 <code>state</code> 和 <code>getters</code> ，将函数的返回存入对象中，最后返回。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://liyucang-git.github.io/2019/07/21/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">vuex 源码解析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 踩坑小记</title>
      <link href="//post/uni-app-issues.html"/>
      <url>//post/uni-app-issues.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这里记录一些使用 uni-app 和 uView 开发时踩过的坑，希望能对后来者有所帮助。</p><h2 id="1-微信开发者工具关闭-ES6-转-ES5"><a href="#1-微信开发者工具关闭-ES6-转-ES5" class="headerlink" title="1. 微信开发者工具关闭 ES6 转 ES5"></a>1. 微信开发者工具关闭 ES6 转 ES5</h2><p>如果微信开发者工具开启了 ES6 转 ES5 的功能，会导致引入的 uView 组件无法正常使用，会报类似于下面这样的错：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728092428.png"></p><p>解决方案：把微信开发者工具的 ES6 转 ES5 功能关掉，设置 -&gt; 项目设置 -&gt; 本地设置。</p><h2 id="2-ref-不要放在-computed"><a href="#2-ref-不要放在-computed" class="headerlink" title="2. ref 不要放在 computed"></a>2. ref 不要放在 computed</h2><p>下面这份代码，在小程序端运行异常：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;button&quot;</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">buttonRef</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$refs.button</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.buttonRef.someMethods() <span class="comment">// 在 mp-weixin 会报：buttonRef 为空</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案：不要把 refs 的定义放在 computed，每次使用都直接通过 <code>this.$refs.button</code> 获取 。</p><h2 id="3-小程序端的组件样式问题"><a href="#3-小程序端的组件样式问题" class="headerlink" title="3. 小程序端的组件样式问题"></a>3. 小程序端的组件样式问题</h2><p>有可能你在 h5 编写好一个组件的样式，运行好好的，结果在小程序端却不正常了，原因在于小程序端会在组件外额外增加一层视图容器，这可能会导致诸如一些高度、外边距之类的样式失效，解决方案就是修改这个外层的样式，使它与我们这个组件的最外层样式一致：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  // <span class="selector-id">#ifdef</span> MP-WEIXIN</span></span><br><span class="line"><span class="css">  // HACk: 微信小程序端组件外面会多一层，需要给它也设置高度</span></span><br><span class="line"><span class="css">  [data-ref=<span class="string">&#x27;basicLayout&#x27;</span>], // 这里的值在微信开发者工具查看</span></span><br><span class="line"><span class="css">// #endif</span></span><br><span class="line"><span class="css">.basic-layout,</span></span><br><span class="line"><span class="css">.page-content &#123;</span></span><br><span class="line"><span class="css">    flex: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：由于这个选择器只针对小程序端，所以我们要加一个条件渲染。</p><h2 id="4-小程序端修改的外部组件样式无效的问题"><a href="#4-小程序端修改的外部组件样式无效的问题" class="headerlink" title="4. 小程序端修改的外部组件样式无效的问题"></a>4. 小程序端修改的外部组件样式无效的问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>如果要在 <code>.vue </code> 中修改外部组件的样式（如 uni-app 和 uView），像下面这样可能会无效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">u-search</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;日照香炉生紫烟&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">u-search</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">keyword</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.u-search</span> <span class="selector-class">.u-input</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728092634.png"><br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728092644.png"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>这是因为在 uni-app <code>&lt;style&gt;</code>   默认都是 <code>scope</code> 的，所以需要改成下面这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.container &#123;</span><br><span class="line"><span class="deletion">-  .u-search .u-input &#123;</span></span><br><span class="line"><span class="addition">+  /deep/ .u-search .u-input &#123;</span></span><br><span class="line">    color: red !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这样 H5 也能运行正常了：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728092659.png"></p><h3 id="小程序端修改-shadow-root-内部样式"><a href="#小程序端修改-shadow-root-内部样式" class="headerlink" title="小程序端修改 shadow-root 内部样式"></a>小程序端修改 shadow-root 内部样式</h3><p>但是还有一种情况，就是如果你要修改的组件位于 <code>#shadow-root</code> 下，就有可能无法修改，比如下面这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav-bar</span> &#123;</span><br><span class="line">  /deep/ <span class="selector-class">.uni-navbar__content</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: unset <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实根本没有修改到：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094252.png"></p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>这种情况，我们必须在 <code>App.vue</code> 下的 <code>&lt;style&gt;</code> 才能进行样式覆盖，但为了方便维护，我们新增了一个 <code>uni-custom-app.scss</code> 专门做这件事，用于解决上面这种情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 文件路径：<span class="attribute">src</span>/styles/uni-custom<span class="selector-class">.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个文件用于修改 uni 或者其他 ui 组件库的样式</span></span><br><span class="line"><span class="comment">* 由于微信小程序的限制，无法在组件内部修改其他外部组件的样式，只能在全局设置</span></span><br><span class="line"><span class="comment">* @link https://ask.dcloud.net.cn/question/68411</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 注意：如果不是全局修改，为避免影响其它，需要指定在外层页面和组件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">// 全局修改</span><br><span class="line">// <span class="selector-class">.u-btn</span> &#123;</span><br><span class="line">//   <span class="attribute">color</span>: red;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 局部修改</span><br><span class="line">// <span class="selector-class">.page-xxx</span> &#123;</span><br><span class="line">//   <span class="selector-class">.container</span> &#123;</span><br><span class="line">//     <span class="selector-class">.u-btn</span> &#123;</span><br><span class="line">//       <span class="attribute">color</span>: red;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们只要把上面的样式移动到这个文件即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文件路径：src/styles/uni-custom.scss</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="addition">+.page-message &#123;</span></span><br><span class="line"><span class="addition">+  .nav-bar &#123;</span></span><br><span class="line"><span class="addition">+    /deep/ .uni-navbar__content &#123;</span></span><br><span class="line"><span class="addition">+      overflow: unset !important;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到是有样式的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728100012.png"></p><p>但是你会看到我们写的样式权重似乎不够高，但其实样式已经被应用上去了，所以不用在意这里，至于为什么会这样，可能会微信开发者工具的问题吧？</p><p>注意：如果此样式只针对某个页面下的组件，建议在外面包一层该页面的唯一 class 名字，以防影响其它页面。</p><p>参考链接：<a href="https://ask.dcloud.net.cn/question/68411">https://ask.dcloud.net.cn/question/68411</a></p><p>如果是自定义 uButton 样式无效，可以看看：[18. 自定义 uButton 样式](</p><h2 id="5-在-HBuilder-运行项目"><a href="#5-在-HBuilder-运行项目" class="headerlink" title="5. 在 HBuilder 运行项目"></a>5. 在 HBuilder 运行项目</h2><p>由于我们是使用 cli 的方式生成的项目，所以基本开发只需要在命令行运行 <code>npm run dev:xxx</code> 即可，但是如果要调试 APP 端，还是使用 HBuilder 要更方便，然而如果在 在 HBuilder 运行 cli 项目 你可能会遇到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node Sass could not find a binding <span class="keyword">for</span> your current environment: OS X 64-bit with Node.js 8.x</span><br></pre></td></tr></table></figure><p>说白就是 node-sass 出了问题了，HBuilder 默认使用的 Node 版本是 v8.x，所以我们要修改一下配置，让它使用我们本机的 Node 版本。</p><p>在 偏好设置 -&gt; 运行配置 中修改 npm 和 Node 的路径即可：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728100327.png"></p><p>如果你不知道 Node 的路径在哪，可以这样：</p><ul><li>Linux/Mac： <code>where node</code></li><li>Windows：直接看系统环境变量</li></ul><p>参考：<a href="https://ask.dcloud.net.cn/question/67852">https://ask.dcloud.net.cn/question/67852</a></p><h2 id="6-动态插槽名"><a href="#6-动态插槽名" class="headerlink" title="6. 动态插槽名"></a>6. 动态插槽名</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要在 uni-app 中使用动态 slot 名字，会比较麻烦，因为：在 MP-WEIXIN、APP-PLUS 都会有坑。</p><h3 id="H5-和-小程序端"><a href="#H5-和-小程序端" class="headerlink" title="H5 和 小程序端"></a>H5 和 小程序端</h3><p>我们先说比较常用的 H5 和 MP-WEIXIN 好了：</p><p>定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- <span class="doctag">HACK:</span> uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #ifdef H5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;`tab:$&#123;item.key&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #ifdef MP-WEIXIN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.key&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #endif --&gt;</span></span><br></pre></td></tr></table></figure><p>使用 slot：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- <span class="doctag">HACK:</span> uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #ifdef H5 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:slot</span>=<span class="string">&quot;`tab:$&#123;item.id&#125;`&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">post-list</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- #ifdef MP-WEIXIN--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in lits&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;tab:professional:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">post-list</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://ask.dcloud.net.cn/question/82506">https://ask.dcloud.net.cn/question/82506</a></p><h3 id="APP-端"><a href="#APP-端" class="headerlink" title="APP 端"></a>APP 端</h3><p>如果还要兼容 APP 端（vue 文件），则情况会变得稍微复杂一点，以上两种情况都不适用，先说结论：</p><ol><li><strong>不支持拿 data 的数据用于拼接动态 slot 名字</strong></li><li><strong>在 v-for 中要根据当前项的字段来拼接 slot 名字，则要将 key 指向 <code>item</code>  本身（不推荐</strong></li><li><strong>能拿 v-for 的 index 来拼接 slot 名字（推荐</strong></li></ol><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>也即，如果是上面的例子，需要改写为如下：：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in tabs&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;swiper-item&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- <span class="doctag">HACK:</span> uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #ifdef H5 || APP-PLUS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;`tab:$&#123;index&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #ifdef MP-WEIXIN--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;index&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tab-swiper</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">&quot;tabSwiper&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:tabs</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:current.sync</span>=<span class="string">&quot;current&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:swiper-current.sync</span>=<span class="string">&quot;swiperCurrent&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- <span class="doctag">HACK:</span> uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #ifndef H5 || APP-PLUS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:slot</span>=<span class="string">&quot;`tab:$&#123;index&#125;`&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">post-list</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">:stagger</span>=<span class="string">&quot;index % 2 !== 0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- #ifdef MP-WEIXIN--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">post-list</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">:stagger</span>=<span class="string">&quot;index % 2 !== 0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- #endif  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tab-swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h4><p>下面开始排查问题，首先我们用以下代码测试用 data 的数据来作为 slot 名字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    testing dynamic slot</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;key&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">:class</span>=<span class="string">&quot;key&quot;</span>&gt;</span> test key value <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">key</span>: <span class="string">&#x27;slot-1&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用命令行或者 HBuilderx 编译 APP 端代码后，我们在 <code>dist/dev/app-plus/app-view.js</code></p><p>搜索 <code>testing dynamic slot</code> ，然后可以看到以下代码：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093109.png"><br>可以看到，即便同样使用了 key 作为属性，但它们编译后的代码是不一样的，slot 节点直接使用 <code>_vm._key</code> ，而 view 节点变成了 <code>_vm._$(2,&#39;c&#39;)</code> ，由此也推断出 uni-app 内部并没有对 slot 的 <code>name</code> 属性做额外处理，其实如果打印 <code>_vm.key</code> 的值， 会发现是空的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093132.png"></p><p><strong>所以结论一：不支持拿 data 的数据用于拼接动态 slot 名字。</strong></p><p>但直接拿 data 数据来拼接 slot 名字的情况比较少，更多时候是在 v-for 循环内部，所以我们再拿以下代码做测试：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    testing dynamic slot</span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;`tab:$&#123;item.id&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">list</span>: [</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;a&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-a&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;b&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-b&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;c&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-c&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        ]</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码在 APP 端依然是不正常的，我们看看编译后的代码：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093202.png"></p><p>代码看上去好像挺正常的是吧，但有一点很奇怪：为什么 key 直接指向了 <code>item</code> ？</p><p>果不其然，打印 <code>item</code> 发现这里的 <code>item</code> 并不是 v-for 中的那个 <code>item</code> 对象 ，而是用于指定 <code>key</code> 的值：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093223.png"></p><p>所以 <code>item.id</code> 依然是空的，实际上这里的 <code>item</code> === 外部的 <code>item.id</code> 。</p><p>既然如此，我们似乎得到两个解决方案：</p><ol><li>将 v-for 的 key 直接指向 item 本身，使 <code>item.id</code> 能正常访问</li><li>拼接 slot 名字时不使用 <code>item.id</code>  而是使用 <code>item</code></li></ol><p>结论是，方案一可行；方案二不可行。</p><p>至于为什么方案二不可行，我认为是 uni-app 的问题，因为打印出来的值是正确的。</p><p>但根据 Vue <a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">官方文档</a>指出：</p><blockquote><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></blockquote><p><strong>结论二：在 v-for 中要根据当前项的字段来拼接 slot 名字，则要将 key 指向 <code>item</code>   本身。</strong></p><p>最后一个解决方案，那就是通过 index 拼接 slot 名字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    testing dynamic slot</span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;`tab:$&#123;index&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">list</span>: [</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;a&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-a&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;b&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-b&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;c&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;item-c&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        ]</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码能在 APP 端正常运行。</p><p><strong>结论三：拿 v-for 的 index 来拼接 slot 名字。</strong></p><p>但毕竟是 HACK，终究原因是 uni-app 目前仍没有在 APP 端支持定义动态 slot ，可见相关的讨论：</p><ul><li><a href="https://ask.dcloud.net.cn/question/95109">https://ask.dcloud.net.cn/question/95109</a></li><li>如何评价 uni-app？ - 蘑菇王的回答 - 知乎 <a href="https://www.zhihu.com/question/309490398/answer/1181409781">https://www.zhihu.com/question/309490398/answer/1181409781</a></li></ul><p>所以 uni-app 官方什么时候支持动态 slot 名字呢？</p><h2 id="7-小程序端-v-for-中使用-v-if-问题"><a href="#7-小程序端-v-for-中使用-v-if-问题" class="headerlink" title="7. 小程序端 v-for 中使用 v-if 问题"></a>7. 小程序端 v-for 中使用 v-if 问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>这个问题需要同时满足以下条件才会触发：</p><ol><li>在 v-for 内部使用了 v-if</li><li>v-if 的断言依赖了 methods 或者 闭包 computed（就是需要根据入参动态返回结果</li><li>在 v-for 内部直接使用了小程序端的语法</li></ol><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>复现代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// tab-swiper.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- <span class="doctag">HACK:</span> uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- #ifdef H5 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:name</span>=<span class="string">&quot;`tab:$&#123;item.id&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- #ifndef H5--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- @see https://ask.dcloud.net.cn/question/82506 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">list</span>: [</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;recommend&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;推荐&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;public&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;公共知识&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">id</span>: <span class="string">&#x27;professional&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;专业项知识&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        ]</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tab-swiper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;tab:recommend&quot;</span>&gt;</span>recommend<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;tab:public&quot;</span>&gt;</span>public<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;tab:professional&quot;</span>&gt;</span>professional<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tab-swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> TabSwiper <span class="keyword">from</span> <span class="string">&#x27;@/components/tab-swiper&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      TabSwiper</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码一切运行正常，slot 也能正常显示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093432.png"><br>然而，只要我把代码改成这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;view v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; class=&quot;item&quot;&gt;</span><br><span class="line"><span class="addition">+      &lt;block v-if=&quot;isShow(index)&quot;&gt;</span></span><br><span class="line"><span class="addition">+        &lt;view&gt;显示我&lt;/view&gt;</span></span><br><span class="line"><span class="addition">+      &lt;/block&gt;</span></span><br><span class="line">      &lt;!-- HACK: uni-app 处理动态 slot 名字不兼容，需要使用不同的语法 --&gt;</span><br><span class="line">      &lt;!-- #ifdef H5 --&gt;</span><br><span class="line">      &lt;slot :name=&quot;`tab:$&#123;item.id&#125;`&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">      &lt;!-- #ifndef H5--&gt;</span><br><span class="line">      &lt;!-- @see https://ask.dcloud.net.cn/question/82506 --&gt;</span><br><span class="line">      &lt;slot name=&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;!-- #endif --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: &#x27;recommend&#x27;,</span><br><span class="line">          name: &#x27;推荐&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: &#x27;public&#x27;,</span><br><span class="line">          name: &#x27;公共知识&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: &#x27;professional&#x27;,</span><br><span class="line">          name: &#x27;专业项知识&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="addition">+  methods: &#123;</span></span><br><span class="line"><span class="addition">+   isShow(index) &#123;</span></span><br><span class="line"><span class="addition">+     return index % 2 === 0</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结果立马变成这样了：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093448.png"></p><p>那三个 slot 哪去了？别急，让我们对比一下两者生成的微信小程序代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是正常的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这是异常的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;$root.l0&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;item.m0&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span>&gt;</span>显示我<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面开始「找不同」，我们发现最大的不同是： <code>wx:for</code> 的值不一样，于是我们看下 <code>$root.l0</code> 的定义：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093530.png"></p><p>我们发现，在 <code>$root.l0</code> 下的每一个 item 项都多了一层 <code>$orig</code> 放置原本的内容，所以我们下面这行代码并不能访问到它的 id 值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们试着把这个值输出来看看：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 当前：&#123;&#123; item.id &#125;&#125;</span></span><br><span class="line">&lt;slot name=&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><p>你会发现居然能显示出来：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093542.png"></p><p>再看看生成的微信小程序代码，终于知道其中的奥妙：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;$root.l0&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;item.m0&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span>&gt;</span>显示我<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">block</span>&gt;</span> &lt;/block</span><br><span class="line">      &gt;&#123;&#123;&#x27;当前：&#x27;+item.$orig.id+&#x27;&#x27;&#125;&#125;<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>原来是 uni-app 自动帮我们添加了 <code>$orig</code> ，但由于 slot 那一行我们直接用了微信小程序的语法，所以并没有帮我们添加 <code>$orig</code> ，那么解决方案就是自己手动加上呗：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- &lt;slot name=&quot;tab:&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="addition">+ &lt;slot name=&quot;tab:&#123;&#123;item.$orig.id&#125;&#125;&quot;&gt;&lt;/slot&gt;</span></span><br></pre></td></tr></table></figure><p>问题是解决了，那么为什么会这样呢？应该是 uni-app 的转换机制，发现 v-for 和 v-if 存在一定关联，就把它们给缓存了，才会出现这种问题。</p><p><strong>核心要点：当微信小程序端异常时，不妨看看生成的代码，说不定有收获哦。</strong></p><h2 id="8-小程序端禁止事件冒泡"><a href="#8-小程序端禁止事件冒泡" class="headerlink" title="8. 小程序端禁止事件冒泡"></a>8. 小程序端禁止事件冒泡</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>在小程序端无法动态阻止事件冒泡，也即，在 js 中使用如下无效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    e.stopPropagation() <span class="comment">// 除了在 h5，其它端均无效</span></span><br><span class="line">    e.preventDefault() <span class="comment">// 同上</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>只能使用修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u-button</span> @<span class="attr">click.native.stop</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">u-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：需要加 <code>native</code> ，否则可能无法无效。</p><p>参考链接：<a href="https://github.com/dcloudio/uni-app/issues/1067">https://github.com/dcloudio/uni-app/issues/1067</a></p><p>关于 uni-app 中的修饰符兼容情况：<a href="https://uniapp.dcloud.io/vue-basics?id=%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符 —— uni-app</a></p><p>很显然， 使用事件修饰符的缺点是无法动态决定是否阻止事件冒泡，如果有这种需求，提供个 hack 思路：</p><ul><li>在外面包一层，利用 css 的 pointer-events 属性决定是否触发内层的 dom 事件</li></ul><p>另外还有一个坑，假设有如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;show = false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">u-icon</span> <span class="attr">name</span>=<span class="string">&quot;plus-circle-fill&quot;</span> @<span class="attr">click.native.stop</span>=<span class="string">&quot;show = !show&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">v-show</span>=<span class="string">&quot;show&quot;</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span>这是一条信息<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">show</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码想要实现当点击 icon 时切换显示 message，而点击 icon 以外的任意地方则隐藏 message。</p><p>在 H5 运行正常，但是在小程序端却会报如下错误：</p><blockquote><p>TypeError: Cannot read property ‘stopPropagation’ of undefined</p></blockquote><p>这是因为我们直接在 <code>@click</code> 的事件绑定中写了代码，而如果改成绑定 <code>methods</code> 则没有该问题：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view class=&quot;container&quot; @click=&quot;show = false&quot;&gt;</span><br><span class="line"><span class="deletion">-    &lt;u-icon name=&quot;plus-circle-fill&quot; @click.native.stop=&quot;show = !show&quot; /&gt;</span></span><br><span class="line"><span class="addition">+    &lt;u-icon name=&quot;plus-circle-fill&quot; @click.native.stop=&quot;toggleShowMessage&quot; /&gt;</span></span><br><span class="line">    &lt;view v-show=&quot;show&quot; class=&quot;message&quot;&gt;这是一条信息&lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      show: false,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="addition">+  methods: &#123;</span></span><br><span class="line"><span class="addition">+    toggleShowMessage() &#123;</span></span><br><span class="line"><span class="addition">+      this.show = !this.show</span></span><br><span class="line"><span class="addition">+    &#125;,</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>出现该问题的原因：如果直接在 Vue 的事件绑定中编写单行代码（不是绑定具体的方法），而 uni-app 转换为小程序端代码时会将它放到 <code>.js</code> 文件的方法中，并且由于使用了 <code>.stop</code> 事件修饰符，也在该方法中添加了 <code>$event.stopPropagation()</code> ，然而小程序端打印 <code>$event</code> 根本就是 <code>undefind</code> ，所以导致错误，可以看看生成的小程序代码：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093710.png"></p><p>这应该是 uni-app 的问题，关于这个问题更详细的描述可以看我在 uni-app 仓库提的这个 <a href="https://github.com/dcloudio/uni-app/issues/2400">issue</a>。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>总之：尽量不要在事件绑定中使用单行代码，特别是使用了事件修饰符的时候。</strong></p><h2 id="9-uView-两层-tabsSwiper-left-计算问题"><a href="#9-uView-两层-tabsSwiper-left-计算问题" class="headerlink" title="9. uView 两层 tabsSwiper left 计算问题"></a>9. uView 两层 tabsSwiper left 计算问题</h2><p>使用 uView 的 tabSwiper 组件时，如果存在两层或多层嵌套，会出现内层的 swiper-item 的 left 值计算错误，这是 uView 的 bug，具体问题描述和临时解决方案可见：<a href="https://github.com/YanxinNet/uView/issues/749">https://github.com/YanxinNet/uView/issues/749</a></p><h2 id="10-scss-文件进行条件渲染"><a href="#10-scss-文件进行条件渲染" class="headerlink" title="10. scss 文件进行条件渲染"></a>10. scss 文件进行条件渲染</h2><p>在 <code>.scss</code>   文件中进行 uni-app 的条件渲染，必须为多行注释，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #ifdef MP-WEIXIN */</span></span><br><span class="line"><span class="selector-class">.u-btn</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* #endif */</span></span><br></pre></td></tr></table></figure><p>另外，如果在 <code>.vue</code>   中的 <code>style</code>   标签，则无论使用单行注释还是多行注释，都是有效的。</p><h2 id="11-方法名不能与生命周期名字冲突"><a href="#11-方法名不能与生命周期名字冲突" class="headerlink" title="11. 方法名不能与生命周期名字冲突"></a>11. 方法名不能与生命周期名字冲突</h2><p>如题，写在 <code>methods</code>   下的方法名字不要与生命周期一致，否则会出现错误，这里的生命周期包括：</p><ul><li><a href="https://uniapp.dcloud.io/use?id=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">Vue 生命周期</a></li><li><a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">uni-app 生命周期</a></li></ul><h2 id="12-调试-uView-组件"><a href="#12-调试-uView-组件" class="headerlink" title="12. 调试 uView 组件"></a>12. 调试 uView 组件</h2><p>如果使用 uView 组件过程中遇到莫名其妙的问题，建议使用断点调试，可帮助你快速定位问题。</p><p>举个例子，想看看 <code>u-tabs-swiper</code>    组件的某个方法执行过程，可以到 <code>node_modules/uview-ui/components/u-tabs-swiper/u-tabs-swiper.vue</code>  ，找到你想调试的方法，打个断点：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728093759.png">然后在浏览器刷新，进行某些操作以便触发你想调试的方法，然后就可以进行断点调试了：</p><p>遗憾的是 uni-app 的自带组件，虽然也可以在 node-module 目录下找到对应的源码位置，但因为是预编译好的，所以进行修改无效，自然也不能打断点。</p><p>大部分 uni-app 的组件都在： <code>node_modules/@dcloudio/uni-h5/src</code>   下。</p><p><strong>核心要点：当组件莫名其妙地表现不正常时，别忘了使用断点调试。</strong></p><h2 id="13-SwipeAction-组件无法自动隐藏按钮"><a href="#13-SwipeAction-组件无法自动隐藏按钮" class="headerlink" title="13. SwipeAction 组件无法自动隐藏按钮"></a>13. SwipeAction 组件无法自动隐藏按钮</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>在使用 SwipeAction 组件时，发现在小程序端下的「点击收藏按钮后隐藏按钮」功能不正常，在官方示例程序也可复现该问题：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094505.gif" alt="img"></p><p>但实际上在 H5 端它是正常的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094538.gif" alt="img"></p><p>深入分析源码后，发现点击收藏按钮时， <code>btnClick</code> 和 <code>touchend</code> 两个方法的执行顺序在 H5 和 小程序端中表现不一致，分别在两个方法中加入 <code>console.log</code> ，运行结果是：</p><ul><li>H5</li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094614.png" alt="img"></p><ul><li>MP-WEIXIN</li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094625.png" alt="img"></p><p>而之所以在小程序端运行异常， 就是因为先执行了 <code>btnClick</code> 方法，而 <code>btnClick</code> 内部将 <code>this.status = false</code> ，导致随后执行 <code>touchend</code> 时进入了错误的条件分支。</p><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>这问题怎么解决？在不修改组件源代码的时候下，只能使用下面这种方式 HACK：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    click(index, index1) &#123;</span><br><span class="line">      if (index1 == 1) &#123;</span><br><span class="line">        this.list.splice(index, 1)</span><br><span class="line">        this.$u.toast(`删除了第$&#123;index&#125;个cell`)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // #ifdef MP-WEIXIN</span><br><span class="line">        /**</span><br><span class="line">         * HACK: 在 MP-WEIXN 表现异常，为避免被覆盖，需要过一段时间再更新值</span><br><span class="line">         * @see https://github.com/YanxinNet/uView/issues/761</span><br><span class="line">         */</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          this.list[index].show = false</span><br><span class="line">        &#125;, 100)</span><br><span class="line">        // #endif</span><br><span class="line">        // #ifndef MP-WEIXIN</span><br><span class="line">        this.list[index].show = false</span><br><span class="line">        // #endif</span><br><span class="line">        this.$u.toast(`收藏成功`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>已向 uView 提 issue：<a href="https://github.com/YanxinNet/uView/issues/761">https://github.com/YanxinNet/uView/issues/761</a></p><h2 id="14-IOS-底部空白安全区域"><a href="#14-IOS-底部空白安全区域" class="headerlink" title="14. IOS 底部空白安全区域"></a>14. IOS 底部空白安全区域</h2><p>子页面在 IOS 会出现一个空白的安全区域，可以通过修改 <code>manifest.json</code>   禁用它：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;app-plus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;safearea&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;bottom&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;offset&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://ask.dcloud.net.cn/article/35564">uni-app 全面屏、刘海屏适配（iphoneX 适配）及安全区设置</a></p><h2 id="15-APP-端锁定屏幕方向"><a href="#15-APP-端锁定屏幕方向" class="headerlink" title="15. APP 端锁定屏幕方向"></a>15. APP 端锁定屏幕方向</h2><p>通过 <code>manifest.json</code> 的 <a href="https://uniapp.dcloud.io/collocation/manifest?id=distribute">orientation</a> 选项可以进行横竖屏配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;distribute&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;orientation&quot;</span>: [<span class="string">&quot;portrait-primary&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果在测试基座， 以上选项会失效，所以最保险的方式是在 <code>APP.vue</code>   中进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// #ifdef APP-PLUS</span></span><br><span class="line">    <span class="comment">// 锁定竖屏</span></span><br><span class="line">    plus.screen.lockOrientation(<span class="string">&#x27;portrait-primary&#x27;</span>)</span><br><span class="line">    <span class="comment">// #endif</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该 API 还可以实现仅允许特定页面旋转方向，关于更多可见：<a href="https://www.html5plus.org/doc/zh_cn/device.html">HTML+ API Reference</a></p><p>关于屏幕旋转的更多可参考：</p><ul><li><a href="https://uniapp.dcloud.io/collocation/pages?id=globalstyle">globalStyle.pageOrientation</a></li><li><a href="https://uniapp.dcloud.io/collocation/manifest?id=distribute">orientation</a></li></ul><h2 id="16-uButton-自定义样式"><a href="#16-uButton-自定义样式" class="headerlink" title="16. uButton 自定义样式"></a>16. uButton 自定义样式</h2><p>根据 uView <a href="https://uviewui.com/components/button.html">文档</a> 说明，如果想要给 button 自定义样式，为了兼容小程序，则要在组件中传递 <code>custom-style</code>   属性，也就意味着需要把 CSS 写在 JS 中，这不是我们想要的，毕竟这样就无法使用 Scss 中的变量了。</p><p>为什么要这么麻烦呢？因为在小程序端，原本是一层的元素，被它搞成两层了，所以我们传递过去的 class 属性只应用在外层，而内层才是真正 button。</p><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;test-page&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">u-button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">u-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.test-page</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码在 H5 的表现是正常的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094742.png"><br>但在小程序的表现却是这样的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094757.png"></p><p>如果想 CSS 层面解决该问题，那就是都将它们都作为选择器即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view class=&quot;test-page&quot;&gt;</span><br><span class="line">    &lt;u-button class=&quot;btn&quot;&gt;按钮&lt;/u-button&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.test-page &#123;</span><br><span class="line">  .btn &#123;</span><br><span class="line"><span class="addition">+    &amp;,</span></span><br><span class="line"><span class="addition">+    button &#123;</span></span><br><span class="line">      color: red;</span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>虽然看上去很丑，但能 work，且兼容性较好，所以推荐使用该方式。</p><h2 id="17-uButton-无法自定义-hover-class"><a href="#17-uButton-无法自定义-hover-class" class="headerlink" title="17. uButton 无法自定义 hover-class"></a>17. uButton 无法自定义 hover-class</h2><p>根据 uView <a href="https://uviewui.com/components/button.html">文档</a> 说明，Button 组件有 hover-class 属性，可自定义 hover 时的 class，但实际使用并无效果，查看源代码后发现代码存在问题。</p><p>目前 GitHub 上已有人指出该问题，但维护者仍未处理：</p><ul><li><a href="https://github.com/YanxinNet/uView/issues/662">u-button hover-class 无效</a></li><li><a href="https://github.com/YanxinNet/uView/pull/741/files">修复 button 组件 hoverClass 不生效的问题</a></li></ul><p>在不修改原组件的情况下，只能通过强制覆盖它默认的 hover-class 的样式来解决该问题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;test-page&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">u-button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">u-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.test-page</span> &#123;</span></span><br><span class="line"><span class="css">    // HACK: 由于 uButton 的 hover-class 传递无效，暂时只能通过该方式自定义</span></span><br><span class="line"><span class="css">    /deep/ .btn &#123;</span></span><br><span class="line"><span class="css">      &amp;.u-default-hover,</span></span><br><span class="line"><span class="css">    // 兼容小程序</span></span><br><span class="line"><span class="css">    button.u-default-hover &#123;</span></span><br><span class="line"><span class="css">        color: white <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="built_in">rgba</span>($color-primary, <span class="number">0.8</span>) <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>为了避免影响其它 button，需要限制选择器范围</li><li>class 不一定是 <code>u-default-hover</code> ，可以自行测试该 button hover 时实际使用哪个 class</li><li>兼容小程序那里详见：<a href="#9WQn6">18. uButton 自定义样式</a></li></ol><h2 id="18-uni-app-只能在-main-js-注册全局组件"><a href="#18-uni-app-只能在-main-js-注册全局组件" class="headerlink" title="18. uni-app 只能在 main.js 注册全局组件"></a>18. uni-app 只能在 main.js 注册全局组件</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>在开发过程中，不可避免需要注册一些全局组件，为了方便管理，我们希望放到一个单独的文件中进行管理，类似下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/plugins/element.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">&#x27;@/layouts/basic&#x27;</span></span><br><span class="line"><span class="keyword">import</span> FullLoading <span class="keyword">from</span> <span class="string">&#x27;@/components/full-loading&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">Vue</span>) =&gt;</span> &#123;</span><br><span class="line">    Vue.component(<span class="string">&#x27;BasicLayout&#x27;</span>, BasicLayout)</span><br><span class="line">    Vue.component(<span class="string">&#x27;FullLoading&#x27;</span>, FullLoading)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> element <span class="keyword">from</span> <span class="string">&#x27;./plugins/element&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(element)</span><br></pre></td></tr></table></figure><p>这也是在开发 Vue 项目时常用的方案，但这在微信小程序端会运行异常，根本没有注册到全局组件。</p><p>但如果将注册全局组件的工作放到 <code>main.js</code>  ，则是可以正常运行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> element <span class="keyword">from</span> <span class="string">&#x27;./plugins/element&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">FIXME:</span> 因不明原因，在 main.js 外的文件注册全局组件会导致组件在 mp-weixin 端表现不正常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> BasicLayout <span class="keyword">from</span> <span class="string">&#x27;@/layouts/basic&#x27;</span></span><br><span class="line"><span class="keyword">import</span> FullLoading <span class="keyword">from</span> <span class="string">&#x27;@/components/full-loading&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;BasicLayout&#x27;</span>, BasicLayout)</span><br><span class="line">Vue.component(<span class="string">&#x27;FullLoading&#x27;</span>, FullLoading)</span><br></pre></td></tr></table></figure><p>该问题也早就有人提出过，但至今仍未看到官方团队有所回应，可见：</p><ul><li><a href="https://ask.dcloud.net.cn/question/86931">uni-app 全局组件 app 不显示</a></li><li><a href="https://ask.dcloud.net.cn/question/93821">【报 Bug】使用 Vue.use 注册全局组件，小程序不支持！</a></li></ul><p>而在 uni-app 官方文档的 <a href="https://uniapp.dcloud.io/use?id=%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6">全局组件</a> 是这样描述的：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094913.png"></p><p>虽然说了文档需在 <code>main.js</code> 中进行全局注册，但根据我们以往对 Vue 的认知，这个工作是可以放到外部文件去的，而 uni-app 也没有明确指出一定只能在 <code>main.js</code> 进行注册全局组件，这就造成不少用户困扰。</p><p>虽然集中在 <code>main.js</code> 注册全局组件也并不是不能接受，但我们需要知道背后的原因，为什么在外部文件注册就无效？</p><p>本文就来一探究竟，了解背后真正的原因。</p><h3 id="结论先行"><a href="#结论先行" class="headerlink" title="结论先行"></a>结论先行</h3><p>先说结论，说白了就是 uni-app 转换小程序代码时，检测全局组件的方式是通过静态分析 <code>main.js</code>   文件，所以在其他文件注册全局组件的话，uni-app 就无法得知了。</p><p>如果想知道更多细节，欢迎继续往下阅读 👇</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>首先，我们来看一下在 <code>main.js</code>   注册全局组件时，生成的微信小程序端 <code>pages.json</code>   的 <code>usingComponents</code> :</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094944.png"><br>很明显这是正常的，那我们再看看如果放在外部文件注册全局组件的话，它是空的：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728094951.png"><br>所以，问题肯定是发生在 uni-app 转换为小程序的过程中，下面就来定位 uni-app 的源码，看看究竟是什么情况。</p><p>但问题是，我们并不知道这部分代码在哪个位置，根本不知道从何看起？？</p><p>别着急，既然我们关心的代码是与 <code>usingComponents</code>   的赋值相关的，那我们可以试试在 <code>node_modules/@dcloudio</code> 搜索关键词 <code>usingComponents = </code></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095001.png"></p><p>可以看到结果比较多，我们快速扫一眼，发现几个比较可疑的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095014.png"></p><p>那我们的做法就是进入这几个文件，分别添加一行 <code>console.log</code>  ，以文件名为区分：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095027.png"> ，如果执行了这个文件，就会打印对应的值：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095039.png"></p><blockquote><p>注意：这时候是把全局组件注册放在 <code>main.js</code>   中</p></blockquote><p>很明显，我们运气不错，这个 <a href="https://github.com/dcloudio/uni-app/blob/master/packages/webpack-uni-mp-loader/lib/main-new.js">main-new.js</a>  应该就是我们想要的代码，下面我们就来看看 <code>components</code>   这个值到底是怎么出来的， <code>components</code>   的定义在 <a href="https://github.com/dcloudio/uni-app/blob/master/packages/webpack-uni-mp-loader/lib/main-new.js#L84">第 84 行</a>：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095053.png"><br>可以看到， <code>components</code>   是根据传入 <code>content</code>   到 <code>traverse()</code>   方法后得到的，我们先来打印一下 <code>content</code> （为避免干扰，可以先把之前的 console.log 去掉），然后我们看到以下：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095103.png"><br>可以看到这是 <code>main.js</code>   的内容，难道是通过解析这个文件的内容得到全局组件的？</p><p>我们还是看一下它给 <code>traverse()</code>   传递的参数，发现是一个通过 babel 解析后的 AST 树：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095113.png"><br>然后我们再看看 <code>traverse()</code>   内部，在 <a href="https://github.com/dcloudio/uni-app/blob/master/packages/webpack-uni-mp-loader/lib/babel/global-component-traverse.js">global-component-traverse.js</a>：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095125.png"><br>那看来的确如此，但这时候我还有一个疑问：<strong>上面只是说明 uni-app 是通过静态解析文件内容得到全局组件，那为什么不可以针对其它文件进行解析呢？</strong></p><p>我们看到其实 <code>content</code>   是从外部传入的，也就是说是别的文件传入了 <code>main.js</code>   的内容：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095125.png"><br>于是搜索当前文件的引用，一路顺藤摸瓜，找到起始的入口，它确实是只针对 <code>main.js</code>   进行解析，在 <a href="https://github.com/dcloudio/uni-app/blob/master/packages/vue-cli-plugin-uni/lib/mp/index.js#L112">vue-cli-plugin-uni/lib/mp/index.js</a>：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210728095253.png"></p><p>到此为止，我们已经知道为什么 uni-app 只能在 <code>main.js</code>   才能注册全局组件，而其它文件无效了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后还是得心平气和地评价几句，虽然在使用 uni-app 开发过程中踩了不少的坑，心里也曾不止一次有十万个草泥马奔腾而过，但是不可否认这么一个开发跨平台应用的前端框架来说，它做的还是有值得称赞的地方，至少从生态上面就足以秒杀其它同样是 Vue 语法的开发跨平台框架。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>司马迁是一个什么样的人？</title>
      <link href="//post/about-si-ma-qian.html"/>
      <url>//post/about-si-ma-qian.html</url>
      
        <content type="html"><![CDATA[<p>孟子有这么一句话：“颂其诗，读其书，不知其人可乎？是以论其世也，是尚友也。”</p><p>所以在阅读《史记》之前，应该要好好了解一下司马迁这个人的一生，知道他是一个什么样的人，身处在一个什么样的环境之中，这样才能理解他为什么要写《史记》，以及《史记》这本书到底有什么不同，为什么后世对这本书的评价如此之高，乃至于被鲁迅誉为：史家之绝唱，无韵之离骚。</p><p>我们可以通过阅读《史记》中的最后一篇<a href="https://zh.wikisource.org/wiki/%E5%A4%AA%E5%8F%B2%E5%85%AC%E8%87%AA%E5%BA%8F">《太史公自序第七十》</a>，以及<a href="https://zh.m.wikisource.org/zh-hans/%E5%A0%B1%E4%BB%BB%E5%B0%91%E5%8D%BF%E6%9B%B8">《报任少卿书》</a>这封信来回答上面这些问题。下面我简单讲一下我从这两篇文章中了解到的司马迁以及一些我个人的感受，但由于本人学识有限，加之生活阅历不够丰富，有些观点可能有失偏颇，大家看看就好。同时为了避免产生争议，以下内容我都会附上原文，如果觉得我的理解有偏差，大家也可自行阅读理解。</p><h2 id="他的家族"><a href="#他的家族" class="headerlink" title="他的家族"></a>他的家族</h2><blockquote><p>昔在颛顼，命南正重以司天，北正黎以司地。唐虞之际，绍重黎之后，使复典之，至于夏商，故重黎氏世序天地。其在周，程伯休甫其后也。当周宣王时，失其守而为司马氏。司马氏世典周史。惠襄之闲，司马氏去周适晋。晋中军随会奔秦，而司马氏入少梁。</p><p>自司马氏去周适晋，分散，或在卫，或在赵，或在秦。其在卫者，相中山。在赵者，以传剑论显，蒯聩其后也。在秦者名错，与张仪争论，于是惠王使错将伐蜀，遂拔，因而守之。错孙靳，事武安君白起。而少梁更名曰夏阳。靳与武安君坑赵长平军，还而与之俱赐死杜邮，葬于华池。靳孙昌，昌为秦主铁官，当始皇之时。蒯聩玄孙卬为武信君将而徇朝歌。诸侯之相王，王卬于殷。汉之伐楚，卬归汉，以其地为河内郡。昌生无泽，无泽为汉市长。无泽生喜，喜为五大夫，卒，皆葬高门。喜生谈，谈为太史公。</p></blockquote><p>这里指出司马迁的祖先从五帝时期就开始掌管天文、地理，到了周朝便开始掌管周史，到了周惠王、襄王统治时期，司马氏的族人分散到卫、赵、秦这三个国家，而来到秦国的叫做司马错，历代也都有担任官职，到了汉武帝时期，司马谈担任太史一职，这正是司马迁的父亲。</p><h2 id="他受到怎样的教育？"><a href="#他受到怎样的教育？" class="headerlink" title="他受到怎样的教育？"></a>他受到怎样的教育？</h2><blockquote><p>太史公既掌天官，不治民。有子曰迁。</p><p>迁生龙门，耕牧河山之阳。年十岁则诵古文。二十而南游江、淮，上会稽，探禹穴，闚九疑，浮于沅、湘；北涉汶、泗，讲业齐、鲁之都，观孔子之遗风，乡射邹、峄；戹困鄱、薛、彭城，过梁、楚以归。于是迁仕为郎中，奉使西征巴、蜀以南，南略邛、笮、昆明，还报命。</p></blockquote><p>司马谈有一个儿子叫做司马迁，他生于龙门（今陕西韩城），过着耕种畜牧的生活，年仅十岁便已习诵古文，二十岁就开始游历四方，曾经去看过孔子的遗风，走过了很多地方，最后回朝廷当一名郎中。</p><p>历史上很多有名的神童（比如苏轼、司马光等等），大多都是从三岁左右就开始学习，相比之下司马迁从十岁才开始学习，感觉是不是有点晚了，但是据考究这个「诵」字指的并不是学习朗读这么简单，而是指的是「背诵」，那这么看来还是非常厉害了，至少大部分现代人是做不到吧。</p><p>二十岁便游历四方，游历对一个人增长见识有很大的帮助，司马迁的这段经历，也对他后来写《史记》起到了非常重要的帮助。</p><p>在这里说一个题外话，那个时候的书籍还是用竹简写的，我从网上得知一本百万字的书籍差不多有一百公斤，而且那个时候由于焚书坑儒，很多先秦史籍被消失了，只剩下少部分书籍隐藏在民间。在这种情况下，那个时候的古人要读书其实挺困难，好在司马迁是生在书香世家，还是个官二代，自然不用担心这个问题。可惜一般人想要读这些书就只能靠借，而且因为太重，一次只能借一小部分，从这里也看出，我们现代人常说教育资源不平等的问题，在两千多年前就已经存在了。</p><p>说回原文这段话，从这段话里面得知，司马谈是从小就重点栽培司马迁的，虽然这里没有提到，但实际上司马迁的老师是董仲舒，可谓是名师出高徒了。下面我们也会提到，司马谈早就想要写《史记》这本书，但他也知道凭借他一个人的力量，是不足以完成这部巨作的，所以他要培养一个接班人，也就是他的儿子，他希望他儿子子承父业完成他毕生的心愿。我们常说望子成龙、望女成凤，但这是不现实的，因为望是没有用的，也永远望不到头，真正的做法应该是教子成龙、以身作则，如果你自己都做不到的事，凭什么希望你的孩子能够做到？所以身为父母，应该要懂得这个道理，中国历史上我最喜欢的两号人物，一个是司马迁、一个是苏轼，而他们的父亲恰恰就是教子成龙这一类。</p><h2 id="他为什么要写史记？"><a href="#他为什么要写史记？" class="headerlink" title="他为什么要写史记？"></a>他为什么要写史记？</h2><blockquote><p>是岁天子始建汉家之封，而太史公留滞周南，不得与从事，故发愤且卒。而子迁适使反，见父于河洛之闲。太史公执迁手而泣曰：“余先周室之太史也。自上世尝显功名于虞夏，典天官事。后世中衰，绝于予乎？汝复为太史，则续吾祖矣。今天子接千岁之统，封泰山，而余不得从行，是命也夫，命也夫！余死，汝必为太史；为太史，无忘吾所欲论著矣。且夫孝始于事亲，中于事君，终于立身。扬名于后世，以显父母，此孝之大者。夫天下称诵周公，言其能论歌文武之德，宣周邵之风，达太王王季之思虑，爰及公刘，以尊后稷也。幽厉之后，王道缺，礼乐衰，孔子修旧起废，论诗书，作春秋，则学者至今则之。自获麟以来四百有馀岁，而诸侯相兼，史记放绝。今汉兴，海内一统，明主贤君忠臣死义之士，余为太史而弗论载，废天下之史文，余甚惧焉，汝其念哉！”迁俯首流涕曰：“小子不敏，请悉论先人所次旧闻，弗敢阙。”</p></blockquote><blockquote><p>太史公曰：“先人有言：‘自周公卒五百岁而有孔子。孔子卒后至于今五百岁，有能绍明世，正易传，继春秋，本诗书礼乐之际？’意在斯乎！意在斯乎！小子何敢让焉。”</p></blockquote><p>司马谈认为从孔子写作《春秋》之后的四百余年，由于诸侯相互兼并，史书丢弃殆尽，如今汉朝兴起，海内统一，明主贤君忠臣死义之士，我作为太史都未能予以论评载录，断绝了天子的修史传统。他认为自己应当担任起这个职责，写一部体系完整的史书，只可惜他只做了一些准备工作，就因为汉武帝赴泰山举行封禅典礼之事，却没有带上身为史官的他，结果因此积怨而终。</p><p>司马谈临终前握着司马迁的手哭着说：“我们的祖先历代掌管历史，远在虞夏的时候就已经显扬功名，但是后世逐渐衰落，难道今天就要断绝在我手上吗？等我死了以后，你一定会当上太史，记住要继续完成《史记》这本书，接续祖先的事业！”。而司马迁回答：“儿子虽然愚笨，但我会详述先人所整理的历史旧闻，不敢稍有缺漏。”</p><p>从上文我们得知，《史记》这本书是司马迁两父子倾注毕生心血，这是他们作为史官的责任，必须要把历史传承下去，这是一件多么伟大的事业。</p><p>上文有一句话我想重点讲一下：</p><blockquote><p>且夫孝始于事亲，中于事君，终于立身。扬名于后世，以显父母，此孝之大者。</p></blockquote><p>这里讲了孝的几种层次，我的理解就是：如果你养育父母，这是第一层次；如果你当官，那是第二层次；如果你扬名于后世，让后世的人仍然知道你的风光伟绩，因此知道你的父母教出这么伟大的一个孩子，那这才是真正的大孝。</p><p>我是否认同这个观点暂且不谈，但是我在阅读《史记》和《报任少卿书》时多次会回想起这句话。比如，当我读《伯夷列传》时：</p><blockquote><p>伯夷、叔齐，孤竹君之二子也。父欲立叔齐，及父卒，叔齐让伯夷。伯夷曰：“父命也。”遂逃去。叔齐亦不肯立而逃之。国人立其中子。</p></blockquote><p>这个伯夷叔齐为了让国逃走，最后被饿死在首阳山的故事相信很多人都听过，但我这里想说的是最后一句话：国人立其中子。</p><p>为什么第二个儿子当了国君，但《史记》却不记载他的名字？虽然我通过网上搜寻得知到这个人叫做亚凭，但关于他的资料实在太少，所以从这里我得出一个结论：如果你一生的作为在历史的长河上起不到任何的影响，那么即便是当了国君，历史也没有必要记载你，反观伯夷叔齐二人，虽然没有当上国君，但是他们的故事却一直流传下来被后世所熟知。不过，伯夷叔齐能不能算是「孝之大者」呢？</p><p>还有当我读到《吴太伯世家》，同样是读到太佰、仲雍二人让国：</p><blockquote><p>吴太伯，太伯弟仲雍，皆周太王之子，而王季历之兄也。季历贤，而有圣子昌，太王欲立季历以及昌，于是太佰、仲雍二人乃奔荆蛮，文身断发，示不可用，以避季历。季历果立，是为王季，而昌为文王。太伯之奔荆蛮，自号句吴。荆蛮义之，从而归之千馀家，立为吴太伯。</p></blockquote><p>虽然同样是让国，但这次是有记载当上国君的人叫做季历，但是我从<a href="https://zh.wikipedia.org/wiki/%E7%8E%8B%E5%AD%A3">维基百科</a>上看到的相关资料也很少，为什么他有名字呢？因为他有个儿子叫做昌，也就是周文王。所以，周文王也能算是「孝之大者」吧？</p><p>但这个故事我还有一个更大的疑问，太佰、仲雍二人为了让国，竟然奔荆蛮，文身断发，古人认为身体发肤受之父母，所以他们这么做是非常不孝的。但是一方面，他们知道父亲想要立最小的儿子季历为王，但由于这是破坏宗法的，即便他是国君也不能破坏，而太佰、仲雍知道父亲的心愿，他们为了实现父亲的心愿，只有自愿放弃国君的位置，并且做出文身断发这种大不孝的事，才能让最小的弟弟继承王位，他们这样的行为也能算是「孝之大者」吧？</p><p>在《史记》中这样的例子还有非常多，比如司马迁身受腐刑让祖辈蒙羞是不孝吧？但他写了《史记》这本书，扬名于后世，这是大孝吧？比如伍子胥在他父亲被捉时，他哥哥选择陪他父亲赴死，而伍子胥却要逃跑，这是不孝吧？但他最后报了杀父杀兄之仇，这也能算是孝吧？</p><p>扯远了，说回司马谈临终前吩咐司马迁继续完成《史记》这件事，上面提到司马谈是因为自从孔子写作《春秋》之后，史书丢弃殆尽，所以他要担负起这个责任，但写史书是为了什么呢？</p><blockquote><p>壶遂曰：“孔子之时，上无明君，下不得任用，故作春秋，垂空文以断礼义，当一王之法。今夫子上遇明天子，下得守职，万事既具，咸各序其宜，夫子所论，欲以何明？”</p></blockquote><blockquote><p>太史公曰：“唯唯，否否，不然。余闻之先人曰：‘伏羲至纯厚，作易八卦。尧舜之盛，尚书载之，礼乐作焉。汤武之隆，诗人歌之。春秋采善贬恶，推三代之德，褒周室，非独刺讥而已也。’汉兴以来，至明天子，获符瑞，封禅，改正朔，易服色，受命于穆清，泽流罔极，海外殊俗，重译款塞，请来献见者，不可胜道。臣下百官力诵圣德，犹不能宣尽其意。且士贤能而不用，有国者之耻；主上明圣而德不布闻，有司之过也。且余尝掌其官，废明圣盛德不载，灭功臣世家贤大夫之业不述，堕先人所言，罪莫大焉。余所谓述故事，整齐其世传，非所谓作也，而君比之于春秋，谬矣。”</p></blockquote><p>壶遂问他：“孔子的时候，是因为天下没有明君，所以写作《春秋》，空留下一部史文来裁断礼义，当作一代帝王的法典。但是现在我们的天子是一位明君，你想要写什么呢？”</p><p>司马迁回答：“写史书并不是因为这样，伏羲最纯厚，但那个时期有《易》；尧舜时期很强盛但那时候有《尚书》；商汤王、周武王功业的隆盛，诗人歌颂不绝。《春秋》扬善贬恶，推崇夏、商、周三代的盛德，赞扬周朝王室，所以修史并非仅限于讥讽呀。况且我曾担任太史令的职务，若弃置天子圣明盛德而不予记载，埋没功臣、世家、贤大夫的功业而不予载述，违背先父临终遗言，罪过就实在太大了。”</p><p>虽然司马迁这么回答，但是我看了《史记》大一半了，给我感觉是：好人好事基本没有、坏人坏事一大堆，父子兄弟互相残杀的事比比皆是，不过我并不是说司马迁就专门拿这些不好的事出来写，而是如果要如实记载中国历史，还真的没有多少件好事，为数不多比较好的，也都写到教科书上被大家所熟知了，剩下那些全是不好的，自然也不太好拿出来宣传，大家可以亲自读读《史记》，这真的不是我胡说八道。</p><h2 id="他是一个什么样的人？"><a href="#他是一个什么样的人？" class="headerlink" title="他是一个什么样的人？"></a>他是一个什么样的人？</h2><p>前面讲了司马迁受到的教育、以及为什么写《史记》，现在讲讲他在写作《史记》时身处的环境、以及他的一些内心感受。</p><p>我们可以从《报任少卿书》得到这些答案，在这之前先交代一下司马迁写《报任少卿书》时的一些背景：</p><p>司马迁因为李陵事件时在汉武帝面前替李陵讲了一些好话，因此要被处以死刑，但他因为那时候还没有写完《史记》，所以选择自宫得以保全性命。（其实汉代时死刑是可以花钱赎的，但司马迁因为没钱，所以选择了第二个选项）</p><p>后来司马迁的好朋友仁安因为蛊惑之祸导致入狱准备判死刑，写信求助于司马迁，希望司马迁帮他求情，而《报任少卿书》就是司马迁给仁安的回信。其实我在之前的文章中也有讲过《报任少卿书》，感兴趣的同学可以点<a href="https://4ark.me/posts/bao-ren-shao-qing-shu.html">这里</a>看看。</p><blockquote><p>僕闻之：修身者，智之符也；爱施者，仁之端也；取与者，义之表也；耻辱者，勇之决也；立名者，行之极也。士有此五者，然后可以託于世，列于君子之林矣。故祸莫憯于欲利，悲莫痛于伤心，行莫丑于辱先，而诟莫大于宫刑。刑馀之人，无所比数，非一世也，所从来远矣。昔卫灵公与雍渠同载，孔子适陈；商鞅因景监见，赵良寒心；同子参乘，爰丝变色。自古而耻之。夫以中才之人，事有关于宦竖，莫不伤气，而况于忼慨之士乎！如今朝虽乏人，柰何令刀锯之馀荐天下豪隽哉！</p></blockquote><p>从这段话就能看出司马迁对于自己已经成为宦官这件事是非常悲痛的，他先是说明哪几种人可以成为君子，实际上是为了衬托出宦官的低贱，用了非常多的例子来说明一个宦官在社会的地位是极低的：从前卫灵公与宦官雍渠同坐一辆车子，孔子感到这对他是一种侮辱，便离开卫国到陈国去，商鞅通过姓景的太监而得以谒见秦孝公，贤士赵良为此担忧；太监赵谈陪坐在汉文帝的车上，袁丝为之脸色大变。可见自古以来，人们把与太监相并列当做一种耻辱。</p><p>最后他还以此回应仁安的求助请求：如今朝廷虽然缺乏人才，但怎么会让一个已经是宦官的人，来推荐天下的豪杰俊才呢？</p><p>这里的推荐天下豪杰俊才，指的就是推举任少卿，其实也就是帮他求情啦。</p><blockquote><p>太上不辱先，其次不辱身，其次不辱理色，其次不辱辞令，其次诎体受辱，其次易服受辱，其次关木索被棰楚受辱，其次剔鬄毛髮婴金铁受辱，其次毁肌肤断支体受辱，最下腐刑，极矣。传曰：“刑不上大夫。”此言士节不可不厉也。</p></blockquote><p>这里司马迁用层层递进的方式来讲述一个人受到侮辱的方式，最下等的就是宫刑，简直侮辱到了极点。古书说“刑不上大夫”，这句话的意思是说，对于士大夫的气节，不可不劝勉鼓励啊（鼓励士大夫在犯罪以后勇于自杀，自杀就坚守了士大夫的气节）。</p><p>在当时的人看来，司马迁既要作死为李陵说话，又要贪生怕死宁愿接受宫刑也不愿去死，简直就是笑话，看下面这几句话：</p><blockquote><p>若僕大质已亏缺矣，虽才怀随和，行若由夷，终不可以为荣，适足以发笑而自点耳。</p></blockquote><blockquote><p>而僕又茸以蚕室，重为天下观笑。悲夫！悲夫！事未易一二为俗人言也。</p></blockquote><blockquote><p>且负下未易居，下流多谤议，僕以口语遇遭此祸，重为乡党戮笑，污辱先人，亦何面目复上父母丘墓乎？虽累百世，垢弥甚耳！是以肠一日而九回，居则忽忽若有所亡，出则不知所如往。每念斯耻，汗未尝不发背霑衣也。</p></blockquote><p>司马迁在文章中三次用到「笑」这个字，第一个是「发笑」，就是司马迁做了这件事让别人笑；第二个是「观笑」，就是别人看到司马迁都会笑；第三个是「戮笑」，其实就是耻笑。</p><blockquote><p>今虽欲自雕瑑，曼辞以自解，无益，于俗不信，祗取辱耳。</p></blockquote><blockquote><p>人固有一死，死有重于泰山，或轻于鸿毛，用之所趋异也。</p></blockquote><blockquote><p>夫人情莫不贪生恶死，念亲戚，顾妻子，至激于义理者不然，乃有所不得已也。今僕不幸，蚤失二亲，无兄弟之亲，独身孤立，少卿视僕于妻子何如哉？且勇者不必死节，怯夫慕义，何处不勉焉！僕虽怯懦耎欲苟活，亦颇识去就之分矣，何至自湛溺累绁之辱哉！且夫臧获婢妾犹能引决，况若僕之不得已乎！所以隐忍苟活，函粪土之中而不辞者，恨私心有所不尽，鄙没世而文采不表于后也。</p></blockquote><blockquote><p>古者富贵而名摩灭，不可胜记，唯俶傥非常之人称焉。盖西伯拘而演周易；仲尼厄而作春秋；屈原放逐，乃赋离骚；左丘失明，厥有国语；孙子髕脚，兵法修列；不韦迁蜀，世传吕览；韩非囚秦，说难、孤愤。诗三百篇，大氐圣贤发愤之所为作也。此人皆意有郁结，不得通其道，故述往事，思来者。及如左丘明无目，孙子断足，终不可用，退论书策以舒其愤，思垂空文以自见。</p></blockquote><p>我们后世人当然已经知道司马迁宁愿选择宫刑而不去死是因为他有更重要的事情未完成，在这之前即便饱受屈辱，也要活下去，只是在当时他并没有跟别人讲他的苦衷，任由别人耻笑他。</p><blockquote><p>僕诚已著此书，藏诸名山，传之其人通邑大都，则僕偿前辱之责，虽万被戮，岂有悔哉！</p></blockquote><p>司马迁是贪生怕死的人吗？并不是，他想完成这本史书，让它能够广传于天下，那么即便让他承受更多的耻辱，他也不会后悔。</p><h2 id="司马迁的文学才华"><a href="#司马迁的文学才华" class="headerlink" title="司马迁的文学才华"></a>司马迁的文学才华</h2><p>司马迁的文学才华是非常好的，他上面这封《报任少卿书》更是被誉为：千古第一书信。无论是在历史、文学上都有着非常高的价值。</p><p>而且我认为在文学上，如果要打动人心，第一是要真、第二是要痛。比如我在看《活着》这本书的时候，我非常有感触，为什么呢？因为我知道它是真实发生过的。所以为何《报任少卿书》这么打动人心呢？因为司马迁在这封信里将自己心里最深的隐衷道出来了，其能让人不为之动容呢？</p><p>司马迁在《史记》上的叙事方式更是精彩绝伦，甚至不同的传记他会用不同的方式去写作，比如在刘邦在《高祖本纪》是比较忠厚老实的，但是在其他人物的传记中，却经常能够体现出刘邦的那种阴险狡诈、六亲不认的为人性格。</p><p>后世人也不少人称赞司马迁的文笔，比如班固：自刘向、杨雄博极群书，皆称迁有良史之材，服其状况序事理，辩而不华，质而不俚，其文直、其事核，不虚美、不隐恶，故谓之实录。</p><p>韩愈：汉朝人莫不能文，独司马相如、太史公、刘向、杨雄之为最。</p><p>当然还有现代人最为熟知的，就是鲁迅的评价：史家之绝唱，无韵之离骚。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>经过上面的介绍，相信你已经知道司马迁为什么要写这本书了，很多人常说历史很多都是虚构的，历史是任人打扮的小姑娘，干脆就不读任何历史，我不否认很多历史可能是假的，我也深知即便在近现代仍有很多历史事件不被大家所熟知，但我相信历史是公正的，历史或许可以被修改或掩饰，但总会有人甘愿付出生命也要道出真相，迟早有一天会真相大白，没有人敢说《史记》上面的事情百分之一百全部真实，但我认为像《史记》这样一本历经司马迁两父子的毕生心血创作出来的书，它跟其它那些只会歌颂某个朝代的官修史，能一样吗？</p><p>虽然现在仍没有明确证据说明司马迁的死是因为这本书，但在后来《史记》公布于天下时，汉朝当时把可能读过这部的人都捉起来杀掉这样的反应来看，我认为司马迁死于这本书的可能性很大。即便他可能不是死于这本书，但正如他所讲：古者富贵而名摩灭，不可胜记，唯俶傥非常之人称焉。</p><p>后世对司马迁的评价基本是只褒不贬的。想想也是理所当然，这样一个为了责任而写一本书可以做牛做马受尽屈辱，甚至不惜献出自己生命，给后世留下了宝贵的财富，这样的人怎能不尊敬他呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 史记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三月总结</title>
      <link href="/post/2021-03-31-2021-mar-summary.html"/>
      <url>/post/2021-03-31-2021-mar-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="uni-app-踩坑小记"><a href="#uni-app-踩坑小记" class="headerlink" title="uni-app 踩坑小记"></a>uni-app 踩坑小记</h2><p>这是我去年在工作中使用 uni-app 和 uView 踩的一些坑，虽然大部分通过搜索引擎能够找到解决方法，但这些记录更为深入的探究了背后的原因，主要是途径就是看 uni-app 的源码或者分析编译后的代码，本着共享精神，也希望大家不要重复踩坑，相信能够对大家有所帮助。</p><p>另外由于在语雀上也能支持互联网索引，也就没必要再搬过来了，且在语雀上的阅读体验要更好。</p><p>这是链接：<a href="https://www.yuque.com/4ark/cya7sq/tvs0tu">uni-app 踩坑小记 · 语雀 (yuque.com)</a></p><h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="https://dbanotes.net/review/the_students.html">现在的计算机专业学生怎么这个样？</a><ul><li>冯大辉在 2004 年发表的文章，讲了计算机专业的大学生有多浮躁，今天看来依然没变。</li></ul></li><li><a href="https://blog.dteam.top/posts/2019-05/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E5%91%98%E5%80%BC%E5%BE%97%E8%8A%B1%E6%97%B6%E9%97%B4%E5%9F%B9%E5%85%BB%E8%87%AA%E5%B7%B1%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4.html">为什么程序员值得花时间培养自己的商业思维？</a><ul><li><a href="https://blog.dteam.top/posts/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E7%AE%97%E8%B4%A6.html">程序员的商业思维：学会算账</a>：要考虑成本，除了成本，我们还应放眼于所得收益，毕竟：每个收益都有其合理的成本要求。</li><li><a href="https://blog.dteam.top/posts/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E8%A1%A8%E8%BE%BE.html">程序员的商业思维：学会表达</a>：提升表达力的渠道有写文章、尝试演讲等，另外代码能力本质上也是表达能力的一种。</li><li><a href="https://blog.dteam.top/posts/2019-07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9B%E5%BA%94%E9%93%BE.html">程序员的商业思维：建立自己的供应链</a>：1）找到你在供应链的位置；2）让外界知道你的能力，打造你的品牌。</li><li><a href="https://blog.dteam.top/posts/2019-08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.htmlhttps://blog.dteam.top/posts/2019-08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.html">程序员的商业思维：解决问题</a>：1）你掌握的技能不值钱，真正值钱的是你运用技能的能力；2）问题本身的价值越大，那么解决能力的价值也就越大；3）自己解决问题的能力固然重要，但是借助外部资源解决问题的能力同样重要；4）不要打着解决问题的幌子制造问题。</li><li><a href="https://blog.dteam.top/posts/2019-11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%90%9B%E5%AD%90%E4%B9%9F%E8%A6%81%E8%A8%80%E5%88%A9.html">程序员的商业思维：君子也要言利</a>：谈钱效率高，钱本来就是一种最有效的量化手段。</li><li><a href="https://blog.dteam.top/posts/2019-12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E5%A4%96%E4%BA%A4.html">程序员的商业思维：学会外交</a>：1）外交不是拉关系，“关系”很重要，但仅仅认为这就是“拉关系”就是大错特错；2）当客户总强调你需要替他考虑而不替你考虑时，请果断放弃；策略：守住底线、双赢思维、有的放矢、明确定价。</li><li><a href="https://blog.dteam.top/posts/2020-03/something-about-personal-leverage.html">程序员的商业思维：关注杠杆率</a>：1）从字面上看，杠杆率并不高深，无外乎代表你一份努力能撬动多大的结果；2）产品化思维有助于提高你的个人杠杆率；3）杠杆率是你的变现能力，了解自己的杠杆率，也是你跟老板谈判的筹码。</li></ul></li></ul><h3 id="文章（技术类）"><a href="#文章（技术类）" class="headerlink" title="文章（技术类）"></a>文章（技术类）</h3><ul><li><a href="https://web.dev/content-visibility/">content-visibility: the new CSS property that boosts your rendering performance</a><ul><li>Chrome CSS 新属性，跳过屏幕外内容的渲染，从而提高初始加载时间。</li></ul></li><li><a href="https://2ality.com/2021/01/import-assertions.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+2ality+(2ality+%E2%80%93+JavaScript+and+more)">ECMAScript proposal: Import assertions</a><ul><li>ECMAScript 提案：Import assertions，在 JS 中 import 文件时断言它的类型。</li></ul></li><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/wiki/coding_guidelines.html">TypeScript 代码风格</a>：可以参考一下。</li><li><a href="https://web.dev/how-to-use-local-https/">How to use HTTPS for local development</a>：使用 <a href="https://github.com/FiloSottile/mkcert">mkcert</a> 工具来让本地网站支持 HTTPS。</li><li><a href="https://juejin.cn/post/6936448887360077831">no-stream 似乎比 js 原生数组方法快</a>：没有黑魔法，仅仅是因为它只遍历一遍数组。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WakeLock">WakeLock</a>：一个实验性的 WEB API，用于使设备保持唤醒状态</li><li><a href="https://adamschwartz.co/magic-of-css/">Magic of CSS</a>：一些 CSS 知识</li><li><a href="https://blog.techbridge.cc/2021/03/28/how-source-map-works/">Source map 运行原理</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://github.com/google/gts">google/gts</a>：Google 的 TypeScript 代码风格，用于格式化和 lint。</li><li><a href="https://www.tabnine.com/">tabnine</a>：使用 AI 更快的完成代码，支持各大 IDE 扩展（PS：在我电脑上内存占用有时候会飙升）。</li><li><a href="https://estimator.dev/">EStimator</a>：通过提供现代 JavaScript 语法来计算网站的大小和性能改进。</li><li><a href="https://github.com/GitSquared/edex-ui">eDEX-UI</a>：跨平台终端工具，炫酷就完了。</li><li><a href="https://jspm.org/docs/cdn">JSPM</a>：原生 ES 模块 CDN。</li><li><a href="https://github.com/qeeqbox/social-analyzer">Social Analyzer</a>：一个通过 API/CLI/Web App 在 350+ 个网站分析、找寻特定用户资料的工具。它提供了不同的字符串分析和检测模块，可自由在“调查”过程中组合使用。</li><li><a href="https://github.com/swc-project/swc">swc</a>：一个用 rust 开发的 typescript 编译器</li><li><a href="https://danger.systems/js/">danger-js</a>：一个审查危险代码的 CI 工具</li><li><a href="https://clinicjs.org/">Clinic.js</a>：一个帮助诊断和检查 Node.js 性能问题的工具</li><li><a href="https://qwerty-learner.vercel.app/">Qwerty Learner</a>：为键盘工作者设计的单词记忆与英语肌肉记忆锻炼软件</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二月总结</title>
      <link href="/post/2021-03-04-2020-feb-summary.html"/>
      <url>/post/2021-03-04-2020-feb-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><ul><li><a href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">从思辨中学历史</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>因为上家公司经营不佳，所以被通知年后不用复工了，于是我开始了找工作的日子。说实话我挺喜欢小城市的生活节奏的，不太愿意回到广州这种一线城市。一线城市的人总是匆匆忙忙的，小城市虽然人少，但更有人情味，而在一线城市，哪怕挤地铁时别人就贴在自己身边，但其实出了地铁后，你可能就会忘记这个人，并无多少交集，甚至连他长什么样都不知道，所以我更喜欢小城市。但可惜我所在的小城市这类公司太少，薪资待遇也跟不上，无奈也只能回广州了。</p><p>经过了一个星期的面试，总算收到一个心仪的 offer，前天刚入职，就目前情况来看还是很不错的。有了之前的教训，这次我在公司附近的地方租房，免去上班挤地铁的痛苦，这极大提高了幸福感。</p><p>由于搬家东西较多，只能让父亲开车送我下来，心里有点不好受，短短几个月，行李搬来搬去的，还要他老人家陪自己奔波，暗暗下定决心，以后绝对不要频繁跳槽了，就先稳定下来吧。</p><h2 id="博客迁移到-Jekyll"><a href="#博客迁移到-Jekyll" class="headerlink" title="博客迁移到 Jekyll"></a>博客迁移到 Jekyll</h2><p>我之前的博客使用 hexo 搭建的，基于 <a href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题做了一些改造，至今也三年多了，我一直都挺喜欢这个主题，直到我看到这个  <a href="https://github.com/cotes2020/jekyll-theme-chirpy">Chirpy</a>，我觉得是时候要换换花样了。但由于这个主题是 jekyll 平台的，我要用只能有两个选择：</p><ol><li>将主题适配到 hexo</li><li>将博客迁移到 jekyll</li></ol><p>显然方案一要更有趣，还能多一个 repo，但想到用了这么久 hexo，也想尝试一下 jekyll，所以暂时选择方案二，于是花了个把小时迁移过来。后续如果有换回 hexo 的想法，再实施方案一。</p><p>其实从 hexo 迁移到 jekyll 也是有损失的，比如会导致以前的文章：链接失效、评论丢失。</p><p>虽然上面两个问题都有办法解决，但是一来想到我的博客只是我的自留地，没什么人看，评论就更少了，并且数据也不是真的丢失了，有心的同学通过搜索引擎还是能够找到的，所以索性不管了。</p><p>另外一个就是不破不立嘛，今年更想多写一些技术以外的东西，虽然大部分只不过是我的牢骚罢了。</p><p>最后放一下博客前后主题的对比，也是跟陪伴我三年的 <a href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题讲拜拜。</p><p>之前：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220338.png" alt="之前"><br>现在：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220711.png" alt="之后"></p><h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="https://mp.weixin.qq.com/s/IIilfJrCCUmOLxd70Vv1Lw">不为人知的韩国新浪潮电影，为什么那么重要？</a></li><li><a href="http://einverne.github.io/post/2015/09/korean-film.html">不得不看的韩国电影</a></li><li><a href="https://m.k.sohu.com/d/515933722">如今的春晚，诸神散去</a></li><li><a href="https://www.zuola.com/weblog/2005/09/298.htm">李敖北大演讲全文</a></li><li><a href="http://mjlsh.usc.cuhk.edu.hk/Book.aspx?cid=4&tid=5812">不写三年大饥荒，就对不起历史和老百姓</a></li><li><a href="https://www.bmpi.dev/self/my-financial-planning/">我的家庭理财规划</a></li></ul><h3 id="文章-技术类"><a href="#文章-技术类" class="headerlink" title="文章(技术类)"></a>文章(技术类)</h3><ul><li><p><a href="https://developers.google.com/web/updates/2021/02/devtools">What’s New In DevTools (Chrome 90)</a></p><ol><li>New CSS flexbox debugging tools</li><li>New Core Web Vitals overlay</li><li>Issues tab updates</li><li>Format strings as (valid) JavaScript string literals in the Console</li><li>New Trust Tokens pane in the Application panel</li><li>Emulate the CSS color-gamut media feature</li><li>Improved Progressive Web Apps tooling</li><li>New Remote Address Space column in the Network panel</li><li>Performance improvements</li><li>Display allowed/disallowed features in the Frame details view</li><li>New SameParty column in the Cookies pane</li><li>Deprecated non-standard fn.displayName support</li></ol></li><li><p><a href="https://linux.cn/article-13125-1.html?utm_source=rss&utm_medium=rss">用 Podman Compose 管理容器</a></p></li><li><p><a href="https://www.cnblogs.com/zkweb/p/12642710.html">写给程序员的机器学习入门 (一) - 从基础说起</a></p></li><li><p><a href="https://zh-style-guide.readthedocs.io/zh_CN/latest/">中文技术文档写作风格指南</a></p><ul><li><a href="https://github.com/tidb-incubator/zh.md">自动检测工具</a></li></ul></li><li><p><a href="https://codeburst.io/5-vue-performance-tips-98e184338439">5 Advanced Tips for Vue Performance</a></p><ol><li>深度 watch 对象变更以便做一些特定操作时，建议将它转为 <code>JSON</code> 后再监听，可以减少大量内存耗费</li><li>不需要改变的数据使用 <code>Object.freeze</code> 冻结对象，让它不再被监听变更</li><li>不要用 Vuex 的 getters 来实现类似于 <code>getItemById</code> 的方法，因为它不会被缓存，可以返回一个 <code>Map</code>，通过索引的方式获取某个 Item</li><li>如果在 getters 或者 computed 返回一个通过拷贝的方式获取每个 Item 的列表时，修改某个 Item 会导致整个列表产生变更，从而导致整个列表组件重新渲染，应该将只需要变更的部分单独提取一个变量</li><li>使用 <code>IntersectionObserver</code> API 优化大量 DOM 的情况，只处理当前可见的 DOM 数据</li></ol></li><li><p><a href="https://web.eecs.utk.edu/~azh/blog/yestercode.html">Why is it so hard to see code from 5 minutes ago?</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API">Visual Viewport API</a></p></li><li><p><a href="https://jakearchibald.com/2021/function-callback-risks/">Don’t use functions as callbacks unless they’re designed for it</a></p></li><li><p><a href="https://drafts.csswg.org/css-color/#funcdef-rgb">CSS Color Module Level 4</a></p><ul><li>rgb 和 hsl 不需要用逗号分开，取而代之的是空格和 /：<a href="https://twitter.com/argyleink/status/1218305696862588928">点这里看看</a></li></ul></li><li><p><a href="https://www.smashingmagazine.com/2021/02/useful-chrome-firefox-devtools-tips-shortcuts/">Useful DevTools Tips And Shortcuts (Chrome, Firefox, Edge)</a></p></li><li><p><a href="https://www.jesuisundev.com/en/20-essential-web-tools-for-developers/">20 essential web tools for developers</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes">&lt;a&gt;: The Anchor element</a></p><ul><li>ping 属性了解一下</li></ul></li><li><p><a href="https://www.bram.us/2021/02/23/the-future-of-css-scroll-linked-animations-part-1/">The Future of CSS: Scroll-Linked Animations with @scroll-timeline (Part 1)</a></p></li><li><p><a href="https://www.industrialempathy.com/posts/image-optimizations/">Maximally optimizing image loading for the web in 2021</a></p></li><li><p><a href="https://github.blog/2021-02-12-avoiding-npm-substitution-attacks/">Avoiding npm substitution attacks</a></p></li></ul><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://impatient-js.apachecn.org/#/">写给不耐烦程序员的 JavaScript（其实就是下一本 2019 年的译版）</a></li><li><a href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a></li><li><a href="https://exploringjs.com/deep-js/">Deep JavaScript: Theory and techniques</a></li><li><a href="https://exploringjs.com/tackling-ts/">Tackling TypeScript: Upgrading from JavaScript</a></li><li><a href="https://debuggingcss.com/">Debugging CSS</a></li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://serverless.css-tricks.com/resources/">Resources - The Power of Serverless</a>：大量 serverless 相关的资源，来涨涨见识也好呀</li><li><a href="https://linuxcommandlibrary.com/basic/oneliners.html?ref=tiny-helpers">Linux Command Library</a>：大量一行的 shell 命令示例</li><li><a href="https://drafts.csswg.org/">CSS Working Group Editor Drafts</a>：CSS 提案列表</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://github.com/barhatsor/coco">coco</a>：使用纯 CSS3 建立 3d 组件</li><li><a href="https://github.com/chriswalz/bit">Bit</a>：现代化 Git CLI，在终端上交互式地使用 Git 命令</li><li><a href="https://atool.vip/appicon/">批量生成多尺寸 APP Icon</a></li></ul><h3 id="技术（语言、类库等）"><a href="#技术（语言、类库等）" class="headerlink" title="技术（语言、类库等）"></a>技术（语言、类库等）</h3><ul><li><a href="https://troisjs.github.io/">TroisJS</a>：ThreeJS + VueJS 3 + ViteJS</li><li><a href="https://github.com/pmndrs/jotai">Jōtai</a>：一个 React 原始，灵活的状态管理器</li><li><a href="https://motion.vueuse.org/">@vueuse/motion</a>：一个 Vue 的可组合 API 动画库</li><li><a href="https://github.com/didi/mpx">Mpx</a>：一款具有优秀开发体验和深度性能优化的增强型小程序开发框架</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从思辨中学历史</title>
      <link href="//posts/cong-si-bina-xue-xi-li-shi.html"/>
      <url>//posts/cong-si-bina-xue-xi-li-shi.html</url>
      
        <content type="html"><![CDATA[<p>首先介绍一下吕世浩这个人：他是国立台湾大学历史博士、北京大学考古学及博物馆学博士，曾于台湾大学历史学系任教。我前段时间学习了他的公开课：《中国古代历史与人物 —— 秦始皇》以及《史记二》，感兴趣的同学可以在互联网上免费进行观看。</p><p>他讲得非常好，「思辨」二字，就是他开这个课程的主要目的，学历史就是要锻炼你的思辨能力。何谓思辨？思辨是指思考辨别，哲学上指运用逻辑推导进行理论上的思考。既然是思辨，自然少不了问问题，没错，吕世浩老师在上课时会问我们很多问题，要回答这些问题就要思考。</p><p>我并不想无意义地重复吕世浩老师在课程中讲过的内容，但是吕世浩老师问了一些非常好的问题，也提出一些我个人非常赞同的观点，所以我会把他的观点贴在我的文章里，除此之外还有一些我个人的想法。但正如吕世浩老师所说，他的观点不一定是对的，我的更是如此，所以大家做个参考就好了。</p><h2 id="一、学生的目的是什么？"><a href="#一、学生的目的是什么？" class="headerlink" title="一、学生的目的是什么？"></a>一、学生的目的是什么？</h2><p>我们从小学到大学，花了十几年时间来上学，有没有问过自己这样一个问题：我们来当学生，我们的目的是什么？</p><p>我从小就有思考这个问题，而且在不同的年龄段，我给出的答案是不一样的，比如：</p><ul><li>在我小学三年级之前，我认为学生之所以要上学，是因为父母要工作没空管孩子，只能把孩子送到学校帮忙看管，这时候学生的目的就是乖乖呆在学校不要给父母添乱。</li><li>后来稍微懂事了，认为学生的目的是学识字、会算数，这样在日常生活中才能不被人欺骗。</li><li>上了初中，我开始厌倦当学生，觉得学校不自由，进入社会就没人可以管我，那时候我觉得当学生跟坐牢没区别，这时候我的目的就是不要当学生。</li><li>后来辍学出了社会，知道没有文化就只能拿最少的钱干最脏最累的活，那时候我觉得学生的目的就是要摆脱这种现状，不要走我们父母的老路。</li><li>现在的我比较认同的一种观点：不同层级的学生有着不同的目的，如果是一个技工院校的学生，那他的目的就是学会一门养家糊口的技能，如果是清华北大的学生，那他的目的就不能仅限于养家糊口，更应该要想着怎样为社会做出自己的贡献，能力越大责任也就越大。</li></ul><p>其实以上观点都没有错，思想是不分对错的，只有好跟坏、粗跟细的区别。</p><p>下面我们来看看吕世浩老师怎么说：</p><p>如果有同学这么多年从来没有思考过这个问题，那你就太不应该了，我们花了十几年去做一件事，怎么能不想想我们为什么要做这件事呢？</p><p>如果你看一本书，看完这本书后，你还是你，书还是书，那就等于没有看过这本书；如果你上一门课，上完这门课后，你却得不到任何好处，那你干嘛还要上这门课呢？这不是浪费自己的生命吗？天下没有比浪费自己生命、浪费别人的生命更大的罪。</p><p>所以，吕世浩老师开宗明义就是要告诉你，学生的目的就是：学——生。</p><p>那这个学——生又是什么意思呢？首先它肯定不是学——死的意思。</p><p>所以，如果一名学生完全不知道自己的目的是什么，那就是浪费自己的生命，那就不是学生，而是学死。</p><p>如果一名学生因为一些感情原因跑去跳楼，那他也不是在学——生。</p><p>西方学问重方法，中国学问重层次，其实这个学——生也是有层次的：</p><ul><li>第一个层次：如何活下去</li><li>第二个层次：如何活得好</li><li>第三个层次：如何活出衷心所愿的人生，在自己活得好的基础上，如何让身边的人活得好，再让更多的人活得好</li></ul><h2 id="二、我们活在一个什么样的时代？"><a href="#二、我们活在一个什么样的时代？" class="headerlink" title="二、我们活在一个什么样的时代？"></a>二、我们活在一个什么样的时代？</h2><p>我们究竟活在一个什么样的时代之中，吕世浩老师提出我们现在活在中国历史上的第三次巨变之中。</p><p>历史的本质就是变，但是变分为「小变」和「巨变」。巨变是指：整个历史的文化、制度、阶段相对来说几乎是推倒重来的。</p><p>他提出目前为止，中国历史上有三次巨变（关于这三次巨变都改变了什么东西可以看课程，这里就不复述了）：</p><ul><li>第一次：从仰韶到龙山</li><li>第二次：从战国到秦汉</li><li>第三次：从清末到今天</li></ul><p>我们何其幸运、又何其不幸地活在第三次巨变之中，活在巨变之中有什么特征呢？特征就是我们活在一个格局未定的时代，也就是我们活在价值观混乱与迷茫之中，我们不知道什么是正确的、什么是不正确的。</p><p>有同学可能会说：”我的价值观一点也不迷茫呀，我活得相当坚定呀！“。这些同学来试着回答一下吕世浩老师问的这个问题：人应不应该节俭？</p><p>节俭是我们中国传统习俗，每个人都应该节俭，但这样真的就是对的吗？试想如果整个社会中所有人都节俭，那么市场需求就会变小，就业需求就会降低，就有可能会导致经济危机，所以国家会想尽办法让我们消费，比如派发消费券、每年弄几个小长假来促进旅游业发展。而资本主义的本质恰恰就是刺激消费，不但让你把这个月的收入花光，还会通过各种办法来让你把下个月、下下个月的收入也提前透支掉，但是恰恰是这种主义的国家都是经济繁荣、国家百业昌盛。</p><p>吕世浩老师的观点讲完了，下面我想再举一个例子，来证明不同时代的人的价值观是不一样的，苏轼相信大家都知道，唐宋八大家之一，但是他当年在参加殿试时，提出了一个在我们今天看来相当惊世骇俗的观点，甚至有颠覆国家主权的嫌疑，以下内容摘抄自苏轼的<a href="https://zh.m.wikisource.org/zh-hans/%E5%BE%A1%E8%A9%A6%E5%88%B6%E7%A7%91%E7%AD%96%EF%BC%88%E5%B9%B6%E5%95%8F%EF%BC%89">《御试制科策》</a>：</p><blockquote><p>“边境已安，而兵不得撤”者，有安之名，而无安之实也。臣欲小言之，则自以为愧；大言之，则世俗以为笑。臣请略言之。古之制北狄者，未始不通西域。今之所以不能通者，是夏人为人障也。朝廷置灵武于度外，几百年矣。议者以为绝域异方，曾不敢近，而况于取之乎！然臣以为事势有不可不取者。不取灵武，则无以通西域。西域不通，则契丹之强，未有艾也。然灵武之所以不可取者，非以数郡之能抗吾中国，吾中国自困而不能举也。其所以自困而不能举者，以不生不息之财，养不耕不战之兵，块然如巨人之病膇，非不枵然大矣，而手足不能以自举。欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。有战国之全利，而无战国之患，则夏人举矣。其便莫如稍徙缘边之民不能战守者于空闲之地，而以其地益募民为屯田。屯田之兵稍益，则向之戍卒可以稍减，使数岁之后，缘边之民，尽为耕战之夫，然后数出兵以苦之，要以使之厌战而不能支，则折而归吾矣。如此，而北狄始有可制之渐，中国始有息肩之所。不然，将济师之不暇，而又何撤乎？</p></blockquote><p>先交代一下背景，殿试是皇帝亲自出题，题目范围很广，涵盖了当时所有的施政方针，而苏轼的《御试制科策》正是他参加殿试的答卷，上文就是苏轼针对边境问题的一个回答，具体内容大家自己看，这里我想重点说的是这句话：「欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。」我理解这句话的大概意思就是：如果要解决这个困境，就是将秦地（今天甘肃一带）这个地方舍弃掉，让它独立出去跟隔壁的匈奴打，我们也不需要帮忙。</p><p>苏轼这观点要放在今天，还不被各大网友口诛笔伐，甚至给个颠覆国家主权罪都是有可能的。但前面说了，出题的人是皇帝，改试卷的自然也是他，提出这么大逆不道观点的苏轼，不但没有招来杀身之祸，还入三等（第一、第二等都是形同虚设的，所以第三等相当于第一了）。</p><p>活在巨变时代之中的不幸我们前面已经说了，那就是价值观混乱与迷茫。那么幸运的是什么呢？幸运的是由于我们活在一个格局未定的时代，所以一切皆有可能，你有没有发现，纵观整个中国历史，能够影响深远的历史人物基本都是出生在巨变时代之中的，比如活在第二次巨变的人物：孔子、秦始皇、汉武帝、王莽。</p><p>而活在第三次巨变之中的我们，说不定就能够找到这个新时代的出路，这也是吕世浩老师开这门课的原因。</p><p>你可能会说，我只不过是一个平凡人物，我怎么有可能跟前面所说的人物相比呢，我何德何能能够改变这个时代呢？</p><p>如果你学了历史，你就知道历史上非常多比你更加不幸的人，但是他们靠着自己的努力，去改变了这个时代。</p><h2 id="三、学历史有什么用？"><a href="#三、学历史有什么用？" class="headerlink" title="三、学历史有什么用？"></a>三、学历史有什么用？</h2><p>我们从初一就开始学历史，那学历史到底有什么用呢？</p><p>说实话，我初一时非常不喜欢历史课，这门课我可以从上课睡到下课，书本到学期期末还是新的。</p><p>那时候我一直搞不懂知道了公元不知多少年前在哪个地方出现了什么猿人跟我们有什么关系，恐怕只是单纯为了应试罢了。</p><p>直到初二讲到近代史，讲鸦片战争、八国联军之类的，才让我稍微有点兴趣，但是只讲一些比较重大的事件，且事件的起因、过程、产出的影响基本都是书上写好的，我们只管背就行了，根本用不着我们来思考。这种教育方式谈不上好坏，但我个人并不喜欢。</p><p>但是出来工作以后，因为机缘巧合的原因，我竟然喜欢上了读历史，当然，并不限于教科书上的那种历史。</p><p>起因我是读了一本叫做《明朝那些事儿》的小说，相信这本书很多人都听说过，但我第一次读到这本书的时候，我惊讶地发现，原来历史还能这么有趣？原来历史并不是只有枯燥乏味、背诵各种历史事件的时间、人物、地点，原来历史中的每个人都是有血有肉的，他们也会面临人生中很重要的抉择，而他们的抉择其实对我们有很大启发。</p><p>至此之后，我一发不可收拾，开始尝试阅读其它历史书，我读的第二本历史书叫做《中国大历史》，作者是黄仁宇，这本书是从宏观角度讲解中国历史各朝代的演变过程，不讲人物史料，侧重于讲各朝代的执政方针，如果你想搞清楚中国历史从宏观角度来看是如何发展的，那么推荐看这本书。</p><p>我在去年的<a href="https://4ark.me/posts/2020-summary.html">《2020 年终总结》</a>也说过，闲人读历史，目的大概有三种，一种是证明了自己博学，一种是追溯上古的八卦，一种是想弄明白为什么是现在这个样子。其实这句话是豆瓣上《中国大历史》的一个书评，我认为概括的非常好。</p><p>这之后我还读了一些诸如《中国近代史》以及一些不太知名的人物史料的书，给我的帮助只是多了解了一些近现代的史料，对我个人的帮助并不大。所以既然要读历史，那怎么能不读《史记》呢？</p><p>但是由于个人文化根基不深，一上来让我直接看古文，还是有点难的，但是白话文又苦于不知道哪一家译得更好，就在这个时候，吕世浩老师的课程让我明白了应该如何读《史记》，当然也包括其它历史书啦。</p><p>然后我来讲讲吕世浩老师对于这个命题的见解，感兴趣的同学可以先看看这个 TED 演讲：<a href="https://www.youtube.com/watch?v=Ap0w3PgSK7g">《学历史的大用》</a>，下面的内容基本出自这里。</p><p>回答这个问题之前，先说说古今对待此历史的区别。</p><p>现代，大部分人对于历史的看法就如我上面所说的一样，就是背诵各种历史事件的时间、人物、地点，除了应试之外别无所用。</p><p>而古代，帝王将相与社会精英无一不学历史，史学教育是他们人生培养中的重要组成部分，他们认为历史重要！重要！再重要！</p><p>为什么古今会有如此大的差别？</p><p>并不是因为历史对现代社会没有用，而是因为古代人学习历史的方法和现代人的方法根本不一样。</p><p>古人学历史的方法是“最关键处，合上书。”</p><p>当古人读史读到一个人在关键时刻要做抉择时，会把书合上，去想如果自己在那样的环境中会如何抉择。想好之后，他再打开书对照史实，看看自己的决定和当事人的是否一样，然后思考当事人为什么做那样的决定，是否成功。用这样的方法学史，其实是在用古人的智慧来磨练自己。</p><p>因此，古代要培养帝王精英，所以用思辨学历史；而现代要培养各行工匠，所以用背诵学历史。目的不同，方法因之而异。</p><p>学历史是古代培养政治精英、帝王将相的重要途径，他们重思辨，用心学习历史，通过史书文献中的用词，体会古人的心境，以达到知微见著。</p><p>讲完了如何学习历史，下面讲讲学历史的作用：</p><ol><li>启发智慧：古人的智慧就像是一个磨刀石，而我们的智慧就是一把刀，所以学习历史的作用就是用古人的人生作为磨刀石来磨砺我们的智慧。</li><li>审时度势：时是指”你所处的环境“，势是指”环境变动的方向“，如果你只是将古人的做法原封不动地搬到今天，那就是跟刻舟求剑一样，只不过是自欺欺人罢了。还有一个就是：变，历史的本质就是变，能够从历史中看出变，那是非常了不起的，但是更高的智慧是从变之中看出不变的东西，什么东西是历经一百个时代，而它始终是不变的呢？那就是人性和良知。</li><li>感动人心：而感动人心就是要唤回人的良知，怎么样才能让人感动呢？那就是真实，不真实的内容是不能感动人心的，比如，我看完《活着》这本书的时候，我非常有感触，为什么呢？因为我知道它是真实发生过的。再比如，《报任少卿书》为何这么打动人心呢？因为司马迁在这封信里将自己心里最深的隐衷道出来了，其能让人不为之动容呢？</li></ol><p>在这里我想来个鸡汤：当你自怨自哀，觉得你没有好父母，人生没有依靠时，想一想有一个人他三岁死了父亲，十几岁死了母亲，家贫如洗，没有接受任何正规教育，完全靠自学成才，成为中国最大的圣人，影响中国文化两千多年，他就是孔子。</p><p>只要你用对方法，历史是无穷智慧的宝库，无穷力量的来源。教育的目的是让人做知识的主人，而不是做知识的奴仆。要做知识的主人，就要启发自己的智慧，愿大家都能从历史中启发智慧，做自己生命的主人，开创理想的人生。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后非常感谢吕世浩老师开这一门公开课，能让我这种连大学都没有上过的人，真真正正感受到应该怎样去学历史，这是何等的幸运。吕世浩老师在课程讲的远远不止上面这些，感兴趣的同学强烈推荐观看学习，相信你的收获不会比我少。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 史记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一月总结</title>
      <link href="//post/c0e3674b.html"/>
      <url>//post/c0e3674b.html</url>
      
        <content type="html"><![CDATA[<p>呼~ 最近实在忙，都没时间写上个月的总结，现在都 2 月 10 号了，还有两天就过年啦，得赶紧把一月份的总结写了。</p><p>总的来说上个月还是过得比较充实的，前半月工作上比较闲，比较多私人时间来做自己的事，下半月赶了个项目，整整两个星期都在日夜赶进度，完全没有私人时间，好在现在已经调整回来。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><h3 id="把你的英语用起来"><a href="#把你的英语用起来" class="headerlink" title="把你的英语用起来"></a>把你的英语用起来</h3><blockquote><p>透析法读原著，原地复活你放下多年的英语！ 本书彻底解救一直想学英语，但从来没有坚持下来的人！</p></blockquote><p>我就是那些一直想学英语，但是从来没有坚持下来的人，我尝试过各种背单词软件、也尝试过直接看英文原著，但是效果都不怎么显著，上个月别人给我推荐了这本《把你的英语用起来》，我看了一下此书的简介，可能这本书确实可以解决我学习英语的困境，于是我读了起来。</p><p>本书根据不同级别的人提供了相应的学习方法，经过书中的自测方法，我目前属于初级，于是按照书中里面所提到的办法，先把基础练好。</p><p>书中建议先按照《赖世雄美语从头学》这套课程学习一段时间，然后再回来跟着本书练习。</p><h3 id="赖世雄美语从头学"><a href="#赖世雄美语从头学" class="headerlink" title="赖世雄美语从头学"></a>赖世雄美语从头学</h3><p>其实，一年前我就买了赖世雄老师的全套书籍，然而一直放在床底吃灰，主要原因是我不太习惯使用纸质书籍学习，虽然附送了光盘，但是使用起来不方便，这次我在 B 站上找了一套别人搬运上去的视频。</p><p>以每天学习三节的速度，学完这套课程大概需要三四个月，但是仅在这短短半个月，我就能够感觉到我的英语能力得到了很大的提升，特别是语感方面，这比单纯背单词的效率来得更高。</p><p>起初我的学习方法是：把对话句子抄下来，没事的时候拿出来读一读，后来我发现这并不是该课程的正确打开方式，因为课程中每一节都会花大量的时间来讲解语法，所以不仅要能读出来里面的例子，更重要的是理解这些句子背后的语法结构，这样才能更好地在现实中应用。</p><p>我把学习笔记放在了语雀：<a href="https://www.yuque.com/4ark/eryhwc/bzbvqk">赖世雄美语从头学</a></p><h2 id="读完的书籍"><a href="#读完的书籍" class="headerlink" title="读完的书籍"></a>读完的书籍</h2><h3 id="清醒思考的艺术"><a href="#清醒思考的艺术" class="headerlink" title="清醒思考的艺术"></a>清醒思考的艺术</h3><p>本书的全名是：清醒思考的艺术 —— 你最好让别人去犯的 52 种思维错误。</p><p>简而言之，书中讲了 52 个思维错误，其中有一些是日常生活中比较常见的，但也有一些是比较不易察觉的，虽然我认为大部分思维错误其实都是很难避免的，但是能够意识到它的存在还是很有用的。</p><p>不过本书只是做一个 check list 的作用，并没有讲得太深入，我之前也读过一遍，此次重读有两个目的：1）我应该要能意识到更多的思维错误；2）为了尝试在 notion 中作读书笔记，而本书的结构是最好不过了。</p><p>读书笔记：<a href="https://www.notion.so/4ark/0e0b80deb60e4854bcdf0f8a4bd5e3a2">《清醒思考的艺术》读书笔记</a></p><h3 id="微思考-——-少有人走的路"><a href="#微思考-——-少有人走的路" class="headerlink" title="微思考 —— 少有人走的路"></a>微思考 —— 少有人走的路</h3><p>本书一口气读完，可能是阅历不够，感觉并没有太大的收获，让我印象比较深刻的是：</p><ul><li>分析自己的性格，思考自己努力从事的职业本身是否真的适合自己的天性。</li><li>千万不要做你不擅长的事情，否则，你会发现自己就像深陷于泥潭之中一般，只能徒劳地挣扎、抱怨。</li></ul><p>我在读到这个观点的时候，是挺认同作者这句话的，如果一个人去从事自己性格不擅长的事，那他必然是痛苦的，至少不比从事自己擅长的职业要来得轻松。所以，分析自己的性格，找到自己最擅长的事，并以此为职业，可能是最好的选择。</p><p>但是后来我又想，现实中不乏有人为了生活去做根本不适合自己性格的事，但经过磨练后，依然能够做得很好。</p><p>至于是顺势而为还是逆势而行，每个人都会有不同的选择，其实都没有错，虽然我是前者，但我更佩服后者。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>上个月看了几部电影，大部分是韩国的，其中让我印象最深刻的是：</p><ol><li>熔炉</li><li>辩护人</li><li>出租车司机</li><li>寄生虫</li><li>海云台</li></ol><p>曾经我和大部分国人一样，对韩国充满厌恶，因为他们对中国历史文化的侵占，以及体育精神上的不道德。但是，这几部电影让我改变了对这个国家的看法，至少我认为在这电影方面，我们远远不如他们。</p><p>引用豆瓣上的两句短评：</p><ol><li>他们有改变国家的电影，我们有改变电影的国家</li><li>我们只有灾难，没有灾难片</li></ol><p>虽然电影并不需要背负起改变国家的责任，但是电影也不应作为政治的宣传物。即便拍不出跟他们并肩的电影，也请不要拍一些无脑剧来拉低我们的智商。</p><p>话说回来，我们国家不是没有人才能够拍出这些电影，我们八十年代也有过类似的电影：《光荣的愤怒》、《见习律师》、《村戏》等，只是后来都被禁了而已。</p><p>再引用一句微博上某不知名人士的话：提倡文化自信，更重要的是文化，而不是自信。</p><h2 id="史记-——-报任少卿书"><a href="#史记-——-报任少卿书" class="headerlink" title="史记 —— 报任少卿书"></a>史记 —— 报任少卿书</h2><p><a href="https://4ark/posts/bao-ren-shao-qing-shu/">报任少卿书</a></p><h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><p>从这个月开始，除了记录一下我的所做的事情之外，再增加一点内容，那就是分享一下我发现的一些好东西，包括但不限于：文章、网站、工具、书籍等。</p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="http://einverne.github.io/post/2015/09/korean-film-brotherhood.html">残忍的战争</a></li><li><a href="https://www.zuola.com/weblog/2004/05/8.htm">什么才是真正的执行</a></li><li><a href="https://blog.csdn.net/pongba/article/details/3549560">如何清晰地思考</a></li><li><a href="https://blog.techbridge.cc/2021/01/23/dom-clobbering/">淺談 DOM Clobbering 的原理及應用</a></li><li><a href="https://mp.weixin.qq.com/s/CYIqWZSrK_OcZ3vL5W5FGA">黄子华的蝴蝶飞不过沧海</a></li><li><a href="https://insights.thoughtworks.cn/technical-blog-experience/">写了十年技术博客，我收获了什么</a></li><li><a href="http://tinylab.org/shell-redirect-stderr-stdout/">Shell 中的 2&gt;&amp;1 命令是什么，这次彻底搞清楚了</a></li><li><a href="https://github.com/rainjay/blog/issues/7">谈谈时间管理</a></li><li><a href="https://github.com/rainjay/blog/issues/6">金字塔原则</a></li><li><a href="https://juejin.cn/post/6923936548027105293">像玩 jQuery 一样玩 AST</a></li><li><a href="https://jub0bs.com/posts/2021-01-29-great-samesite-confusion/">The great SameSite confusion</a></li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://shanyue.tech/">山月的琐碎博客记录</a></li><li><a href="https://ctext.org/zhs">中国哲学书电子化计划</a></li><li><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">OpenResty 最佳实践</a></li><li><a href="https://folkstory.github.io/lingqiu-folk-story/#/?id=%E5%BA%8F">灵丘民间故事歌谣谚语</a></li><li><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://real-world-plantuml.com/?type=activity">Real World PlantUML</a> ：大量 UML 文本绘图模板，可直接复制代码</li><li><a href="https://you-tldr.com/">you-tldr</a> ：根据 youtube 视频字幕快速生成文本</li><li><a href="https://demo.greenroots.info/categories/web-apis/">web-apis</a>：一些 web api 的 demo</li><li><a href="https://multiavatar.com/">Multiavatar</a>：根据你的昵称生成专属头像（但是好丑</li><li><a href="https://moiva.io/">MOIVA</a>：快速调研某个 npm 包</li><li><a href="https://tiny-helpers.dev/">Tiny helpers</a>：开发者在线工具集合</li><li><a href="https://github.com/conwnet/github1s">github1s</a>：只要在 GitHub 仓库域名后面加上<code>1s</code>，即可在 Web 版的 VS Code 浏览代码，终于不需要再 clone 到本地啦（其实 youtube 也有 +1s 的操作</li><li><a href="https://github.com/JonnyBurger/remotion">remotion</a>：使用 React 编程的方式创建视频</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报任少卿书</title>
      <link href="//posts/bao-ren-shao-qing-shu.html"/>
      <url>//posts/bao-ren-shao-qing-shu.html</url>
      
        <content type="html"><![CDATA[<p>在这里先安利一个电台<a href="https://music.163.com/radio/?id=336387122&userid=284852689">《软件那些事儿》</a>，该电台专门讲一些科技史，主播是北大的研究生，白天打羽毛球，晚上开滴滴，偶尔在电台吹吹牛逼，风格幽默，是我在互联网上认识为数不多的有趣的灵魂，他最近开始”不务正业“讲起史记来了，刚好我最近也在读史记，自然是要收听的，他现在在讲《报任少卿书》，感兴趣可以去听听。当然了，我建议最好还是要亲自读原文。</p><p>此信被古人推崇为「千古第一书信」，可以用八个字来总结全文：披肝沥胆，挖心掏肺。</p><p>司马迁在这封信中把自己心中最深的感情和隐衷全部交代出来，告诉他的好朋友任少卿，他在「李陵之祸」中因为替李陵讲话而被判处死刑，但他因为自己人生中最重要的事情还没完成——《史记》这本书，所以他宁可选择自行宫刑，承受世间上最大的耻辱，以此苟活在这个世界上得以继续完成《史记》。现在司马迁的好朋友任少卿因为「巫蛊之祸」被判处死刑，写信给司马迁希望他再次像之前那样推贤进士——救任少卿，司马迁在这封书信中拒绝了他的请求，但他并不是因为贪生怕死，而是《史记》还没做完，他不敢再次冒这个风险。</p><p>这封信篇幅虽短，但可谓字字血泪，怎能不动人呢？</p><p>下面对一些我比较感兴趣的句子做一下解析。</p><blockquote><p>太史公牛马走司马迁再拜言</p></blockquote><p>这是原文的第一句，大概意思就是说：为《太史公》这本书可以做牛做马的司马迁再拜致意。</p><p>这句话是《报任少卿书》中最受争议的一句话，我们知道，太史公是一个称号，并不是一个官职，大部分时候太史公指的就是司马迁自己，少部分时候指的是司马迁的父亲，但在这里，它指的是《史记》这本书，为什么呢？</p><p>因为古人写书大部分都是以人物的名字作为书名，如：《孟子》、《荀子》、《韩非子》等。</p><p>也就是说《史记》的原名叫做《太史公》。</p><p>这个结论不是我瞎扯的，早在钱穆先生的《太史公考释》就有考证。</p><blockquote><p>究天人之际，通古今之变，成一家之言。</p></blockquote><p>这句话有多经典想必不用我多说，大部分熟知《史记》的人，想到的第一句话可能就是这一句。</p><p>但其实这句话只在《报任少卿书》中出现过，但它几乎成为了《史记》的代言词，可见《报任少卿书》的影响力，那这这句话是什么意思呢？</p><ul><li>究天人之际<ul><li>究：研究、缕清</li><li>天人：这里的「天」指的是上天注定，但不是封信迷信的那个老天爷，而是说凡人力所不可及者，谓之「天」</li><li>际：这里的「际」指的是两堵墙相接的边，也就是天和人的交汇。</li><li>所以这句话的大概意思就是说：搞清楚历史上的这些事迹，哪些是靠人的选择、哪些是靠运气，如何运用它们？</li></ul></li><li>通古今之变<ul><li>有一个句话叫做「谈古论今」，谈古是为了论今，如果讲史只是为了知道在古代什么时间什么地点发生了什么事，而对今世的我们没有一点帮助，那谈它有何用？</li><li>要知道，以前的史书，基本都会讲到当代史，《史记》讲汉代更是花了大部分篇幅来讲汉武帝，但从《汉书》以后，中国的史书基本只讲到上一代，不会讲当代史，这就是一个巨大的变化。</li></ul></li><li>成一家之言<ul><li>何谓「家」，这里的家不是家国的「家」，而是「儒家」、「道家」的「家」。</li><li>要成「家」，必然在学术上面要有自己的思想，所以司马迁他说「成一家之言」，这里的家就是：「史家」。</li><li>所以《史记》这本书绝不是一本单纯记载历史的书，它是一本有自己的思想、精神的书，否则他也不会一开始把这本书叫做《太史公》。</li></ul></li></ul><blockquote><p>人固有一死，死有重于泰山，有轻于鸿毛。 用之所趋异也。</p></blockquote><p>这句话相信大家都听过，它正是出自《报任少卿书》，正是出自这个因为判处死刑想继续存活下去，而不得不自行宫刑的司马迁，他是贪生怕死之人吗？并不是，如果他就这么死了，后世只知道他是一个被处以死刑的太史令，可能甚至根本没人知道他，所以他一定要写《史记》，后世的人才知道他到底是一个怎么样的人。</p><p>其实《报任少卿书》还有大量的精彩句子，它们背后隐藏着司马迁心里最深的伤痛、也代表着他为了完成《史记》甘愿忍受天下所有人的耻笑的精神。</p><p>但由于本人才疏学浅，没有能力把整篇讲好，所以有对中国历史或文学感兴趣的同学，强烈建议阅读这封千古第一书信。</p><p>另外，我认为在网络上讲《报任少卿书》最好的是吕世浩，以上大部分内容正是参考他的，感兴趣的同学可以自行到油管搜索。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 史记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Composition API 源码分析 getCurrentInstance() 为何返回 null</title>
      <link href="//post/87ba8d8b.html"/>
      <url>//post/87ba8d8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果同学们已经开始使用 Composition API，那么我们可能都会遇到类似的问题，那就是有时候我们调用 <code>getCurrentInstance()</code> ，它返回的居然是 <code>null</code> ，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase&quot;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;</span></span><br><span class="line"><span class="javascript">    defineComponent,</span></span><br><span class="line"><span class="javascript">    ref,</span></span><br><span class="line"><span class="javascript">    getCurrentInstance</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/composition-api&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">useIncrease</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      count.value++</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 假设我们还要访问当前实例来做些什么</span></span></span><br><span class="line"><span class="javascript">      getCurrentInstance().doSomething <span class="comment">// 但 getCurrentInstance() 返回的是 null</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      count,</span></span><br><span class="line"><span class="javascript">      increase</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123; count, increase &#125; = useIncrease()</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        count,</span></span><br><span class="line"><span class="javascript">        increase</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或许有些同学已经知道，只要我们把该方法的调用摆到外面，那它就能正常工作了：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function useIncrease() &#123;</span><br><span class="line"><span class="addition">+  const vm = getCurrentInstance()</span></span><br><span class="line">  const count = ref(0)</span><br><span class="line"></span><br><span class="line">  function increase() &#123;</span><br><span class="line">    count.value++</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   getCurrentInstance().doSomething</span></span><br><span class="line"><span class="addition">+   vm.doSomething // 这时能够正常访问</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    count,</span><br><span class="line">    increase,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外其实不止 <code>getCurrentInstance()</code> ，还有诸如： <code>useStore</code> 、 <code>useRouter</code> 这些跟 Vue 实例沾边的都会有这个问题，不过本文只讨论 <code>getCurrentInstance()</code>，至于其它这些我不太清楚，所以不敢乱下结论。</p><p>我之前对此一直没怎么深究，满足于知道这样做能使它正常工作就足够了。但是，当我今天看到这篇文章《<a href="https://juejin.cn/post/6917592199140458504">使用 Vue3 的 CompositionAPI 来优化代码量</a>》的时候，里面也提到了一样的问题，只是这位同学认为像 <code>getCurrentInstance()</code> 方法只能在 <code>setup()</code> 中调用，而无法在外部的 <code>hooks</code> 方法中调用时，我意识到这个问题必须得讲清楚，否则会造成很多误解。</p><p>但当我想在评论区提醒一波时，我发现其实我也不清楚背后的缘由，索性就趁此机会，好好了解一下为什么会有这么神奇的事情。毕竟，只知道能工作的解决方法是不够的，还要知道它为什么会这样。</p><p>但 Google 一番，发现没有对这个问题做太多解读（难道这件事不值得疑惑吗？），从 Composition API 官方仓库的 <a href="https://github.com/vuejs/composition-api/issues/455">issue</a> 中，也只是给出了与上面类似的解决方案，但并没有说为什么要这样，对此我就更加疑惑了。</p><p>所以，本文就来分析一下，到底为什么在不同的位置调用 <code>getCurrentInstance()</code> 得到的结果会不一样呢？</p><h2 id="太长不读"><a href="#太长不读" class="headerlink" title="太长不读"></a>太长不读</h2><p>为了不浪费同学们宝贵的时间，我先把重点放到前面，首先是到底什么时候才能访问通过 <code>getCurrentInstance()</code> 当前实例：</p><ol><li>只要在 <code>setup()</code> 内部调用的任何方法，都能获取到当前实例，无论函数调用栈有多深</li><li>但只能在同步代码中才能访问，其它的诸如 <code>setTimeout</code>、 <code>DOM 事件</code> 、 <code>Promise</code> 这类异步代码均无法访问（建议再回头看看上面的例子</li></ol><p>无法访问的原因是：</p><ol><li>Composition API 会在调用组件的 <code>setup()</code> 前，先拿一个变量存放当前实例，以供调用 <code>getCurrentInstance()</code> 时返回，源码：<a href="https://github.com/vuejs/composition-api/blob/master/src/mixin.ts#L95">mixin.ts#L95</a> 和 <a href="https://github.com/vuejs/composition-api/blob/master/src/utils/instance.ts#L116">instance.ts#L116</a></li><li>执行完 <code>setup()</code> 以后，会把用于存放当前实例的变量值恢复到以前的模样（也就是 <code>null</code> ），源码：<a href="https://github.com/vuejs/composition-api/blob/master/src/utils/instance.ts#L126">instance.ts#L126</a></li><li>所以，当 Composition API 内部执行到我们组件的 <code>setup()</code> 时，所有的同步代码都能访问到当前实例，但那些异步代码再去访问时，它已经恢复成 <code>null</code> 了。</li></ol><p>好了，就是这么简单，相信同学们下次再遇到这种问题时，就不会疑惑为什么 <code>getCurrentInstance()</code> 会返回 <code>null</code> ，因为我们知道背后的运行逻辑。</p><p>结论说完了，下面开始分享一下我分析这个问题的整个过程，也希望能对同学们有一些启发。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>想知道问题的所在，最直接的方法就是看源码，但是直接 clone 项目下来从头看，显然不及通过打断点来得高效，毕竟我们现在的目的还不是学习它的源码设计，只是想知道它其中一部分的运行逻辑。</p><p>我们用下面的代码来做例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; defineComponent, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/composition-api&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(getCurrentInstance())</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(getCurrentInstance())</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们在两处调用的地方之前都加了一个断点， 先看看它们执行起来有何不同。</p><p>第一次调用的内部是这样的，这时候它能够访问：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image.png"></p><p>而第二次调用的内部是这样的，这时候它已经变成了 <code>null</code> ：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224432.png"></p><p>可以看到 <code>getCurrentInstance()</code> 的内部非常简单，只是将 <code>currentInstance</code> 给返回出来了，而这个变量显然是在外部定义的，那为什么两次调用，它的值就发生了变化呢？</p><p>我们留意到断点进来的文件是：vue-composition-api.esm.js，那我们直接在 <code>node_modules</code> 下打开这个文件，先搜索一下有哪些地方修改了 <code>currentInstance</code> 这个变量，根据上图就能看到是通过 <code>setCurrentInstance()</code> 方法来修改，于是我们搜索一下这个方法的调用：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224450.png"></p><p>可以看到一共有四处（其中一处是定义），但是光靠肉眼看也很难看出来什么，所以还是老方法，在每个调用之前加一个断点（是的，我们可以直接修改 <code>node_modules</code> 下的代码来进行调试），然后我们发现第一次调用是在 <code>activateCurrentInstance</code> ：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224510.png"></p><p>这时候我们仔细看看这个方法的内部，就能看出些端倪：</p><ol><li>上图显示 <code>preVm</code> 是一个 <code>null</code></li><li>而 <code>vm</code> 是一个 Vue 的实例</li><li>执行完 <code>fn(vm)</code> 后，又将 <code>preVm</code> 传入到 <code>setCurrentInstance()</code> 去了</li></ol><p>所以，我们看看这个 <code>fn(vm)</code> 内部是什么，搜索 <code>activateCurrentInstance()</code> 的调用，发现一个很可疑的地方：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224526.png"></p><p>很明显这里就是执行组件 <code>setup()</code> 函数的地方，再结合上图来看，我们得出结论：</p><ol><li>在执行组件 <code>setup()</code> 函数前，先把当前实例存放起来</li><li>然后执行组件 <code>setup()</code> 函数时， <code>setup()</code> 函数内部自然就能通过 <code>getCurrentInstance()</code> 访问当前实例了</li><li>等执行完 <code>setup()</code> 后，又将 <code>currentInstance</code> 重置回 null 去了（注意是同步执行 <code>setup()</code></li><li>后面 <code>setup()</code> 内部的异步代码再去调用 <code>getCurrentInstance()</code> ，其实已经是 <code>null</code> 了</li></ol><p>如果还不太理解的同学，建议先补一下 JavaScript 的：事件循环、同步、异步、宏任务、微任务这些概念。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个分析过程就结束了，你可能也会觉得很简单，我觉得你上你也行，所以不要觉得这些底层库的运行原理很难捉摸，出了问题也先别一味抱怨或者尝试各种 HACK，为何不直接看看它的运行逻辑呢？</p><p>所以，大胆 debug 吧，少年。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 年度总结</title>
      <link href="//posts/2020-summary.html"/>
      <url>//posts/2020-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020 年，是奇幻的一年，我们共抗疫情，见证了太多太多。对于我来说，2020 年也是非常不寻常的一年，在这一年中，既有收获，也有失去，那么就以本文来总结一下 2020 年我做了哪些事情，收获了什么，同时也是给自己一个交代，有习惯则继续保持，不好的习惯则应戒掉。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="关于写文章"><a href="#关于写文章" class="headerlink" title="关于写文章"></a>关于写文章</h3><p>说来惭愧，在今年，我整整大半年没有更新博客，于是八月份的时候我在《<a href="https://4ark.me/posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html">太久没更新博客的原因和反思</a>》中进行反思，主要原因是我变懒了，另外一个原因就是我认为没有东西什么值得写的，后来我坦然了，其实写博客这件事真的不能太功利，我认为我写博客更多是写给自己看，当然也希望能够帮助到他人，但我最终目的是为了给以后的自己看，因为人的想法会随着年龄的增长而改变，我想把我的想法记录下来，放在互联网上。</p><p>于是后面我有了写月总结的习惯，因为一年太长了，我怕等到写年总结的时候，忘了自己之前做了哪些事，所以每隔一个月记录一下是挺有用的。</p><p>今年写在本站的大部分文章都是比较偏个人想法或记录类的，技术性文章不多，但我今年在工作中却是做了不少技术性相关的文章，也有一部分发布到知乎专栏，虽然点赞的人不多，但我并不在意，因为我知道这些都是我工作过程中实际解决的问题，我更喜欢写这类文章，虽然没有这篇《<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么（超详细版）</a>》吸引眼球，但前者给我收获要更大。</p><h3 id="关于抄袭"><a href="#关于抄袭" class="headerlink" title="关于抄袭"></a>关于抄袭</h3><p>林子大了什么鸟都有，在数月前，发生了一件让我不太愉快的事，我偶然间发现了一个人抄袭我的文章，还在各大技术社区以原创的形式发布，这让我非常恼火，关于这件事情的讨论可以看 <a href="https://v2ex.com/t/703344#reply85">这篇 V2EX 的帖子</a>。</p><p>这件事给我最大的感触就是，这种人很多，这不是第一个，也绝对不是最后一个，我作为一个普通人，没有太多精力去维权，我能做的也只是看到就顺手举报一下，所以我希望国内对于知识产权要更加重视，本来中文互联网的优质内容已经逐渐减少，如果再让这种剽窃他人成果的行为泛滥，最终只会寒了大家的心。</p><p>另外这里我要吐槽一下微信公众号平台，它本身的封闭性决定了我永远不会在上面发布内容，并且它的审查机制只会根据本平台现有的内容来做原创判断，也就意味着别人可以任意将一些没有在微信公众号发表为原创的文章标记为自己原创，这过程可能只需要几分钟，而申诉者却要花上大半个小时才能填写好它那个极其不人性化的表单，最后还要整整七个工作日才会<strong>下发</strong>（我很不喜欢这个词）处理结果。</p><h2 id="工作与成长"><a href="#工作与成长" class="headerlink" title="工作与成长"></a>工作与成长</h2><p>去年 11 月份我在《<a href="https://4ark.me/posts/why-i-became-a-programmer">我为什么会成为一名程序员</a>》一文中讲述我进入这行业的初心，以及我当时对现状的一个忧虑，当时我知道我需要一个能够带领我成长的团队，所以在同一个月，我回到广州工作，加入了一个让我感到兴奋的团队，在《<a href="https://4ark.me/posts/review-summary.html">面试总结</a>》中我总结了我与团队内其他成员的差距，面试时我曾信誓旦旦地说半年后我能达到他们的高度，当然后面并没有做到，但在下半年，由于团队内一些核心人员的流失，我开始负责一些比较重要的任务，在这过程中，我完成了从别人带着干活发展到能够独当一面，这其中的成长让我知道，我兑现我曾许下的诺言，虽然花了整整一年的时间。</p><p>但由于我个人的学历原因，以及公司的制度变更，我意识到我可能无法在这家公司转正，这时候刚好我的一个师兄找我一起回去创业，我思考了很久，我想起我当时为什么要回广州，我觉得我现在已经没有当时的顾虑了，我坚信即使不在现在的团队，我也依然能够保持现有的工作习惯和职业素养，再综合一些其他因素，我认为这是我当下的最好选择，所以我离开了广州，关于这件事的想法我也写在《<a href="https://4ark.me/posts/hui-guang-zhou-yi-nian-you-gan.html">回广州一年有感</a>》一文中。</p><p>我回来已经有一个多月，虽然前期有点不太适应，但已经逐渐把心态调整过来，我正在把我之前团队的文化带来这里，同时我也相信这里能够给我带来更多不一样的成长。</p><h2 id="阅读与兴趣"><a href="#阅读与兴趣" class="headerlink" title="阅读与兴趣"></a>阅读与兴趣</h2><p>如果说我今年最大的两个兴趣，那就是：阅读 RSS 和 历史了。当然今年我也看了一些书。</p><h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>现在还用 RSS 阅读的人估计不多了，现在是公众号、各大平台的推荐机制的天下，RSS 这种古老的东西已经渐渐没落。</p><p>那我又是怎么与 RSS 结缘的呢？是因为我想要一个统一汇总阅读我感兴趣的内容、并且不算推荐算法所影响的阅读平台，这时候 RSS 就重新走到我面前，试用一段时间后发现，这就是我想要的。</p><p>在这里要感谢两个开源项目：<a href="https://github.com/DIYgod/RSSHub">RSSHub</a> 和 <a href="https://github.com/HenryQW/Awesome-TTRSS">ttrss</a>，这让 RSS 有了更多玩法，我可以随意订阅一切我感兴趣的内容，这才是我认为的互联网，与微信公众号完全不一样。</p><p>另外对 RSS 感兴趣的同学，如果你是 Mac/iOS，那么强烈推荐使用 Reeder 这款阅读器，我希望所有软件都可以像它一样使用起来如此丝滑。</p><p>我利用 RSS 阅读什么？很多，除了一些常规的 RSS 订阅源，我还折腾了一些其他的：</p><ul><li>看书<ul><li>epub 转 html，每天推送一章</li></ul></li><li>看历史文章<ul><li>将某个博客网的所有历史文章标题和链接爬下来，每天推送几篇</li></ul></li><li>看图<ul><li>诸如 100photos 这样的图册，每天看一张图片背后的故事</li></ul></li></ul><p>RSS 在我看来本身就一个利用碎片时间阅读，如果要真正构建知识体系，还是认认真真地看书吧。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>今年另一个重大改变就是对历史感兴趣了，起初是因为看了《明朝那些事儿》这本书，后来一发不可收拾，然后阅读了《中国大历史》、《中国近代史》。闲人读历史，目的大概有三种，一种是证明了自己博学，一种是追溯上古的八卦，一种是想弄明白为什么是现在这个样子，起初我是第二种，后来我发现历史中可以学到很多东西，包括历史是如何发展的，以及古人面对如何处理事情，这都给我很大收获。</p><p>当然了，读历史，怎能不读《史记》呢？所以我最近开始读史记，起初想直接读原文，后来感觉有点吃力，于是找了个白话文与原文对照着看，希望明年能够针对这本书上的一些事迹写下自己的感悟。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>我读书一直是比较佛性的人，能看下去的就接着看，看不下去也不要强迫自己，所以经常会出现，一本书看了前面两章，然后就被搁置，后来开的坑越来越多，真正能读完的也没几本，希望明年我能看更多好书吧。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>提升英语能力是我一直非常想做，但是又一直在逃避的事，我从去年就开始下定决心提升英语，也做过各种各样的尝试，包括背单词、读英文书、看英文视频，不能说没有效果，但我都坚持不下去。</p><p>我也曾想过可能是我做这件事的意愿不够，没有找到真正适合我的方法，但不管怎么说，我还是会继续尝试。</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>一年过去了，虽然在生活上过的比较苦逼，但我认为这一年我还是比较充实的，也坚信明年的生活会过得好一点。</p><p>2021 年，我会继续保持现在的好习惯，我也希望我能在思想方面有更大的提升，建立自己的知识体系和观点，做到不随波逐流。</p><p>关于立 Flag 这件事，其实我已经不想再做了，因为我觉得我不知道明年会有哪些新的兴趣爱好，会有哪些重大改变，所以一切都随缘吧，但我希望我能够认真对待我所做的每一件事，这就足够了。</p><p>最后，祝大家新年快乐！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 上配置 MNMP 环境</title>
      <link href="//post/41f45ee.html"/>
      <url>//post/41f45ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天打算实践一下 Wordpress 主题开发，但由于电脑上没有 PHP 和 MySQL 的环境，于是折腾了一下，结果发现安装配置过程一堆的坑，虽然最终选择了 Docker 环境开发，但毕竟已经踩坑了，就记录一下。</p><p>本文记录如何在 Mac OS 上配置 Ngnix + PHP + MySQL，以及最后如何成功安装 Wordpress。</p><p><a name="UovYc"></a></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><a name="EeiNv"></a></p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a name="8LI7s"></a></p><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p><a name="rc4Yt"></a></p><h4 id="2-开启"><a href="#2-开启" class="headerlink" title="2. 开启"></a>2. 开启</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">brew services start nginx</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">brew services stop nginx</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">brew services restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">sudo cp /usr/<span class="built_in">local</span>/opt/nginx/homebrew.mxcl.nginx.plist /Library/LaunchDaemons/</span><br><span class="line">sudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭开机启动</span></span><br><span class="line">sudo launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist</span><br></pre></td></tr></table></figure><p><a name="HpcvU"></a></p><h4 id="3-访问"><a href="#3-访问" class="headerlink" title="3. 访问"></a>3. 访问</h4><p>nginx 默认监听 8080 端口，可以这样看一下是否能够访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8080</span><br><span class="line"></span><br><span class="line"><span class="comment">## 看到这个返回表示 ok</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a name="lqRdT"></a></p><h4 id="4-配置主机"><a href="#4-配置主机" class="headerlink" title="4. 配置主机"></a>4. 配置主机</h4><p>为了方便管理，我们在 nginx 配置目录下的 <code>servers</code>   新增一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/etc/nginx/servers/www.conf</span><br></pre></td></tr></table></figure><p>并填充以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">  <span class="comment"># 如果需要域名访问的话，注意需要修改 /etc/hosts 文件</span></span><br><span class="line">    <span class="comment"># server_name  4ark.dev;</span></span><br><span class="line">  <span class="comment"># 项目根目录</span></span><br><span class="line">    <span class="attribute">root</span> /Users/4ark/www;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.php index.html;</span><br><span class="line">        <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：最好每个项目都单独一个配置文件。</p><p>从上面的配置可以看到我们将项目放在用户下的 <code>www</code>   下，在这个目录新建一个 html 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/www</span><br><span class="line"></span><br><span class="line">vim ~/www/index.html</span><br></pre></td></tr></table></figure><p>这时候重启一下 nginx 服务，访问刚刚配置的主机，就可以访问到上面这个 html 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew services restart nginx</span><br><span class="line"></span><br><span class="line">curl localhost</span><br></pre></td></tr></table></figure><p><a name="Qdk9Q"></a></p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p><a name="CezDV"></a></p><h4 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1. 安装"></a>1. 安装</h4><p>Mac 已经自带有 PHP，你可以通过以下命令查看本机是否存在 PHP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list | grep php</span><br></pre></td></tr></table></figure><p>如果没有，或者你想安装其他版本的话，那就先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以先搜索以下是否有你想要的版本</span></span><br><span class="line">brew search php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 php 7.3</span></span><br><span class="line">brew search php@7.3</span><br></pre></td></tr></table></figure><p><a name="qlUNa"></a></p><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h4><p>配置 php-fpm 权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/etc/php/7.3/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- user = _www</span></span><br><span class="line"><span class="addition">+ user = 4ark # 你的用户名</span></span><br><span class="line">group = _www</span><br></pre></td></tr></table></figure><p>如果正在运行 php-fpm，那就先关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall php-fpm</span><br></pre></td></tr></table></figure><p>然后启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo php-fpm -D</span><br></pre></td></tr></table></figure><p>这时候如果遇到以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: failed to open configuration file <span class="string">&#x27;/private/etc/php-fpm.conf&#x27;</span>: No such file or directory (2)</span><br><span class="line">ERROR: failed to load configuration file <span class="string">&#x27;/private/etc/php-fpm.conf&#x27;</span></span><br><span class="line">ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>错误信息显示，不能打开配置文件， <code>cd /private/etc</code> ，发现没有  <strong>php-fpm.conf</strong>  文件，但是有  <strong>php-fpm.conf.default</strong>  文件。这个文件是默认配置，我们可以复制一份，改名为  <strong>php-fpm.conf</strong>，然后再根据需要改动配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</span><br><span class="line"></span><br><span class="line">sudo cp /private/etc/php-fpm.d/www.conf.default /private/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure><p>执行   <code>php-fpm</code> ，再次报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: failed to open error_log (/usr/var/<span class="built_in">log</span>/php-fpm.log): No such file or directory (2)</span><br><span class="line">ERROR: failed to post process the configuration</span><br><span class="line">ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>错误信息显示，不能打开错误日志文件。 <code>cd /usr/var/log</code>   发现根本没有这个目录，甚至连  <strong>var</strong>  目录都没有，加上为了避免权限问题，干脆配置到  <strong>/usr/local/var/log</strong>  目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /private/etc/php-fpm.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 error_log 改为 /usr/local/var/log/php-fpm.log</span></span><br><span class="line">error_log = /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/php-fpm.log</span><br></pre></td></tr></table></figure><p>执行   <code>sudo php-fpm</code> ，再次报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: unable to <span class="built_in">bind</span> listening socket <span class="keyword">for</span> address <span class="string">&#x27;127.0.0.1:9000&#x27;</span>: Address already <span class="keyword">in</span> use (48)</span><br><span class="line">ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>说是 9000 端口被占用了，但 <code>lsof -i:9000</code>   又看不见，于是只能换个端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /private/etc/php-fpm.d/www.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改监听端口为 9999</span></span><br><span class="line">listen = 9999</span><br></pre></td></tr></table></figure><p>再执行 <code>sudo php-fpm -D</code>  ，就能够正常启动了。</p><p><a name="Ih0Fu"></a></p><h4 id="3-配置-nginx"><a href="#3-配置-nginx" class="headerlink" title="3. 配置 nginx"></a>3. 配置 nginx</h4><p>这时候我们修改 nginx 的主机配置，使它支持 PHP</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  4ark.dev;</span><br><span class="line">    root /Users/4ark/www;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php index.html;</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    location ~ \.php$ &#123;</span></span><br><span class="line"><span class="addition">+        fastcgi_pass   127.0.0.1:9999;</span></span><br><span class="line"><span class="addition">+        fastcgi_index  index.php;</span></span><br><span class="line"><span class="addition">+        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span></span><br><span class="line"><span class="addition">+        include        fastcgi_params;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启 nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services restart nginx</span><br></pre></td></tr></table></figure><p>这时候在项目根目录新增一个 php 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~/www/index.php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容</span></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span>;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><a name="zJVB5"></a></p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>通常来说 Mac OS 也是自带有 MySQL，你可以通过以下命令查看本机是否存在 MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list --formula | grep mysql</span><br></pre></td></tr></table></figure><p>如果没有安装的话，那就先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure><p>安装完成以后，会发现并没有让我们设置密码，运行以下进入密码设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>设置完密码之后，就可以登录了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment"># 输入密码</span></span><br></pre></td></tr></table></figure><p><a name="HeiO2"></a></p><h3 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h3><p>环境终于配置好了，终于可以安装 Wordpress 啦，然而事情并没有这么简单，当我满心欢喜把 wordpress 下载到项目根目录下，就好像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r ~/download/wordpress ~/www/wordpress</span><br></pre></td></tr></table></figure><p>然后我们创建一个数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******  <span class="comment"># 登录后进入终端</span></span><br><span class="line"></span><br><span class="line">mysql&gt; create DATABASE `wordpress-test`;</span><br></pre></td></tr></table></figure><p>然后我们通过浏览器访问 <code>localhost/wordpress</code>  ，就可以看到一个 Wordpress 的安装界面，输入数据库相关的信息后，本以为可以像往常一样成功进入下一步，结果我看到了这个错误：<strong>WordPress 建立数据库连接时出错</strong>。</p><p>结果再尝试了几次，确保所有表单都已经填写正确，依然无法正常建立数据库连接，意识到事情可能并没有这么简单， 于是我在网上找到了一个解决方案，大概就是说无法使用 root 进行登录，需要新增一个用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on wordpress-test.* to <span class="string">&#x27;wp-test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><p>然后使用这个用户进行登录，然后在我这里却行不通，依然显示同样的错误，于是我开启一下 <code>debug</code>  ，看一下导致是什么问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp wp-config-sample.php wp-config.php</span><br><span class="line"></span><br><span class="line">vim wp-config.php</span><br></pre></td></tr></table></figure><p>做以下改动：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 填写以下数据库信息</span><br><span class="line"></span><br><span class="line">// ** MySQL 设置 - 具体信息来自您正在使用的主机 ** //</span><br><span class="line">/** WordPress数据库的名称 */</span><br><span class="line">define( &#x27;DB_NAME&#x27;, &#x27;database_name_here&#x27; );</span><br><span class="line"></span><br><span class="line">/** MySQL数据库用户名 */</span><br><span class="line">define( &#x27;DB_USER&#x27;, &#x27;username_here&#x27; );</span><br><span class="line"></span><br><span class="line">/** MySQL数据库密码 */</span><br><span class="line">define( &#x27;DB_PASSWORD&#x27;, &#x27;password_here&#x27; );</span><br><span class="line"></span><br><span class="line">/** MySQL主机 */</span><br><span class="line">define( &#x27;DB_HOST&#x27;, &#x27;localhost&#x27; );</span><br><span class="line"></span><br><span class="line">// 开启 DEBUG</span><br><span class="line"></span><br><span class="line"><span class="deletion">- define(&#x27;WP_DEBUG&#x27;, false);</span></span><br><span class="line"><span class="addition">+ define(&#x27;WP_DEBUG&#x27;, true);</span></span><br></pre></td></tr></table></figure><p>再访问一下，可以看到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No such file or directory 建立数据库连接时出错</span><br></pre></td></tr></table></figure><p>其实原因是 PHP 配置中的 <code>mysql.sock</code>   与本机的 MySQL 中的路径不一致，可以通过这样查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/www/phpinfo.php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容</span></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br></pre></td></tr></table></figure><p>然后打开 <code>localhost/phpinfo</code>  ，搜索 <code>default_socket</code>  。</p><p>然后再查看 MySQL 的 <code>socket</code>   路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******  <span class="comment"># 登录后进入终端</span></span><br><span class="line"></span><br><span class="line">mysql&gt; status;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">mysql  Ver 8.0.22 <span class="keyword">for</span> osx10.16 on x86_64 (Homebrew)</span><br><span class="line"></span><br><span class="line">Connection id:114</span><br><span class="line">Current database:</span><br><span class="line">Current user:root@localhost</span><br><span class="line">SSL:Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:less</span><br><span class="line">Using outfile:<span class="string">&#x27;&#x27;</span></span><br><span class="line">Using delimiter:;</span><br><span class="line">Server version:8.0.22 Homebrew</span><br><span class="line">Protocol version:10</span><br><span class="line">Connection:Localhost via UNIX socket</span><br><span class="line">Server characterset:utf8mb4</span><br><span class="line">Db     characterset:utf8mb4</span><br><span class="line">Client characterset:utf8mb4</span><br><span class="line">Conn.  characterset:utf8mb4</span><br><span class="line">UNIX socket:/tmp/mysql.sock</span><br><span class="line">Binary data as:Hexadecimal</span><br><span class="line">Uptime:14 hours 59 min 44 sec</span><br></pre></td></tr></table></figure><p>如果与 PHP 中的 <code>mysql.sock</code>   路径不一致，则需要修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /private/etc/php.ini.default /private/etc/php.ini</span><br><span class="line"></span><br><span class="line">vim /private/etc/php.ini</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改为以下</span></span><br><span class="line"></span><br><span class="line">pdo_mysql.default_socket= /tmp/mysql.sock</span><br><span class="line">mysqli.default_socket = /tmp/mysql.sock</span><br></pre></td></tr></table></figure><p>然后重启一下 <code>php-fpm</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo killall php-fpm</span><br><span class="line">sudo php-fpm -D</span><br></pre></td></tr></table></figure><p>再看看 <code>phpinfo</code>  ，应该就生效了。</p><p>然后再尝试登录一下 Wordpress，又发现了以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: The server requested authentication method unknown to the client [duplicate]</span><br></pre></td></tr></table></figure><p>解决方案如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******  <span class="comment"># 登录后进入终端</span></span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password</span><br><span class="line">BY <span class="string">&#x27;your_root_password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>应该就可以了。</p><p><a name="rgfRu"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://ismdeep.com/posts/2020-04-22-install-nginx-mysql-php-on-macos.html">安装 Nginx + MySQL + PHP 环境（ macOS 篇 ）</a></li><li><a href="https://github.com/musicode/test/issues/5">[开发环境]Mac 配置 php-fpm</a></li><li><a href="https://stackoverflow.com/questions/52364415/php-with-mysql-8-0-error-the-server-requested-authentication-method-unknown-to">PHP with MySQL 8.0+ error: The server requested authentication method unknown to the client [duplicate]</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> MNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十月总结</title>
      <link href="//post/edb9a744.html"/>
      <url>//post/edb9a744.html</url>
      
        <content type="html"><![CDATA[<h2 id="几篇新文章"><a href="#几篇新文章" class="headerlink" title="几篇新文章"></a>几篇新文章</h2><ul><li><a href="https://4ark.me/posts/hsts-problem-solving-experience.html">记一次因 HSTS 导致跨域问题的经历</a></li><li><a href="https://zhuanlan.zhihu.com/p/269036804">浏览器通知推送服务选型</a></li><li><a href="https://4ark.me/posts/hui-guang-zhou-yi-nian-you-gan.html">回广州一年有感</a></li></ul><h2 id="最近在折腾什么"><a href="#最近在折腾什么" class="headerlink" title="最近在折腾什么"></a>最近在折腾什么</h2><h3 id="ish-shell"><a href="#ish-shell" class="headerlink" title="ish shell"></a>ish shell</h3><p>最近 <a href="https://github.com/ish-app/ish">ish</a> 上架 app store，趁着暂时还没收费，赶紧在手机和 iPad 装上体验一波，玩了一下发现好像还真的只能当个玩具…</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20201103220016.jpg"></p><h2 id="最近在看什么书"><a href="#最近在看什么书" class="headerlink" title="最近在看什么书"></a>最近在看什么书</h2><h3 id="史记"><a href="#史记" class="headerlink" title="史记"></a>史记</h3><p>其实今年开始对历史感兴趣，之前也看过几本历史相关的书，例如《中国大历史》、《中国近代史》，还有《明朝那些事儿》（这个是听的），然而如果对中国历史感兴趣，那自然绕不过《史记》，这本巨著的伟大之处，想必无须我多说，最近决定拜读。</p><p>起初，我想看繁体版的原版，那感觉会更有味道，奈何学识有限，最后只能决定先看一遍白话文的版本，以后再来重新读原版。</p><h3 id="苏菲的世界"><a href="#苏菲的世界" class="headerlink" title="苏菲的世界"></a>苏菲的世界</h3><p>这本书有多经典，同样不需要我多说，它可以说是最好的一本哲学入门书，很多人在学生阶段已经读过。</p><p>其实我原本对哲学并不是很感兴趣，但是我的偶像黄子华，他是读哲学的，他的偶像李小龙也是同样读哲学的，那我自然也不得不对哲学产生兴趣。</p><h2 id="谷歌测试之道-amp-重新定义团队"><a href="#谷歌测试之道-amp-重新定义团队" class="headerlink" title="谷歌测试之道 &amp; 重新定义团队"></a>谷歌测试之道 &amp; 重新定义团队</h2><p>这两本书是和公司的小伙伴一起读的，每人轮流读一章，由于这些书都比较贴近我们的日常工作，看看谷歌的团队是如何做项目测试、怎么样工作的，也经常能够从中获得一些灵感。</p><h3 id="一些杂书"><a href="#一些杂书" class="headerlink" title="一些杂书"></a>一些杂书</h3><p>除此之外，我也在看以下的书：</p><ul><li>半小时漫画 xxx 系列</li><li>把时间当做朋友</li><li>我的奋斗（罗永浩）</li></ul><p>其实上面这些书我并不是很正式地看，我是通过它们的 epub 版本转换到 html，然后制作成了 rss 订阅源，每天推送一章，慢慢地就能读完了，当然这种阅读方式仅适用于那些不需要怎样做笔记，看过了就算的书。</p><h2 id="还是不够慎重"><a href="#还是不够慎重" class="headerlink" title="还是不够慎重"></a>还是不够慎重</h2><p>最近做了个不大不小的决定，事后才发现自己其实还有很多东西没有考虑清楚，当时只看到眼前的利益，却忽略了一些更重要的事情，以至于突然醒悟后的心理落差，让我又开始怀疑自己做的这个决定到底是对是错。</p><p>一方面，自己还是太过图样，阅历不够，还需继续修炼，希望能够吃一鳖长一智。</p><p>另一方面，下次再遇到这种需要抉择的情况，哪怕我心里已有答案，我也会先找几个信任的朋友商量，避免再次出现这种当局者迷旁观者清的情况。</p><h2 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a>最后说几句</h2><p>一年又准备到头了，一方面希望这种苦逼的日子早点过去，另一方面又感慨时间真得过得好快，转眼间，又快到 2021 年了，我曾经许下的无数诺言，还不知道何日能够兑现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回广州一年有感</title>
      <link href="//posts/hui-guang-zhou-yi-nian-you-gan.html"/>
      <url>//posts/hui-guang-zhou-yi-nian-you-gan.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去年的这个时候，我写了一篇<a href="https://4ark.me/posts/why-i-became-a-programmer.html">《我为什么会成为一名程序员》</a>，记录了我为什么会进入软件开发这个行业，以及我对当时现状的忧虑、反思我成为程序员的初心是什么。</p><p>那么，一年过去了，我现在是怎么样的呢？我还是曾经那个少年吗？</p><h2 id="我回广州了"><a href="#我回广州了" class="headerlink" title="我回广州了"></a>我回广州了</h2><p>是的，我写了那篇文章后，我决定离开当时的公司，离开那个城市，我想要找一个能让我成长的团队，跟一群能够互相激励共同进步的人一起工作，于是我回到广州，来到现在这家公司，在这篇<a href="https://4ark.me/posts/review-summary.html">《面试总结》</a> 中记录了我面试通过后的一些想法。</p><p>在这一年中，我学到了很多东西，这不仅仅只是技术的进步，更多的是思维、做事的方式，这会影响我的一生。</p><p>比如，我会在开始工作之前，先写设计文档、技术调研文档；在开发过程中，我会记录开发细节、踩过的坑；总之，不要出现一件事情只存在你的大脑中，一定要有文档记录。</p><p>又比如，我会使用 Google 搜索引擎、优先选择查阅英文文档、尽自己能力对开源社区做一些贡献。</p><p>还有很多，这些我每天工作做的事情，已经逐渐养成习惯，慢慢影响着我。</p><p>其实这些都是一个程序员的基本素养，只是，如果我当初没有选择离开那家公司，来到这里的话，可能到今天我依然还是那个不专业的程序员。</p><h2 id="未来作何打算"><a href="#未来作何打算" class="headerlink" title="未来作何打算"></a>未来作何打算</h2><p>由于一些原因，说不定我会离开这里，但，只要有可能，我希望继续留下。</p><p>但我想，即便离开了，我在这里养成的习惯，我会坚持做下去，我也希望我能够影响别人做出改变。</p><p>至于未来会如何，我也不清楚。</p><p>但不管怎样，我希望我始终能看到自己的进步，而不是永远停留在原地。</p><h2 id="最后讲讲关于写博客"><a href="#最后讲讲关于写博客" class="headerlink" title="最后讲讲关于写博客"></a>最后讲讲关于写博客</h2><p>我认为，写博客既是记录现在的自己，也是为了给以后的自己看，毕竟就我这个破 blog 看得最多的人肯定还是自己。</p><p>虽然我不是一个很有文采的人，我也写不出华丽的句子，但我认为要记录自己，哪怕是用最简单朴素的文字，也已经足够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次因 HSTS 导致跨域问题的经历</title>
      <link href="//posts/hsts-problem-solving-experience.html"/>
      <url>//posts/hsts-problem-solving-experience.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://a.com/api&#39;">http://a.com/api&#39;</a> from origin ‘<a href="http://b.com&/#39;">http://b.com&#39;</a> has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: Redirect is not allowed for a preflight request.</p></blockquote><p>生产上多次出现上面这个奇怪的跨域问题，但神奇的是强刷新后或者使用无痕模式打开就正常了。<br />到底是哪里出了问题呢？本文将一探究竟。<br /></p><blockquote><p>本文首发于知乎：<a href="https://zhuanlan.zhihu.com/p/245511588">https://zhuanlan.zhihu.com/p/245511588</a></p></blockquote><p><a name="T7LWX"></a></p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>排查后发现，出现这个报错的原因是：<strong>之前使用过 HTTPS 访问页面，所以也请求了 HTTPS 协议的 API，然后 API 的域名被记录在 <code>HSTS</code> 列表中，之后使用 HTTP 访问页面，而 API 请求却被重定向到 HTTPS，而因为预检请求(OPTIONS)不能被重定向，所以导致出现 CORS 错误。</strong><br /><br><br />关于 CORS 更详细的介绍可以点击查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP 访问控制（CORS）</a><br /><br><br />总的来说原因在于前后端 HTTP 和 HTTPS 混用导致的，正常的情况下如果统一为 HTTP 或者 HTTPS 则不会出现这个问题。<br /><br><br />所以如果要开启 <code>HSTS</code> ，请确保前后端都开启，否则就会出现与本文一样的错误。<br /><br><br />那么前端页面要开启 HSTS 的话，需要做哪些操作呢？需要在 web 服务器添加响应头 ，以 Nginx 为例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com;</span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />如果是其他 web 服务器，可以到参考<a href="https://www.techbrown.com/configure-hsts-apache-nginx-iis-lighttpd-web-servers/">这里</a>。<br /><br><br />这里还要注意：<br /></p><ol><li>即便关掉 HSTS 也需要等到 max-age 过期才会从 HSTS 列表清除，所以除非让用户手动清除，否则这段时间内还是会被重定向到 HTTPS。</li><li>如果加了 includeSubDomains ，该网站的所有子域名都会被重定向到 HTTPS ，那会有什么影响呢？假设生产环境为 <a href="http://a.com/">http://a.com</a>，而测试环境为 <a href="http://test.a.com/">http://test.a.com</a>，当访问 <a href="http://a.com/">http://a.com</a> 后，即便在测试环境没有 HTTPS 的情况下也会被重定向</li></ol><p><br />好了，说完结论，那下面来讲讲我是如何使用 Chrome 自带的网络记录工具定位到此问题的。<br /></p><p><a name="n8wDb"></a></p><h2 id="是缓存的问题？"><a href="#是缓存的问题？" class="headerlink" title="是缓存的问题？"></a>是缓存的问题？</h2><p>既然强刷新或者使用无痕模式是正常的，那么就很有可能是因为缓存导致，对比会出现跨域和正常的请求头，发现两者有很大不同：<br /><br><br />这是正常的 👇<br /></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_1.png">这是出现跨域的 👇<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_2.png"><br />可以看出下面这个会出现跨域的请求少了很多内容，而猜测会不会是因为缺少 CORS 相关的部分请求头，所以导致跨域呢？<br /><br><br /><del>根据关键词「跨域 无痕模式」在搜索引擎找到这篇《</del><a href="https://blog.techbridge.cc/2018/08/18/cors-issue/"><del>原來 CORS 沒有我想像中的簡單</del></a><del>》，其中说到是因为浏览器缓存的问题，使用 <code>crossorigin=&quot;anonymous&quot;</code> 让每次发出的请求带上 origin header， 但是这个属性只适用于 <code>&lt;img&gt;</code> 、 <code>&lt;script&gt;</code> 等，于是我去寻找在 axios 请求库对应的属性</del>，然并卵。<br /><br><br />那么有没有可能问题根本不是出在前端发送请求上呢？<br /></p><p><a name="8lHSO"></a></p><h2 id="使用-Chrome-排查网络问题"><a href="#使用-Chrome-排查网络问题" class="headerlink" title="使用 Chrome 排查网络问题"></a>使用 Chrome 排查网络问题</h2><p>既然这样，那就来看看浏览器发送请求的过程中到底发生了什么，于是我通过 chrome://net-export 记录会发生跨域的页面请求日志：<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_3.png"><br />导出日志文件后，发现了一个很奇怪的点：<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_4.png"><br />在上图可以看到，明明请求 HTTP 协议的 API，但是因为 <code>HSTS</code> ，将请求重定向到了 HTTPS 协议下。<br /><br><br />简单来说一下 <code>HSTS</code> 是什么：</p><blockquote><p>HTTP Strict Transport Security（通常简称为 HSTS）是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源，而不是 HTTP —— <a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security">MDN</a></p></blockquote><p><br />就是说如果浏览器发现该网站开启了 <code>HSTS</code> ，则会自动把所有请求重定向到 HTTPS 下。<br /><br><br />为了验证是不是因为这个原因，在无痕模式下也进行了一次记录，发现该日志下找不到 <code>HSTS</code> 的身影：<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_5.png"><br />随后我又通过 Chrome 的 <code>HSTS</code> 设置页面进一步验证了两者的不同，打开 <a href="">chrome://net-internals/#hsts</a> 查询发送跨域的请求域名：<br /><br><br />出现跨域的浏览器窗口 👇<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_6.png"><br />正常请求的浏览器窗口（无痕模式）👇<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image_7.png"><br /></p><p><a name="CDmgs"></a></p><h2 id="都是-HSTS-惹的祸"><a href="#都是-HSTS-惹的祸" class="headerlink" title="都是 HSTS 惹的祸"></a>都是 HSTS 惹的祸</h2><p>没想到，竟然是因为 <code>HSTS</code> ，那为什么一个会有 <code>HSTS</code> 而另一个却没有呢？这时候我留意到出现跨域的页面使用的是 HTTP 访问，但其实是支持 HTTPS 的，所以我猜想会不会是：<strong>之前使用过 HTTPS 访问页面，所以也请求了 HTTPS 的 API，然后 API 的域名被记录在 <code>HSTS</code> 列表中，之后使用 HTTP 访问页面，而 API 请求却被重定向到 HTTPS，所以导致跨域？</strong><br /><br><br />为了验证上面的猜想，特地开了一个新的无痕模式，按照上面所说的步骤操作，完美复现跨域错误！<br /><br><br /><strong>更重要的是我在原本出现跨域的页面改为 HTTPS 访问，也正常请求了。</strong><br /></p><p><a name="7Nc9R"></a></p><h2 id="为什么会出现这种情况？"><a href="#为什么会出现这种情况？" class="headerlink" title="为什么会出现这种情况？"></a>为什么会出现这种情况？</h2><p>为什么请求 API 会被自动重定向到 HTTPS，而请求页面却不会呢？<br /><br><br />原来 <code>HSTS</code> 是根据响应头有没有 <code>strict-transport-security</code> 字段决定是否加入 <code>HSTS</code> 列表的，<strong>经排查发现前端页面的响应头是没有这个字段的，但 API 响应头却有</strong>。<br /><br><br />页面响应头：<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20201017132900.png"><br><br />API 响应头：<br /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20201017132926.png"><br><a name="3pm3v"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果出现奇怪的网络请求问题，可以尝试使用 Chrome 自带的网络请求分析工具，说不定会有收获。<br /></p><p><a name="MB4GK"></a></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://support.google.com/chrome/a/answer/6271171?hl=zh-Hans">排查 Chrome 网络问题</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP 访问控制（CORS）</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a></li><li><a href="https://juejin.im/post/6866942131777306631">浏览器跨域问题与服务器中的 CORS</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九月总结</title>
      <link href="//post/d33db2d3.html"/>
      <url>//post/d33db2d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="九月总结"><a href="#九月总结" class="headerlink" title="九月总结"></a>九月总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天已经是十月三号了，本来 30 号那天就想着写总结，但是被其它事情耽误（下面说的 ttrss 的事），所以直到今天才有空好好写一下总结。</p><h2 id="公众号文章抄袭申诉"><a href="#公众号文章抄袭申诉" class="headerlink" title="公众号文章抄袭申诉"></a>公众号文章抄袭申诉</h2><p>有一天晚上我像往常一样刷 RSS，结果发现有一篇文章抄袭我一年前写的<a href="https://4ark.me/post/b6c7c0a2.html">《在浏览器输入 URL 回车之后发生了什么（超详细版）》</a>，还在多个平台标注原创，于是我通过他文章末尾的微信号沟通（应该做私域流量的），结果此人态度恶劣，最后通过微信公众号平台，最后是官方把这篇侵权的文章删掉结束这件事情。<br>我还在 V2EX 发了个<a href="https://v2ex.com/t/703344">帖子</a>，对于这件事我想说的几个点：</p><ol><li>我是在 <a href="https://segmentfault.com/">segmentfault</a> 看到的这篇文章，结果这个平台上的举报选项没有侵权的选项。</li><li>由于我之前没有在微信公众号发过这片文章，所以在申诉起来很麻烦，而且用户体验贼差，就说最不能忍受的两点：<ol><li>需要上传身份证正反面，但居然只能上传一张图片（还得自己拼在一起上传</li><li>上传资料只能是图片，且备注只能写 150 个字</li></ol></li><li>微信公众号说七个工作日内<strong>下发</strong>申诉结果，结果还真的是等了足足七天</li><li>这种抄袭或洗稿的行为太多了，根本无法阻止，个人原创者也没有精力天天查被谁抄袭，至于其他外部因素， V2EX 上的那个帖子已经很多人发表自己的看法了，这就不重复引述了。</li><li>最后，我希望中文互联网环境的内容越来越好</li></ol><h2 id="新增一些-RSS-订阅源"><a href="#新增一些-RSS-订阅源" class="headerlink" title="新增一些 RSS 订阅源"></a>新增一些 RSS 订阅源</h2><p>由于越来越觉得现在的中文互联网产出的内容不太行，于是我用 <a href="https://docs.rsshub.app/">RSSHub</a> 制作了几个 RSS 源，爬了一下一些比较知名的中文博客文章，每天 5 篇这样子，翻翻以前的内容，目前已经做了的博客：</p><ol><li>阮一峰</li><li>酷壳</li><li>梁文道</li><li>绿帽子大学</li><li>Tsung’s Blog</li><li>泰晓资讯</li></ol><p>除此之外，我还基于维基百科的人物列表做了一些源，增长一下见识：</p><ol><li>中华民国大陆时期人物</li><li>图灵奖获得者</li><li>影响人类历史进程的 100 名人排行榜</li><li>本世纪最重要的人物</li></ol><p>还有一些杂七杂八的，比如某本开源书籍每天一章、reddit 上每天热门帖子汇总等等。<br>每天利用上下班通勤时间（差不多两个小时呢），我可以：</p><ol><li>因为都是一些自己感兴趣的博客或内容，每天看几篇，时间长了慢慢就能看完，总比直接打开博客从头到尾一篇一篇地读要容易</li><li>通过阅读早起的博客文章（比如阮一峰的博客是从 03 年开始的），我可以了解到一些那个时期发生的事或者流行的东西，虽然有一些已经随着时间的流逝慢慢被大家遗忘，但互联网还记得</li></ol><p>最后还是要说，每天刷刷 RSS 权当消磨时间，如果要真正让自己提升、构建思维体系，还是得老老实实看书。</p><h2 id="ttrss-换成-freshrss"><a href="#ttrss-换成-freshrss" class="headerlink" title="ttrss 换成 freshrss"></a>ttrss 换成 freshrss</h2><p>有一天早上发现部署在服务器的 ttrss 里面订阅的同一台机器的 RSS 订阅源失效了，试了各种方案：不用 docker 部署、重启、重装还是没有解决，奇怪的是我根本没有修改任何配置、或升级哪些服务，就这样搞了几天，终于放弃了，换到 freshrss。<br>所幸的 freshrss 没有问题，只是用着没有 ttrss 舒服，不过先用着吧。</p><h2 id="服务器开启-v2ray-占用-cpu-和内存过大"><a href="#服务器开启-v2ray-占用-cpu-和内存过大" class="headerlink" title="服务器开启 v2ray 占用 cpu 和内存过大"></a>服务器开启 v2ray 占用 cpu 和内存过大</h2><p>上面说换到 freshrss 之后（经过重装服务器系统），隔了一天，发现服务器明显变慢了，最后排查出问题是出在 v2ray 上，看到 GitHub 有人提过这个<a href="https://github.com/v2ray/v2ray-core/issues/1961">问题</a>，估计是 v2ray 新版本的 bug，最终通过编译安装旧版本(v4.26.0)，发现没有这个问题。</p><h2 id="读完的书"><a href="#读完的书" class="headerlink" title="读完的书"></a>读完的书</h2><p>这个月看完了两本书：</p><ol><li>清醒思考的艺术</li><li>ThoughtWorks：从敏捷开发到技术雷达</li></ol><p>第一本是 leader 推荐我看的，副标题是《你最好让别人去犯的 52 种思维错误》，顾名思义，里面讲了 52 条逻辑谬误，其中有一些我之前就从别的地方看到过，但这本书讲得通俗易懂，读下来还是比较顺畅的。<br>第二本是我们部门每人轮流读一章，读完的，讲敏捷开发，了解别人是如何进行敏捷开发的，结合我们部门团队日常工作，截长补短。</p><h2 id="准备读的书"><a href="#准备读的书" class="headerlink" title="准备读的书"></a>准备读的书</h2><ol><li>《退步集》—— 陈丹青</li><li>《说话的力量》—— 孙路弘</li></ol><h2 id="最近的一些看法"><a href="#最近的一些看法" class="headerlink" title="最近的一些看法"></a>最近的一些看法</h2><p>这两天发生了挺多事，其中最让人津津乐道的自然就是特朗普感染新冠这件事了，起初我得知这件事，感到非常震惊之余，也好奇国内会有什么反应，果不其然，第二天微博就炸了，让我感到最不可思议的是，居然有这么多人庆祝一个人感染病毒，这是一种什么样的心态？<br>这让我想起多年前，日本地震时，我们的反应，好像也是差不多的，也就是说，这么多年过去了，我们还是没有变。<br>对于这件事，有一种声音我是比较赞同的：如果你家着火了（不是故意的），自己是摆脱险境了，但烧到别人家去，你非但没有同情别人，但嘲笑别人无法自救，甚至幸灾乐祸，这到底是一种什么样的心态呢？<br>退一万步来讲，即便这火真不是自家引起的，作为一个自诩有大国担当的国家人民，这也不是一个正常的举动吧？<br>当然这种声音，少之又少，说出来还会被大家喷。<br>这种民族主义是好是坏，我不知道，但是我想说，如果一个社会，不管你做的这件事情本身是否可耻，只要你的初衷是爱国，就能得到理解；或者反过来，不管你之前做过什么令人骄傲的事，只要你表现出不爱国的举动（可能还是误解，因为现在大家批判别人爱不爱国的标准都太过于简单了），就全盘否认这个人的话，这个民族不是有病吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级 IOS 14 的一些坑</title>
      <link href="//post/7b1778ee.html"/>
      <url>//post/7b1778ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IOS 14 正式版已经发布差不多一个星期了，也看到社区不少人开始讨论新特性，我当然也要跟上脚步，于是也开始把我的 iPhone 和 iPad 更新了，但这过程中却是踩了不少的坑，先记录下来，让后来者少花一些时间。</p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>我最终成功更新的过程是：</p><ol><li>在 Windows 下载最新版本的 iTunes</li><li>在 <a href="https://www.iplaysoft.com/item/ios-ipsw-download">异次元</a> 下载 IOS 14 固件</li><li>打开 <code>Service.msc</code> ，将 <code>Remote Desktop Services</code> 设置为启用和自动</li><li>Windows 连接手机热点，不要连接宽带网络</li><li>在 iTunes 连接手机，按住 Shift 点击更新，选择固件，等待更新</li></ol><p>PS：先备份好手机数据，以防万一！</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>收到推送的当天晚上睡觉前我就在手机和平板上都点了更新，然而等我早上起床打算愉快地体验新系统时，却发现没有更新，进入更新界面才发现下载了不到一半，显示「正在预估剩余时间」，第二天晚上再试了一下，结果还是一样。</p><p>既然在手机上更新不了，那就在电脑更新，于是连接到 Mac，点击更新，到最后一步出现「iPad “4Ark 的 iPad” 的软件下载时被损坏，断开后再次连接…」，换了 Windows 也是一样的问题。</p><p>于是我自己在网上找 IOS 14 的固件，最初我打算在官方，想着系统固件还是官方的比较安全，结果发现最新版本还是停留在 IOS 13.7，于是在一个相对比较靠谱的 <a href="https://www.iplaysoft.com/item/ios-ipsw-download">异次元</a> 里把 IOS 和 iPadOs 固件下载回来。</p><p>因为我是在 Windows 下载的，所以也就在 Windows 最新版的 iTunes 上面更新，连接上手机，按住 Shift 点击更新，选择固件，结果出现「未能更新 iPhone，发生未知错误 53」，在 <a href="https://discussionschinese.apple.com/thread/251504194">这里</a> 找到了解决方案，主要是电脑上的网络不要连接宽带，而是连接移动网络的热点。</p><p>结果在更新过程中，一直停留在「正在准备 iPhone 以进行软件更新」十几分钟，根据以往的折腾经验，准备工作超过十分钟基本就是有问题的了，于是果然在 <a href="https://hcwang.pixnet.net/blog/post/40515550">这里</a> 找到了解决方案，主要就是：打开 <code>Service.msc</code> ，将 <code>Remote Desktop Services</code> 设置为启用和自动，重启 iTunes，重新连接手机，这时候终于可以更新了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>前两天还看到社区里的人都是手机上直接升级的，一睡醒就好了，怎么到我这里就一大堆问题 😩</p><p>但不管怎么说，这些问题我肯定不是第一个，更不可能是最后一个，本文就是为了让大家不要再浪费时间。</p><p>毕竟，周末美好时光，不能白白浪费嘛。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> IOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八月总结</title>
      <link href="//post/f05d518.html"/>
      <url>//post/f05d518.html</url>
      
        <content type="html"><![CDATA[<h2 id="背单词"><a href="#背单词" class="headerlink" title="背单词"></a>背单词</h2><p><img src="https://i.loli.net/2020/08/28/OCf79JkXbP4vQUw.png" alt="image.png"></p><p>月初发现这个软件，发现比我之前使用过的所有背单词软件都好用，基于艾宾浩斯记忆曲线，我的方法是同时打开三个软件：</p><ul><li>List 背单词（上图软件</li><li>欧路词典（用来练发音</li><li>词根词缀字典（用来记词根，同时还有一个“不拘一格背单词”模块，有趣还方便记忆</li></ul><p>每天晚上抽一个小时，效果还是挺不错的，希望能继续坚持下去。</p><h2 id="手机换屏幕"><a href="#手机换屏幕" class="headerlink" title="手机换屏幕"></a>手机换屏幕</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前的小米 8 的屏幕摔坏了，然后换手机后就一直被闲置，最近老母亲提到她的手机电池不太稳定，就心想着自己动手把这台小米的屏幕换了给她用，之前还没有亲自换过屏幕，还是得自己动手折腾一波。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>之前就看过在官方换需要 740 元，觉得这台手机用了这么久了，不值得花这个钱来“续命”，而且对屏幕要求也不高，能用就行。所以在某宝上找了一个华强北的带框屏幕总成，跟着网上的视频教程一步一步换，结果在第一步（拆后壳）卡了近两个小时，差点把我整疯了。</p><p>期间还把开机排线扯断了，然后又在某宝上买了两条排线（备用），就这样等了一天才能继续更换。</p><p>最后更换完开机也是各种问题，比如因为音量键卡住导致开机进入 fastboot 界面，还有因为指纹模块没插好导致无法使用指纹。</p><p>解决上述问题后，还有一个问题无法解决，就是后壳无法完全贴合，据网上说是因为里面没放平，但觉得这个没什么大碍，反正平时也是戴手机壳，只要不重摔就没事。</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>经过三天的折腾，总算是换好了，虽然最后各种问题，但不管怎么说也是尝试过，当然最重要一个原因也是因为这个手机本身并不贵重，就当练练手，否则我还是会选择送去维修店的，毕竟专业的事就应该交给专业的人做。</p><h2 id="RSS-阅读"><a href="#RSS-阅读" class="headerlink" title="RSS 阅读"></a>RSS 阅读</h2><p>今年最大一个改变，就是开始习惯 RSS 阅读，这大大减少我需要在不同平台切换的繁琐，改用 RSS 订阅后，能自由订阅自己感兴趣的内容，不受算法推荐的影响，且对各大平台的文章拥有一致的阅读体验。</p><h3 id="阅读器"><a href="#阅读器" class="headerlink" title="阅读器"></a>阅读器</h3><p>首先是要找一个用得舒服的 RSS 阅读器，我在前几个月都一直在使用 RSS Reader Prime，这个阅读器的优点是：配色好看，阅读体验很好、支持搜索以前阅读过的文章。</p><p>但是后来随着我对 RSS 的需求越来越大，经常需要在不同设备间同步订阅源和阅读历史，虽然该软件自带有 iCloud 同步，但是挺捉急的，经常出现无法同步的问题，于是前段时间趁 Reeder 4 限免，赶紧在三个设备中安装，然后开始我的 RSS 折腾之旅。</p><h3 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h3><p>首先 Reeder 支持使用第三方账号登录，如 Feedly、Inoreader 等，但是我尝试过这两者的服务，总觉得有订阅源限制，赶紧不太舒服，且我现在已经订阅超过 100 个 RSS 源，于是在 <a href="https://diygod.me/ohmyrss/">我有特别的 RSS 使用技巧</a> 这篇文章的安利中，我也自己搭了一个 <a href="https://github.com/HenryQW/docker-ttrss-plugins">Tiny Tiny RSS</a>，从此不再担心有限制。</p><h3 id="定制订阅源"><a href="#定制订阅源" class="headerlink" title="定制订阅源"></a>定制订阅源</h3><p>自建 ttrss 后，就开始折腾如何订阅一些不支持 rss 的网站，那就不得不提 <a href="https://docs.rsshub.app/">RSSHub</a> 这个开源项目了（与前面那篇文章是同一个作者），我自己 fork 了一份部署在自己的 vps 上，根据自己兴趣添加 RSS 订阅源，其实大部分个人博客都是支持 RSS 订阅的，主要是一些比较奇怪的需求，比如：全文输出内容、筛选分类等。</p><p>我还有一个想法，就是把一些英文订阅源的标题翻译成中文，毕竟英文还是比较烂，这样我就能快速寻找感兴趣的文章阅读，而不用一个一个细看，于是我找到一个可用的 google translate 库 <a href="https://www.npmjs.com/package/google-translate-open-api">google-translate-open-api</a>，但在我的套路云上会超时，而在谷歌云则没问题，后来想想这样对我英文提升是无帮助的，所以也就放弃了。</p><p>即便 RSSHub 已经足够强大，但由于部署在国内的 vps 上，即便我设置了代理，也会出现无法访问部分需要科学上网的网站，这时候我会使用 <a href="https://feed43.com/">Feed43</a> 定制这些源，虽然比较土，但也能凑合用。</p><h2 id="闯越自动签到"><a href="#闯越自动签到" class="headerlink" title="闯越自动签到"></a>闯越自动签到</h2><p>我们学校实习期需要每天在一个叫做 「闯越顶岗实习管理系统」 的软件上面写日志签到，个人对于这种繁琐且纯属应付的操作实在不能忍受，不过之前有个朋友做了个自动签到的脚本，我也就直接用他的，懒得重复造轮子。</p><p>最近突然想搞点业余项目，就估摸着在他的基础上做个更完善的自动签到系统，不仅限于学生自动签到，还打算做一个可以让教师快捷点评的操作，据我了解，教师在上面要逐一对学生的日志点评，操作要更加繁琐，。</p><p>而且根据该软件官网上描述，在广东省就有十几家合作技校，如果我做的这个系统能让大家节省这些时间，还是挺有成就感的。</p><p>初步想法是做一个 web 的管理后台 + 小程序用户端 ，后面根据实际用户量再考虑要不要做成 SASS 版。</p><p>目前基本核心签到功能已经实现，剩下的就是做成一个完整的系统，至于技术栈，尝试一下使用 nest.js + react 。</p><h2 id="八佰"><a href="#八佰" class="headerlink" title="八佰"></a>八佰</h2><p><a href="https://4ark.me/posts/ba-bai-review.html">《八佰》读后感</a></p><h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><ol><li>微信公众号 RSS 订阅源</li><li>在语雀构建自己的知识库</li><li>读完《清醒思考的艺术》</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 每月总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《八佰》观后感</title>
      <link href="//posts/ba-bai-review.html"/>
      <url>//posts/ba-bai-review.html</url>
      
        <content type="html"><![CDATA[<p>这几天在很多社区网站都看到关于《八佰》的评论，趁着周末和女朋友去观看，也算了却她一直说今年因为疫情期间没有去看过电影的遗憾。</p><p>其实在之前有了解过这部电影，主要讲述的是 1937 年淞沪会战的最后一役，“八百壮士”奉命坚守上海四行仓库，以少敌多顽强抵抗四天四夜的这段真实历史事件。</p><p>因为总所周知的原因，这部电影从去年一直拖到今年才终于上映，最后不可避免地要做一些妥协，但是就上映后的剧情来说还是可以接受的，而且据网上资料所说，电影原本的龙标是 2019 第 88 号（八十八师），但是后来改为 2019 第 800 号（八百壮士），从这两个定制的龙标，能看出国家电影局确实是给了特别优待的。</p><p>暂时抛开历史，就电影本身的质量而言，我觉得可以给个 4 星，其中有很多场战斗戏，不乏一些血腥的画面，且整体剧情相对紧凑，战斗总是来得很突然，前一秒还是活生生的人，下一秒就倒下，能如此近距离观看战争的残酷，让我对今天能处在和平的年代感到幸运，也让某些整天想着开战的人看看，还是挺有教育意义的。</p><p>因为太关注剧情本身，我从头到尾并没有很关注哪个角色是谁扮演的，以至于后来我甚至没有发现那个特派员居然是黄晓明扮演的，其中也有一些我之前不太感兴趣的演员，但这部戏我认为是超出了他们之前的水平的。</p><p>近几年我国的抗日片，有一个通病，那就是故意丑化日本军人，而一味夸大自己，以此鼓吹民族主义。但这部电影并没有，影片中，一名记者去到日军营地时，看见日军戒备森严、言行律己，且对牺牲军人给予厚葬，说明日军的实力不容小觑，没有故意贬低敌人的拍摄方式很值得大家学习。这也凸显中国军方的英勇抗战和为胜利所付出的代价。</p><p>这部电影不是要激起民族主义，更不是让我们敌视日本这个国家，而是让我们不要忘记那段历史，从而更加珍惜现在和平的时代，那时候我们之所以被打得这么惨，除了跟日本实力悬殊之外，更多的是国人自己不团结，影片中有一幕给我很大冲击，当时日军正在攻楼，而国军自行组成敢死队高喊自己的家乡和名字，身绑手榴弹前仆后继跳楼与敌人同归于尽，当时对岸围观的人说的一句话：“国人皆如此，倭寇何敢？”。</p><p>影片结束时，谢晋元团长按照军队高层命令，率领剩余的“八百壮士”，冲过日军火力封锁的连向英租界的桥。影片到这里就结束了。实际上，后面冲过英租界的“八百壮士”结局更加悲凉，有兴趣可以自行搜寻。这里我想说的希望以后我们能正视我们的历史，更不要扭曲事实，敢于正视自身历史污点的民族，勇于承认错误，才是伟大的民族。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我以为我不会成为那样的煞笔</title>
      <link href="//post/834cbf1e.html"/>
      <url>//post/834cbf1e.html</url>
      
        <content type="html"><![CDATA[<p>多年前在帝吧看过一篇文章，题目大概的意思就是本文的标题，作者貌似叫操笔帝，但不知道是不是我记忆错乱还是怎么的，我居然没有在互联网上找到这篇文章，今晚突然想起了这篇文章， 觉得很适合此刻的心情，就来写一篇差不多的吧。</p><p>当我小时候看到别人家里吵架，我心想我以后一定不会像他们这么煞笔，直到我现在为夹在她们中间而感到心累。</p><p>当我小时候看到别人脾气暴躁，我心想我以后一定不会像他们这么煞笔，直到我现在还经常无法控制自己的脾气。</p><p>当我小时候看到别人自私自利，我心想我以后一定不会像他们这么煞笔，直到我现在做什么都先考虑自己。</p><p>当我小时候看到别人精打细算，我心想我以后一定不会像他们这么煞笔，直到我现在也经常盘算如何才不吃亏。</p><p>当我小时候看到别人有难不帮，我心想我以后一定不会像他们这么煞笔，直到我现在害怕老同学找我借钱。</p><p>当我小时候看到别人冷漠无情，我心想我以后一定不会像他们这么煞笔，直到我现在看到有人晕倒也不敢上去扶。</p><p>当我小时候看到别人没有道德，我心想我以后一定不会像他们这么煞笔，直到我现在坐公交都会先找后面的位置。</p><p>当我小时候看到别人不合群，我心想我以后一定不会像他们这么煞笔，直到我现在喜欢一个人安静的做自己的事。</p><p>我们生活中有形形色色的煞笔，但我们总是在不同的时间里扮演着他们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太久没更新博客的原因和反思</title>
      <link href="//posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html"/>
      <url>//posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html</url>
      
        <content type="html"><![CDATA[<p>距离上一篇文章 <a href="https://4ark.me/post/72566ae3.html">我的 2019 年度总结</a> 发布时间，已经过去大半年了，也就是说 2020 年我把写博客的习惯弄丢了，其实原因很简单，那就是我变懒了。</p><p>我曾给自己找过借口，写技术方面的我总觉得自己写的太粗浅，其实这类文章在目前国内平台已经够多了，没必要重复产出这类文章，但是一篇质量好、有深度的文章，又要花费大量的时间，这让我总是望而却步。</p><p>还有一种生活类文章，我也考虑过要不要把生活上一些感想记录下来，但是后来总是因为各种原因没有这样做，所以对比去年，今天我在写博客方面变懒惰了，但是我知道写博客是好习惯，所以从现在开始我要重新坚持这个习惯。</p><p>我觉得我把写博客这件事还是看得太功利，还没写之前就开始想着会不会有人看，其实博客更多是给以后的自己看。</p><p>自勉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2019年度总结</title>
      <link href="//post/72566ae3.html"/>
      <url>//post/72566ae3.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>转眼一年时间又过去了，在这一年中，完成从一名学生到职场工作者的角色转换，那么就用本文来回顾一下在这年中我都做了些什么，得到哪些收获和成长，反思还有哪些做得不够好的，并在最后制定明年的目标。</p><p>这是我写年度总结的第二年，先来看看我在去年的<a href="https://4ark.me/post/5330f5ce.html">总结</a>中为自己定下了哪些目标：</p><ul><li>对已学知识进行梳理、深挖，写出通俗易懂的文章</li><li>增加英语词汇量</li><li>在广州找一份心仪的工作</li></ul><p>下面从以下几个方面来总结今年我做了什么，得到哪些收获：</p><ul><li>博客文章</li><li>开源项目</li><li>工作</li><li>英语</li></ul><h2 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h2><p>今年一共写了 21 篇文章，分为几类：</p><ul><li>技术点讲解</li><li>项目中遇到的问题，解决方案</li><li>读书笔记</li><li>个人总结</li></ul><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ol><li><p>正向反馈</p><p>通过在社区发表文章，收获一定的读者，不时也有人能指出一些不足之处，自己既能得到成长，也能帮助别人。</p></li><li><p>文章被转载</p><p>其实只要注明出处，我还是很乐意自己的文章被转载，这说明我的文章是有价值的，所以偶尔在自己关注的公众号上看自己的文章，心里还是觉得挺高兴的。</p></li><li><p>破千赞的文章</p><p>这篇<a href="https://zhuanlan.zhihu.com/p/80551769">《在浏览器输入 URL 回车之后发生了什么（超详细版）》</a>在知乎上超过了一千的赞同数，着实让我惊喜了一下，虽然不可否认这类文章比较容易让人点赞（以后再读系列），但不管怎么说还是有成就感的，毕竟写这篇文章也是花费了将近三天时间。</p></li></ol><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>写博客不能太功利，还记得年初写了一篇 <a href="https://juejin.im/post/5c602ba6e51d457fc75f7d09">《分享一些好用的网站》</a>在几天内获得数百赞，于是我又马上写了一篇类似的分享文章，试图复制之前的成功，但是后来我转变了心态，不能一味地为了迎合大众而写一些对自己没帮助的文章，希望每一篇文章都是经过沉淀、有意义的。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><img src="https://i.loli.net/2019/12/28/6KnUbjgMZPkXLwe.png" alt="image.png"></p><p>PS：56 次提交那天是有故事的</p><h3 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h3><ol><li><p>第一个破百 star 的项目</p><p><a href="https://github.com/gd4Ark/star-battle">star-battle</a> 是我第一个开源项目，我在初学前端的时候，写过很多小游戏，但完成这个游戏让我的编码能力得到质的提升，不过还是存在很多不足，希望明年能抽时间更新到 2.0 版本。</p></li><li><p>第一个开源组件</p><p><a href="https://github.com/gd4Ark/vue-fa-form">vue-fa-form</a> 是经过几个项目沉淀下来的，起初只是集成在项目模板内部，后面将它独立出来，经历了从开发组件、编写文档，到发布，不过后来发现已经有更好的类似组件，所以后面也没继续维护，改向其他组件提 PR。</p></li><li><p>认识更多朋友</p><p>今年基本上是面向 GitHub 编程，不愧是全球最大的同性交友网站，通过这个平台我认识到几个朋友，甚至还成为了同事。</p></li></ol><h3 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h3><p>开源并不仅仅是开放源代码，它更是一种开放的精神，所以是不是自己的仓库并不重要，重要的是你有意愿参与其中，对此作出贡献。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>毕业后与几个小伙伴一起创业，主要是接一些外包项目，但过了几个月后感觉得不到提升，当时很迷茫，担心自己就这样止步不前，我开始思考我想要成为怎样的人，后来我找到了答案，写下<a href="https://4ark.me/posts/why-i-became-a-programmer.html">《我为什么会成为一名程序员》</a>，最终决定要换一个环境，并在我的<a href="https://4ark.me/posts/review-summary.html">《面试总结》</a>中反思自己的不足和需要改进的地方。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>这个说来惭愧， 我的英语没怎么提升，主要原因是我没有坚持下去，不过在我换了家公司后有了改变，现在每天都会利用通勤时间背单词，相信慢慢地就会有提升。</p><h2 id="总结-2019"><a href="#总结-2019" class="headerlink" title="总结 2019"></a>总结 2019</h2><p>2019 年，我 19 岁，从校园到职场，开始了自己的职业生涯，对未来有过憧憬、有过迷茫，</p><p>刚出来工作，各方面都不太如意，但现在正慢慢步入正轨，相信一切都会好起来的，</p><p>无论如何，我不会停止前行的脚步。</p><h2 id="展望-2020"><a href="#展望-2020" class="headerlink" title="展望 2020"></a>展望 2020</h2><p>希望明年我能保持现在的习惯，不要停止在舒适区，更具体一点：</p><ul><li>写博客<ul><li>产出三篇以上高质量文章</li><li>掘金 LV5</li></ul></li><li>开源项目<ul><li>做一个好玩的项目</li><li>向大项目提 PR</li></ul></li><li>技术<ul><li>深入：看 Vue 全家桶源码</li><li>新技术：Flutter、K8s</li></ul></li><li>英语<ul><li>听说读写</li></ul></li><li>看书<ul><li>值得看的书</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="//posts/review-summary.html"/>
      <url>//posts/review-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>经过前几天的面试，我从中有了一些感悟，让我觉得面试不仅仅是为了求得一份工作，也是一个自我审核的过程，它能让你意识到自身能力的不足，其中包括了你的：技术能力、沟通能力、表达能力、思考能力等。</p><p>所以我想把我的感悟写下来，从而更清晰地知道自身的不足，并且加以改进。</p><h2 id="投简历"><a href="#投简历" class="headerlink" title="投简历"></a>投简历</h2><p>我起初是在拉勾网上海投简历，但大多都是石沉大海，之后我转向在 BOOS 直聘上投，依然大多都是回复不适合，仅有的几个面试机会，也是因为招聘人员是个技术，并且恰好点开了我的博客，给了我一个机会，我总结了一下，觉得主要是出在以下几个问题：学历、工作经验、技能。</p><p>说白了，在现在这个程序员满街跑的年代，大部分 HR 是不会看大专应届生的简历的，或者说我的简历在他们看来实在是没什么亮点，对于这个我也比较无奈，能做可能就是提升学历了。</p><p>而我能拿到面试机会，是因为技术人员看了我的博客、GitHub，这也让我们更加明白坚持写博客、写开源项目的好处。</p><h2 id="第一家公司"><a href="#第一家公司" class="headerlink" title="第一家公司"></a>第一家公司</h2><p>第一家公司只面了一次，总的来说面试官对我印象不错，但最后他说站在他个人的角度，认为我应该去更好的公司发展，说我很有潜力云云。</p><p>虽然他对我评价比较高，但我知道在那场面试中，我是没发挥好的，因为他问的大部分问题，我之前有写过文章，但是我依然没有很好地回答，总的来说有以下原因：</p><ul><li><p>准备不充分，偶尔会有遗漏</p></li><li><p>对知识点理解还不透彻，不能很直观的表达出来</p></li><li><p>比较紧张，回答问题不够清晰</p></li></ul><p>这让我知道我有必要重新梳理一遍知识点，但不再是仅仅依靠文字，还要口头表达出来。</p><p>最终我没有选择这家公司，因为我更倾向第二家。</p><h2 id="第二家公司"><a href="#第二家公司" class="headerlink" title="第二家公司"></a>第二家公司</h2><p>第二家公司一共面了三次，前两次是现场面，最后一次是电话面，三次面试大部分都不是考察知识点，更多是考察对技术的理解、个人素质、成长空间。</p><p>现场面试时，其实我也在观察他们，我在想如果以后我作为他们同事，我和他们是有一定差距的，这个差距不仅仅是技术，而是包括了：</p><ul><li><p>技术</p><p>包括了对技术的思考和理解、解决问题的方法和流程等。</p></li><li><p>个人素质</p><p>包括了沟通能力、英语能力、思考能力等。</p></li></ul><p>我能感觉到我们的差距，但我认为我和他们是同一类人，我有信心成为他们中的一员，不过我也知道他们的评价估计不怎么好，最后是他们老大决定再给我一次机会，再进行电话面试。</p><p>电话面试中，面试官问了我很多关于成长、学习、心态、兴趣的问题，我知道这是我最后的机会，我尽可能地展示最真实的自己，也没有刻意隐瞒自己的缺点。</p><p>最终我拿到了 offer，说起来也比较巧，我和他们团队刚好有共同的兴趣爱好，这也让我更坚信我们是同一类人，我会努力追上他们的脚步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我拿到了 offer，但是我知道我发挥不怎么好，从这次的面试经历中，发现了很多自身的问题，可能有些问题我之前就注意到了，但当时的环境让我产生了没必要改进的错觉，如今我深刻知道正是因为这些问题，才让我和别人产生差距，为了不让我落后于团队的人，我必须要有所行动。</p><p>主要有以下问题：</p><ul><li><p>思考能力</p><p>我缺少一个永远质疑的心态，这让我在做事情时，往往会停留在解决问题即可，可能会忽略了其他更优的解决方案。</p><p>这会造成我对大多事情的理解往往会停留于表面，而不能从容地整理各种解决方案的优缺点，比较孰优孰劣。</p><p>所以以后在解决问题时，要尝试别的可能性，即便当时条件不允许，事后也要重新复盘，养成习惯。</p></li><li><p>沟通能力</p><p>很多时候我不能清晰地表达自己的意思，这是因为我平时缺少了归纳总结，表达能力也欠缺。</p><p>这需要我前期大量的写作，养成能够条理清晰地描述问题的习惯，最后能够口头表达出来。</p><p>我可以做这些：</p><ul><li>归纳总结一些事情</li><li>把自己理解的知识写出来</li><li>简明扼要地复述一些书的内容</li><li>事后读出来，并且录下来，自己寻找问题</li></ul></li><li><p>英语能力</p><p>英语能力很重要，我之前认为英文只要能认出意思就行，不需要会读，这就发生了我在面试时想念某个单词却念不出的窘境，如果不克服这个问题，这种情况在以后工作中会经常出现。</p><p>所以我制定计划，按照赖世雄老师的课本，从头开始学英文。</p></li><li><p>写字能力</p><p>没错，由于我从小学开始就经常不写作业，导致我现在字丑不说，还经常会出现提笔忘字的情况，所以我也需要抄写文章，重拾我当年抛下的笔。</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>制定计划永远是简单的，我也曾制定过无数的计划，但真能如实执行的寥寥无几，因为之前的计划是没有督促力的，但这次我必须要执行，因为我不允许我落后于他们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些好用的网站（二）</title>
      <link href="//post/839d1638.html"/>
      <url>//post/839d1638.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半年前写了一篇<a href="https://4ark.me/posts/share-site.html">《分享一些好用的网站》</a>记录了我之前常用的一些网站，现在过去半年，收藏夹也多了一些网站，特地记录下来，希望能对你有所帮助。</p><p>由于这些网站都比较杂，我也懒得分类了。</p><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><ol><li>临时邮箱 <a href="https://temp-mail.org/zh">https://temp-mail.org/zh</a></li><li>域名注册商比较 <a href="https://www.nazhumi.com/domain/.com">https://www.nazhumi.com/domain/.com</a></li><li>Tables Generator <a href="http://www.tablesgenerator.com/html_tables#">http://www.tablesgenerator.com/html_tables#</a></li><li>图片放大 <a href="http://waifu2x.udp.jp/index.zh-CN.html">http://waifu2x.udp.jp/index.zh-CN.html</a></li><li>物联网搜索引擎 <a href="https://www.shodan.io/">https://www.shodan.io</a></li><li>AST Explorer <a href="https://astexplorer.net/">https://astexplorer.net</a></li><li>Linux 命令搜索 <a href="http://git.io/linux">http://git.io/linux</a></li><li>Vue render <a href="https://vuejs-tips.github.io/compiler/#inline-template">https://vuejs-tips.github.io/compiler/#inline-template</a></li><li>图片转矢量图 <a href="https://www.vectorizer.io/">https://www.vectorizer.io</a></li><li>在线免费作图 <a href="https://www.processon.com/">https://www.processon.com</a></li><li>拾色器 <a href="https://color.hailpixel.com/">https://color.hailpixel.com</a></li><li>在线幻灯片 <a href="https://slides.com/">https://slides.com</a></li></ol><h2 id="1、TempMail（临时邮箱）"><a href="#1、TempMail（临时邮箱）" class="headerlink" title="1、TempMail（临时邮箱）"></a>1、TempMail（临时邮箱）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105152931.png"></p><p>有时候注册某些论坛必须提供邮箱，但你又不想使用你常用的邮箱时，临时邮箱应运而生，在注册这些不重要的服务时使用临时邮箱作为替身是个很好的选择。临时邮箱具有匿名性，能有效减少垃圾邮件；同时具有时效性，邮箱在短时间内会自毁。</p><p>建议：</p><ul><li>使用完后手动删除邮件</li></ul><blockquote><p>网站链接：<a href="https://temp-mail.org/zh">https://temp-mail.org/zh</a></p></blockquote><h2 id="2、哪煮米（域名注册商比价）"><a href="#2、哪煮米（域名注册商比价）" class="headerlink" title="2、哪煮米（域名注册商比价）"></a>2、哪煮米（域名注册商比价）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105153609.png"></p><p>当你想购买一个域名而不知道选哪个注册商时，这个网站可以帮助你对一些价格进行评分。</p><p>该站目前已经收录了 58 家域名注册商，可注册域名后缀将近有 2000 个，相关信息还在不断收集中。</p><blockquote><p>网站链接：<a href="https://www.nazhumi.com/">https://www.nazhumi.com</a></p></blockquote><h2 id="3、Table-Generator（表格生成）"><a href="#3、Table-Generator（表格生成）" class="headerlink" title="3、Table Generator（表格生成）"></a>3、Table Generator（表格生成）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105154026.png"></p><p>还记得我当时做一个项目，需要展示十几个不规则的报表，当时弄了一下午愣是没画出一个，终于让我发现这个网站，简直就是神器，只要像在 Excel 一样拽拉合并就可以直接生成 HTML 代码，顿时提高了百倍工作效率。</p><p>另外除了 HTML，它还支持：LaTeX、Text、Markdown 等</p><blockquote><p>网站链接：<a href="http://www.tablesgenerator.com/html_tables">http://www.tablesgenerator.com/html_tables</a></p></blockquote><h2 id="4、waifu2x（图片无损放大降噪）"><a href="#4、waifu2x（图片无损放大降噪）" class="headerlink" title="4、waifu2x（图片无损放大降噪）"></a>4、waifu2x（图片无损放大降噪）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105154646.png"></p><p>这个网站厉害了，可以将图片无损放大数倍，似乎是通过卷积神经网络等高科技（咱也不懂），反正好用就是了，如果以后刚好有这个需求，不妨用起来，亲测好用！</p><p>下面放一个对比图</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/%E4%B8%8B%E8%BD%BD.jpeg"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/%E4%B8%8B%E8%BD%BD_waifu2x_art_noise1_scale_tta_1.png"></p><h2 id="5、shodan（物联网搜索引擎）"><a href="#5、shodan（物联网搜索引擎）" class="headerlink" title="5、shodan（物联网搜索引擎）"></a>5、shodan（物联网搜索引擎）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105160718.png"></p><p>首先，Shodan 是一个搜索引擎，但它与 Google 这种搜索网址的搜索引擎不同，Shodan 是用来搜索网络空间中在线设备的，你可以通过 Shodan 搜索指定的设备，或者搜索特定类型的设备。</p><p>好了，感兴趣的同学可以自行查阅资料，这里不好叙述过多。。</p><p>不过请不要做坏事哦。</p><blockquote><p>网站链接：<a href="https://www.shodan.io/">https://www.shodan.io</a></p></blockquote><h2 id="6、AST-Explorer（解析器生成-AST）"><a href="#6、AST-Explorer（解析器生成-AST）" class="headerlink" title="6、AST Explorer（解析器生成 AST）"></a>6、AST Explorer（解析器生成 AST）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105162317.png"></p><p>如果你在学习 AST 抽象语法树，那么这个网站很对你很有帮助，它可以展示将你输入的代码经过 parser 处理为 AST 的过程。</p><blockquote><p>网站链接：<a href="https://astexplorer.net/">https://astexplorer.net</a></p></blockquote><h2 id="7、Linux-命令搜索"><a href="#7、Linux-命令搜索" class="headerlink" title="7、Linux 命令搜索"></a>7、Linux 命令搜索</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105163308.png"></p><p>有时候需要用到 Linux 命令但一时想不出去的时候，可以在上面搜一下，支持命令、描述搜索。</p><p>目前已收集 568 个命令，无聊时也可以上去看看，增加一下印象。</p><blockquote><p>网站链接：<a href="http://git.io/linux">http://git.io/linux</a></p></blockquote><h2 id="8、Vue-render"><a href="#8、Vue-render" class="headerlink" title="8、Vue render"></a>8、Vue render</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105164607.png"></p><p>一个将 Vue HTML 编译为 JavaScript 的工具（有助于 Debug 和理解 Vue），深入学习 Vue 是如何把 HTML 编译成 JavaScript 有助于让你了解原理。</p><p>另外网站已经内置很多案例，可以快速查看一些内置指令在 render 函数中是如何编写的。</p><blockquote><p>网站链接：<a href="https://vuejs-tips.github.io/compiler/#inline-template">https://vuejs-tips.github.io/compiler/#inline-template</a></p></blockquote><h2 id="9、Vectorizer（图片转矢量图）"><a href="#9、Vectorizer（图片转矢量图）" class="headerlink" title="9、Vectorizer（图片转矢量图）"></a>9、Vectorizer（图片转矢量图）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105165152.png"></p><p>该网站可以将位图转成矢量图（SVG），不仅支持 PNG、BMP、JPEG 格式，而且完全免费，亲测效果不错。</p><blockquote><p>网站链接：<a href="https://www.vectorizer.io/">https://www.vectorizer.io</a></p></blockquote><h2 id="10、processOn（免费在线作图）"><a href="#10、processOn（免费在线作图）" class="headerlink" title="10、processOn（免费在线作图）"></a>10、processOn（免费在线作图）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105165623.png"></p><p>ProcessOn 是一个在线协作绘图平台，为用户提供最强大、易用的作图工具！支持在线创作流程图、思维导图、组织结构图、网络拓扑图、BPMN、UML 图、UI 界面原型 …</p><p>之前做技术分享时用过一次，觉得挺不错的，免费版不支持直接导出高清图，解决方法就是先导入 SVG 再用别的工具转成 png。</p><p>但这个网站免费版只能在线存储 9 张图（包括回收站），目前的做法是先导入备份，有需要再导入。</p><p>这里推荐另外一个类似的网站 <a href="https://www.draw.io/">draw.io</a>，不同之处在于：</p><ul><li>英文、可在线存储（利用 Google）、完全免费、不限数量</li></ul><p>所以如果是常用的话，建议还是使用 draw.io</p><blockquote><p>网站链接：<a href="https://processon.com/">https://processon.com</a></p></blockquote><h2 id="11、Colordot（拾色器）"><a href="#11、Colordot（拾色器）" class="headerlink" title="11、Colordot（拾色器）"></a>11、Colordot（拾色器）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105171134.png"></p><p>这个网站的特点就是通过摇动滑鼠轻松找出配色灵感，对于我这种不是很懂配色的人，以后就可以在上面挑几个比较顺眼的啦。</p><blockquote><p>网站链接：<a href="https://color.hailpixel.com/">https://color.hailpixel.com</a></p></blockquote><h2 id="12、Sliders（在线幻灯片）"><a href="#12、Sliders（在线幻灯片）" class="headerlink" title="12、Sliders（在线幻灯片）"></a>12、Sliders（在线幻灯片）</h2><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20191105171436.png"></p><p>可以在浏览器中创建在线幻灯片，轻松做出简洁实用的幻灯片，对于开发者需要制作技术分享文稿时是个不错的选择。</p><p>但 Sliders 的一些高级功能是要收费的，仅提供一些基本的使用，如果愿意折腾不妨使用这个 <a href="https://github.com/hakimel/reveal.js">Reveal.js</a>。</p><blockquote><p>网站链接：<a href="https://slides.com/">https://slides.com</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 与加密那些事儿</title>
      <link href="//post/bebf2aea.html"/>
      <url>//post/bebf2aea.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTTPS 在我们日常中经常能用到，我们经常说 HTTPS 安全，那么你知道它为什么安全吗？有些同学会说：是因为加密啊，那么你知道它是怎么加密的吗？</p><p>如果你对此不是很明白，欢迎阅读本文，希望能让你解开 HTTPS 的迷雾，但如果你是大神级别的人物，那么请轻喷，因为我也不是很懂。。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>在说 HTTPS 之前，我们需要先知道 HTTP，HTTP 是基于 TCP 协议的一个无状态协议，如果你不是很懂欢迎阅读我上一篇文章，<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么</a>，此文讲解了一个 HTTP 请求的过程。</p><p>缺点：</p><ol><li>使用明文进行传输，内容可能被窃听</li><li>不验证通信方的身份，通信方的身份可能是伪装</li><li>无法证明报文的完整性，报文有可能被篡改</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 并不是一个新协议，而是 HTTP 先和 <a href="SSL/TLS">SSL/TLS</a>，再由 SSL/TLS 和 TCP 通信。也就是说 HTTPS 使用了隧道进行通信。</p><p>为什么不直接对 HTTP 报文进行加密，而是多加一层 SSL/TLS 呢？因为 HTTP 报文分为报文首部和报文主体，如果只对发送内容进行加密（也就是报文主体），而未加密的报文首部信息也会导致信息不安全。</p><p>在开始讲之前我们需要介绍一下加密算法。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>加密算法的实现原理是公开的，读者可能觉得这观点很奇怪，很多开发者喜欢设计千奇百怪的算法，窃以为别人并不知道，其实自行设计的算法根本不具备严格的数学模型，很容易被攻破。流行的密码学算法其算法实现是公开的，经过了长时间的考验。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>简单来说就是加密和解密都是通过同一个密钥，比如我要传输的明文是 <code>5201314</code>，我在传输前将明文的所有数字+1，得到：<code>6302425</code>，然后接收方根据相同的密钥将密文进行解密，得到明文。</p><p>一般的对称加密算法是使用 XOR（异或） 这个特点，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5201314</span> <span class="comment">// 明文</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">123456</span> <span class="comment">// 密钥</span></span><br><span class="line"><span class="keyword">var</span> c = a ^ b <span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">var</span> d = c ^ b <span class="comment">// 解密 =&gt; 5201314</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对按位操作符感兴趣可以阅读我之前的文章：<a href="https://4ark.me/post/learn-bitwise-operators.html">深入理解按位操作符</a></p></blockquote><h4 id="一次性加密"><a href="#一次性加密" class="headerlink" title="一次性加密"></a>一次性加密</h4><p>上面这个例子就是一次性加密，在不知道密钥的情况下，理论上是无法破解，因为即便你遍历了所有情况，但由于你不确定破译出来的是不是原文，所以这就是它无法破解的原因。这个理论是香农(C.E.Shannon)于 1949 年通过数学方法加以证明的。</p><h4 id="DES-加密"><a href="#DES-加密" class="headerlink" title="DES 加密"></a>DES 加密</h4><p>DES 是 1977 年美国联邦信息处理标准中采用的一种对称加密算法，但是在 1998 年已经被成功破解，耗时紧紧 22 小时，目前不再推荐使用。</p><p>它是一种把 64 位明文加密成 64 位密文的对称加密算法，也就是一次性只能加密 64 位，如果超过了 64 位，就需要进行分组加密。</p><p>对称加密还有很多种，想要了解更多可以查看这篇文章：<a href="https://halfrost.com/symmetric_encryption/">漫游对称加密算法</a></p><h4 id="对称加密的缺点"><a href="#对称加密的缺点" class="headerlink" title="对称加密的缺点"></a>对称加密的缺点</h4><p>无论对称加密算法再怎么复杂，它们都有一个共同的弱点，就是</p><ul><li>如何传输密钥</li></ul><p>如果我们要和接收方进行通信，我们需要提前协商好一个密钥，那么这个如何才能保证密钥能安全地送达，而不会落到中间人手中？</p><p>自然是将密钥进行加密，但如何依然使用对称加密，那是不是又需要另外一个密钥？所以这就陷入死循环了。</p><p>这时候就要介绍密码学上伟大的发明：RSA（公钥私钥密码算法），也就是非对称加密算法。</p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><blockquote><p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">RSA 算法</a>。</p></blockquote><p>非对称加密有公钥和私钥，也就是私钥加密的密文只有公钥才能解密，公钥加密的密文只有私钥才能解密。</p><p>关于原理部分我认为阮一峰老师的这篇文章<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理</a>已经讲得很通俗易懂了，这里不再赘述。</p><h4 id="非对称加密的缺点"><a href="#非对称加密的缺点" class="headerlink" title="非对称加密的缺点"></a>非对称加密的缺点</h4><p>非对称加密虽然安全，至今都无法被破解，但也不是完全没有缺点的，一个比较显著的缺点就是加密时需要经过大量的计算，消耗计算机资源。</p><h2 id="HTTPS-采用的加密方式"><a href="#HTTPS-采用的加密方式" class="headerlink" title="HTTPS 采用的加密方式"></a>HTTPS 采用的加密方式</h2><p>对称加密特点：</p><ul><li>优点：运算速度快</li><li>缺点：密钥容易被获取</li></ul><p>非对称加密特点：</p><ul><li>优点：更安全</li><li>缺点：运算速度慢</li></ul><p>很明显，如果 HTTPS 采用非对称加密的话，会消耗大量的计算资源，那么有没有一种方式可以解决这个问题呢？有的。</p><p>我们知道对称加密的缺点就是密钥的分发问题，既然这样，我们可以使用非对称加密对密钥进行加密，保证只有通信双方知道密钥后，接着就可以使用对称加密进行通信。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>但依然存在一个很严重的问题就是：<strong>公钥如何分发？</strong></p><p>因为客户端无法确认公钥是来自服务器还是来自中间人，所以需要一个客户端和服务器双方都信赖的第三方机构，配分配公钥，这个机构就叫做 数字证书认证机构（CA，Certificate Authority）。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。</p><p>但依然存在问题：<strong>证书怎么安全传输？ 被篡改了怎么办？</strong></p><p>使用数字签名就好了，简单来说就是将公钥和个人信息用一个 Hash 算法生成一个信息摘要。我们知道 Hash 算法有个极好的特征，只要输入的数据有一点点变化，那生成的信息摘要就会发生巨变，这样就可以防止别人修改原始内容。</p><p>但还有个问题就是，<strong>如何防止别人冒充 CA？</strong></p><p>如果连 CA 都无法信任的话，那么之前的一切都是徒劳的，所以必须打破僵局，我们必须信任 CA。</p><p>CA 是像树一样分级的，在操作系统/浏览器中都会内置一些顶层的 CA 证书，而这些顶层 CA 会为上层的 CA 做信用背书。</p><p>说到底其实我们相信的是操作系统/浏览器，如果中间人连这个都可以伪装，那么我们就没有安全可言了。</p><h2 id="HTTPS-中的-TLS-SSL-协议"><a href="#HTTPS-中的-TLS-SSL-协议" class="headerlink" title="HTTPS 中的 TLS / SSL 协议"></a>HTTPS 中的 TLS / SSL 协议</h2><blockquote><p>能让 HTTPS 带来安全性的是其背后的 TLS 协议。它源于九十年代中期在 Netscape 上开发的称为安全套接字层(SSL)的协议。到 20 世纪 90 年代末，Netscape 将 SSL 移交给了 IETF，IETF 将其重命名为 TLS，并从此成为该协议的管理者。许多人仍将 Web 加密称作 SSL，即使绝大多数服务已切换到仅支持 TLS。</p></blockquote><p>TLS/SSL 协议位于应用层和传输层 TCP 协议之间，注意 TLS/SSL 并不是只有 HTTP 才能使用，而是位于应用层的协议都可以使用，换句话说 TLS/SSL 协议 是用于加密应用层协议并传递给下层的 TCP。</p><p>TLS 粗略的划分又可以分为 2 层：</p><ul><li>靠近应用层的握手协议 TLS Handshaking Protocols</li><li>靠近 TCP 的记录层协议 TLS Record Protocol</li></ul><p>TLS 握手协议还能细分为 5 个子协议：</p><ul><li>change_cipher_spec (在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)</li><li>alert</li><li>handshake</li><li>application_data</li><li>heartbeat (这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议)</li></ul><p>TLS/SSL 可以查看以下流程：</p><p><img src="https://i.loli.net/2019/11/05/ALpa2NBYJfsgi3c.png"></p><h3 id="握手失败"><a href="#握手失败" class="headerlink" title="握手失败"></a>握手失败</h3><p>浏览器访问 HTTPS 网站的时候，在握手阶段可能会存在错误，比如证书的有效期过期、证书是自签名证书、客户端和服务器无法协商出一致的密码套件，遇到类似的情况，浏览器会出现一个错误页面，告知用户存在的问题。</p><p>一般握手失败时，浏览器会直接告诉用户该网站不安全。</p><p>其实 TLS / SSL 协议的原理是很复杂的，如何感兴趣可以看一下《深入浅出 HTTPS》这本书。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>《深入浅出 HTTPS》</li><li><a href="https://halfrost.com/https-begin/">HTTPS 温故知新</a></li><li><a href="https://halfrost.com/symmetric_encryption/">漫游对称加密算法</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么会成为一名程序员</title>
      <link href="//posts/why-i-became-a-programmer.html"/>
      <url>//posts/why-i-became-a-programmer.html</url>
      
        <content type="html"><![CDATA[<p>今天突发奇想，心里冒出一个很奇怪的问题：我为什么会成为一名程序员？</p><p>其实也是在问，我成为程序员的初心是什么？</p><h2 id="接触电脑"><a href="#接触电脑" class="headerlink" title="接触电脑"></a>接触电脑</h2><p>第一次接触电脑应该是在小学四年级被同学带去网吧玩游戏，那时候对电脑的印象就是一台比较大的游戏机，从此以后我就成了一名网瘾少年，终日泡在网吧，但那时对于计算机的认识也只停留在玩游戏上。</p><p>不过这也让我从小对任何所接触的电子产品都感兴趣，到后来学会自己利用网上的教程去刷机、拆机等，总之那时就养成了比较爱折腾的习惯。</p><h2 id="初中辍学、读技校"><a href="#初中辍学、读技校" class="headerlink" title="初中辍学、读技校"></a>初中辍学、读技校</h2><p>初二那年我 14 岁，因为叛逆期的缘故，我辍学了，那时我就出来工作，我做过一些工厂的杂工、服务员等。</p><p>就这样过了两年，因为家人的劝说和自己也觉得需要重回学校学习，所以我还是决定回去读书。</p><p>因为从小对计算机感兴趣，所以选择了这个专业，现在看来，可能这是影响一生的决定。</p><h2 id="接触编程"><a href="#接触编程" class="headerlink" title="接触编程"></a>接触编程</h2><p>进入学校第三个学期，我才真正开始接触编程，那时候我们还没有相关的课程，只能自己学习，我开始接触 HTML、CSS，从此以后，我开始每天不孜不倦地学习，但那时候也没想过自己以后会从事这方面的工作，甚至连“程序员”、“前端开发”这些名称都没听说，但因为兴趣的缘故，我坚持了下来，那段时间没有一个同学和我交流，他们也不懂我做出一个看上去很难看的网页喜悦的心情。</p><h2 id="进入工作室"><a href="#进入工作室" class="headerlink" title="进入工作室"></a>进入工作室</h2><p>在第四个学期，我进入了学校的前端开发工作室，接触到比我厉害的师兄，我才真正明确以后要从事什么工作。</p><p>在不断的学习中，我经历了很多次从觉得自己很厉害、到发现其实自己懂得很少的阶段。</p><p>但我从来没有想过放弃编程，因为它确实改变了我的人生，而编程也能让我感到快乐，那是探索、创造的乐趣。</p><h2 id="工作之后"><a href="#工作之后" class="headerlink" title="工作之后"></a>工作之后</h2><p>之前我认为每个之所以成为程序员的人，都是因为对编程感兴趣，但后来发现也并不完全是，有些人的兴趣并不在此，他们做程序员的目的也不那么纯碎，可能是为了薪资高、为了谋生…</p><p>但我认为大部分程序员最初的目的肯定也是因为感兴趣使然，只是他们后来因为各种原因，忘记了最开始的初心。</p><p>我不想变成他们那样，但怎样才能让自己的初心不变呢？我思来想去，只有跟自己有共同想法的人一起工作，因为只有这样，我们可以一直督促自己前行。</p><h2 id="我的初心"><a href="#我的初心" class="headerlink" title="我的初心"></a>我的初心</h2><p>从我接触编程至今，我对技术始终保持浓烈的兴趣，虽然自知天资愚钝，但从未想过放弃。</p><p>我想即便不从事这个行业，我也会利用业余的时间来学习技术，当然现在更好的情况是，我可以以此当做职业。</p><p>因为当你的兴趣成为你的工作时，这是很幸福的。</p><p>我不要求自己以后成为什么技术大牛、架构师等等，只希望自己可以一直保持这份对技术的追求，这就足够了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写这篇文章的原因，是为了复盘自己为何成为程序员，也是为了告诉未来的自己，不要忘记最开始的初心是什么。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打造自动化前端项目CLI 工具</title>
      <link href="//post/2dfd4a9c.html"/>
      <url>//post/2dfd4a9c.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中，尤其是新开项目的时候，往往需要重新进行各种配置、甚至复制以往的代码，为了解决这种场景，就有了 CLI，想必大家平时都经常使用，比如 Vue 的<code>vue-cli</code>，React 的 <code>create-react-app</code>，这类工具存在的主要目的是：释放双手、加快项目开发进度。</p><h2 id="我的场景"><a href="#我的场景" class="headerlink" title="我的场景"></a>我的场景</h2><p>本文就将介绍我如何根据我们团队内部的繁琐场景编写 CLI，从而加快项目开发速度。</p><p>开发项目中最常见的非后台管理系统莫属了，如果你仔细观察，就会发现大多数的后台管理大同小异。</p><p>就我们团队内部的后台管理系统而言，每次新开项目时，我们都需要进行以下操作：</p><ul><li>搭建项目：拷贝之前的项目来改，或者重新创建一个项目，再根据需求拷贝文件</li><li>新增页面的时候，需要创建很多文件（视图、路由、Vuex）</li></ul><p>而每个页面其实也是大同小异：</p><ul><li>数据表格（搜索、分页、其他操作等）</li><li>表单</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>基于以上场景，我想到的解决方法就是编写一个 CLI 工具，可以一行命令实现以下功能：</p><ul><li>初始化项目</li><li>增删页面</li></ul><p>只有 CLI 自然是不够的，还要搭配项目模板（template）使用。</p><p>但要注意脚手架工具要与项目模板解耦，下面细讲。</p><h3 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h3><p>创建一个 GitHub 组织存放项目模板，一个模板应该包含以下：</p><ol><li><p>meta.json</p><p>根据项目自定义一些问题，比如：</p><ul><li>项目名称</li><li>项目描述</li></ul></li><li><p>template 文件夹</p><p>存放项目模板，初始化时根据用户回答的问题，生成项目。</p></li><li><p>generator 文件夹</p><p>执行 CLI 命令时，由 CLI 调用，主要用来自定义一些问题、模板文件信息等。</p></li></ol><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>主要命令：</p><ol><li><p>init：</p><p>初始化项目，这时候会查询项目模板列表，然后根据用户所选的模板进行初始化（把项目模板下载到本地），并且生成一个<code>template.json</code>记录当前项目模板的名字，供后续使用</p></li><li><p>add、delete：</p><p>此命令需在生成后的项目中使用，会根据<code>template.json</code>中的模板信息找到对应的 <code>generator</code> 目录下的方法，执行对应的方法。</p></li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>每个团队面临的场景不一样，如果你也想编写一个自己的 CLI 工具，希望本文能给你提供一些思路。</p><p>如果有兴趣可以参考一下我的 CLI 实现：<a href="https://github.com/gd4Ark/fa-cli">fa-cli</a>，项目模板：<a href="https://github.com/fa-web-template/vue-admin">fa-web-template</a></p><p>感谢观看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器输入 URL 回车之后发生了什么（超详细版）</title>
      <link href="//post/b6c7c0a2.html"/>
      <url>//post/b6c7c0a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><p><strong>注意：</strong>本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h2 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h2><p><strong>地址解析：</strong></p><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/">你所不知道的 HSTS</a>。</p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181538.png"></p><h2 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h2><p><strong>基本步骤</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png"></p><p><strong>1. 浏览器缓存</strong></p><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong></p><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong></p><p>路由器也有自己的缓存。</p><p><strong>4. ISP DNS 缓存</strong></p><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong></p><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png"></p><blockquote><p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8">维基百科</a></p></blockquote><p><strong>需要注意的点</strong></p><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h2 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h2><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822182400.png"></p><h3 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a><strong>1. 应用层：发送 HTTP 请求</strong></h3><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h3 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a><strong>2. 传输层：TCP 传输报文</strong></h3><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol></blockquote><h3 id="3-网络层：IP-协议查询-Mac-地址"><a href="#3-网络层：IP-协议查询-Mac-地址" class="headerlink" title="3. 网络层：IP 协议查询 Mac 地址"></a><strong>3. 网络层：IP 协议查询 Mac 地址</strong></h3><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h3 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a><strong>4. 链路层：以太网协议</strong></h3><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p><strong>注意</strong>：接收方回应是单播。</p><blockquote><p>相关知识点：</p><ol><li>ARP 攻击</li></ol></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a><strong>服务器接受请求</strong></h4><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h2 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h2><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183251.png"></p><p><strong>HTTPD</strong></p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong></p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p><strong>重定向</strong></p><p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html">详见这篇文章</a></p></blockquote><p><strong>URL 重写</strong></p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME</a> 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h2 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h2><p><strong>浏览器内核</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/961f7b5d-9e06-4006-ab99-974e8e9e2ba5.png"></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183712.png"></p><h3 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1.HTML 解析"></a><strong>1.HTML 解析</strong></h3><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>1. 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><p><strong>2. 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>3. 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>4. 构建树（tree construction）</strong></p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1355879024-573db51949951_articlex.png"></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h3 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h3><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p &#123; font-size :14px &#125;</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h3 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h3><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li><code>!important</code></li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8">这篇文章</a></p><h4 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a><strong>5. 合并渲染层</strong></h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a><strong>6. 回流与重绘</strong></h4><p><strong>回流(reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li></ul><h4 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h4><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184523.png"></p><p>可以分为三个阶段：</p><h4 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a><strong>1. 词法分析</strong></h4><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a><strong>2. 预编译</strong></h4><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><h4 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a><strong>3. 执行</strong></h4><p><strong>JS 线程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184731.png"></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p><strong>微任务</strong></p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822185002.png"></p><p><strong>代码例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN">what-happens-when-zh_CN</a></li><li><a href="https://alistapart.com/article/tags-to-dom/">Tags to DOM</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">js 引擎的执行过程（一）</a></li><li>还有一些找不到了。。。。。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图解 HTTP》 学习笔记</title>
      <link href="//post/f6ef2a76.html"/>
      <url>//post/f6ef2a76.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本书对互联网基盘——HTTP 协议进行了全面系统的介绍。作者由 HTTP 协议的发展历史娓娓道来，严谨细致地剖析了 HTTP 协议的结构，列举诸多常见通信场景及实战案例，最后延伸到 Web 安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解 HTTP 通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握 HTTP 协议的基础，前端工程师分析抓包数据，后端工程师实现 REST API、实现自己的 HTTP 服务器等过程中所需的 HTTP 相关知识点本书均有介绍。</p><p>本书适合 Web 开发工程师，以及对 HTTP 协议感兴趣的各层次读者。</p><h2 id="第一章、了解-WEB-及网络基础"><a href="#第一章、了解-WEB-及网络基础" class="headerlink" title="第一章、了解 WEB 及网络基础"></a>第一章、了解 WEB 及网络基础</h2><p><strong>HTTP 的诞生</strong></p><p>1989 年 3 月，HTTP 诞生了，最初设想的理念是：借助多文本之间互相关联形成的超文本，连成 WWW。</p><p><strong>Web 成长时代</strong></p><p>1990 年 11 月，CERN 研发了世界上第一台 WEB 服务器。</p><p>1990 年，大家针对 HTML1.0 草案进行讨论，因存在多处模糊的地方，草案被直接废弃。</p><p>1992 年 9 月，日本第一个<a href="http://www.ibarakiken.gr.jp/www/">网站</a>的主页上线了。</p><p>1993 年 1 月，现代浏览器的祖先 <a href="http://archive.ncsa.illinois.edu/mosaic.html">Mosaic</a> 问世，它以内联等形式显示 HTML 的图像，迅速在世界范围内流行开来。</p><p>1994 年 12 月，网景公司发布 Netscape Navigator 1.0。</p><p>1995 年，微软发布了 Internet Explorer 1.0 和 2.0。</p><p><strong>驻足不前的 HTTP</strong></p><p>HTTP 0.9 ：因为那时的 HTTP 并没有正式的标准被建立，所有含有 HTTP 1.0 之前版本的意思。</p><p>HTTP 1.0 ：1996 年 5 月正式作为标准被公布，并记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt">RFC1945</a>。</p><p>HTTP 1.1 ：1997 年 1 月公布，最新标准版本为 <a href="https://www.ietf.org/rfc/rfc2616.txt">RFC2616</a>。</p><p><strong>网络基础 TCP/IP</strong></p><p>通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p><p><strong>TCP/IP 协议族</strong></p><p>TCP/IP 是互联网相关的各类协议族的总称。</p><p><strong>TCP/IP 的分层管理</strong></p><p>分为四层：</p><ul><li>应用层：决定了向用户提供应用服务时通信的活动，例如：FTP、DNS、HTTP。</li><li>传输层：提供处于网络连接中的两台计算机之间的数据传输，TCP、UDP。</li><li>网络层：处理在网络上流动的数据包，规定传输路线。</li><li>数据链路层：处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。</li></ul><p>分层的好处：把各层之间的接口部分规划好后，修改某个地方时只需修改对应的层，每个层次内部不影响其他层。</p><p><strong>TCP/IP 通信传输流</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819113915.png"></p><p>HTTP 举例：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819115726.png"></p><p><strong>与 HTTP 关系密切的协议 : IP、TCP 和 DNS</strong></p><ul><li>负责传输的 IP 协议</li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143752.png"></p><ul><li><p>确保可靠性的 TCP 协议</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143845.png"></p></li><li><p>负责域名解析的 DNS 服务</p></li></ul><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143832.png"></p><p><strong>各种协议与 HTTP 协议的关系</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819143952.png"></p><h2 id="第二章、简单的-HTTP-协议"><a href="#第二章、简单的-HTTP-协议" class="headerlink" title="第二章、简单的 HTTP 协议"></a>第二章、简单的 HTTP 协议</h2><p>HTTP 协议用于客户端和服务器之间的通信，请求资源方成为客户端，提供资源响应方成为服务器端。</p><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p>请求报文的构成：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819145113.png"></p><p>响应报文的构成：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819145201.png"></p><p><strong>HTTP 是不保存状态的协议</strong></p><p>HTTP 是一个无状态协议，自身不具备保存之前发送过的请求或响应的功能。</p><p>之后随着发展，引入了 Cookie 技术。</p><p><strong>请求 URI 定位资源</strong></p><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p><p><strong>告知服务器意图的 HTTP 方法</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819150110.png"></p><p><strong>持久连接节省通信量</strong></p><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。</p><p><strong>持久连接</strong></p><p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接的方法。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p><strong>管线化</strong></p><p>管线化技术出现后，能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><strong>使用 Cookie 的状态管理</strong></p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><h2 id="第三章、HTTP-报文内的-HTTP-信息"><a href="#第三章、HTTP-报文内的-HTTP-信息" class="headerlink" title="第三章、HTTP 报文内的 HTTP 信息"></a>第三章、HTTP 报文内的 HTTP 信息</h2><p><strong>HTTP 报文</strong></p><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。</p><p>HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p><p>HTTP 报文大致可分为报文首部和报文主体两块，通常，并不一定要有报文主体。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151451.png"></p><p><strong>结构</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151537.png"></p><p><strong>实例</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819151613.png"></p><p><strong>编码提升传输速率</strong></p><p>HTTP 在传输时可以原样直接传输，也可以在传输时通过编码提升传输速率，通过编码，能有效地处理大量的访问请求，但也消耗更多的 CPU 等资源。</p><p><strong>报文主体和实体主体的差异</strong></p><ul><li>报文：HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。</li><li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</li></ul><p><strong>压缩传输的内容编码</strong></p><p>常用的内容编码有以下几种：</p><ul><li>gzip（GNU zip）</li><li>compress（UNIX 系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><p><strong>分割发送的分块传输编码</strong></p><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码。</p><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p><p><strong>发送多种数据的多部分对象集合</strong></p><p>发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><p>多部分对象集合包含的对象如下：</p><ul><li>multipart/form-data：在 Web 表单文件上传时使用。</li><li>multipart/byteranges：状态码 206，响应报文包含了多个范围的内容时使用。</li></ul><p><strong>获取部分内容的范围请求</strong></p><p>为了解决加载超大图片导致网络中断的情况而实现的一种手段，叫做范围请求。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819154030.png"></p><p><strong>内容协商返回最合适的内容</strong></p><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商。</p><h2 id="第四章、返回结果的状态码"><a href="#第四章、返回结果的状态码" class="headerlink" title="第四章、返回结果的状态码"></a>第四章、返回结果的状态码</h2><p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p><p><strong>状态码类别</strong>：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819154239.png"></p><p>更多：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应代码</a></p><h2 id="第五章、与-HTTP-协作的-Web-服务器"><a href="#第五章、与-HTTP-协作的-Web-服务器" class="headerlink" title="第五章、与 HTTP 协作的 Web 服务器"></a>第五章、与 HTTP 协作的 Web 服务器</h2><p><strong>用单台虚拟主机实现多个域名</strong></p><p>即便物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以搭建多个站点。</p><p><strong>通信数据转发程序：代理、网关、隧道</strong></p><p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序：</p><ul><li><p>代理：一种有转发功能的应用程序，扮演了服务器和客户端中间人的角色。</p></li><li><p>网关：转发其他服务器通信数据的服务器，它就像自己拥有资源的源服务器一样对请求进行处理。</p></li><li><p>隧道：将相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><p><strong>保存资源的缓存</strong></p></li></ul><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p><strong>客户端的缓存</strong></p><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件。</p><h2 id="第六章、HTTP-首部"><a href="#第六章、HTTP-首部" class="headerlink" title="第六章、HTTP 首部"></a>第六章、HTTP 首部</h2><p><strong>注：这部分太多解释，建议看原文</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155354.png"></p><p><strong>HTTP 请求报文</strong></p><p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155327.png"></p><p><strong>HTTP 响应报文</strong></p><p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819155514.png"></p><p><strong>HTTP/1.1 首部字段一览</strong></p><p>通用首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160353.png"></p><p>请求首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160426.png"></p><p>响应首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160452.png"></p><p>实体首部字段：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819160511.png"></p><h2 id="第七章、HTTP-的缺点"><a href="#第七章、HTTP-的缺点" class="headerlink" title="第七章、HTTP 的缺点"></a>第七章、HTTP 的缺点</h2><p>主要的不足，例举如下：</p><ul><li>通信使用明文（不加密），内容可能会被窃听（例如：抓包）</li><li>不验证通信方的身份，因此有可能遭遇伪装（例如：DoS）</li><li>无法证明报文的完整性，所以有可能已遭篡改（例如：中间人攻击）</li></ul><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong></p><p>为了统一解决上述这些问题，需要在 HTTP 等机制。我们把添加了加密及认证机制的称为 HTTPS。</p><p><strong>使用 HTTPS 通信</strong></p><p>经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。</p><p><strong>HTTPS 是身披 SSL 外壳的 HTTP</strong></p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p><p>简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819161403.png"></p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><strong>相互交换密钥的公开密钥加密技术</strong></p><p>SSL 采用一种叫做公开密钥加密（非对称加密）的加密处理方式。</p><p><strong>HTTPS 的安全通信机制</strong></p><p>通信步骤：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819161648.png"></p><p><strong>SSL 速度慢吗</strong></p><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p><p>HTTPS 比 HTTP 要慢 2 到 100 倍，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p><h2 id="第八章、确认访问用户身份的认证"><a href="#第八章、确认访问用户身份的认证" class="headerlink" title="第八章、确认访问用户身份的认证"></a>第八章、确认访问用户身份的认证</h2><p><strong>何为认证</strong></p><p>服务器为了确认用户的身份，通常需要核对一些信息：</p><ul><li>密码</li><li>动态令牌</li><li>数字证书</li><li>生物认证</li><li>IC 卡</li></ul><p><strong>HTTP 使用的认证方式</strong></p><ul><li>BASIC 认证（基本认证）</li><li>DIGEST 认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="第九章、基于-HTTP-的功能追加协议"><a href="#第九章、基于-HTTP-的功能追加协议" class="headerlink" title="第九章、基于 HTTP 的功能追加协议"></a>第九章、基于 HTTP 的功能追加协议</h2><p><strong>消除 HTTP 瓶颈的 SPDY</strong></p><p>Google 在 2010 年发布了 <a href="http://www.chromium.org/spdy/">SPDY</a>（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><p><strong>SPDY 的目标</strong></p><p>陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使 HTTP 得到了改善，但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。</p><p>处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP 所遭遇的瓶颈。</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。</li><li>赋予请求优先级：可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 首部</li><li>推送功能：支持服务器主动向客户端推送数据的功能。</li><li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</li></ul><p><strong>使用浏览器进行全双工通信的 WebSocket</strong></p><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p><p><strong>WebSocket 协议</strong></p><p>主要特点：</p><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能。</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。</li></ul><p><strong>期盼已久的 HTTP/2.0</strong></p><p>特点：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190819163846.png"></p><p><strong>Web 服务器管理文件的 WebDAV</strong></p><p>WebDAV（基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。</p><h2 id="第十章、构建-Web-内容的技术"><a href="#第十章、构建-Web-内容的技术" class="headerlink" title="第十章、构建 Web 内容的技术"></a>第十章、构建 Web 内容的技术</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>动态 HTML</li><li>CGI</li><li>Servlet</li><li>XML</li><li>RSS/Atom</li><li>JSON</li></ul><h2 id="第十一章、Web-的攻击技术"><a href="#第十一章、Web-的攻击技术" class="headerlink" title="第十一章、Web 的攻击技术"></a>第十一章、Web 的攻击技术</h2><p>对 Web 应用的攻击模式有以下两种：</p><ul><li>主动攻击：是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式</li><li>被动攻击：指利用圈套策略执行攻击代码的攻击模式</li></ul><p><strong>因输出值转义不完全引发的安全漏洞：</strong></p><ul><li><p>XSS 注入</p></li><li><p>SQL 注入</p></li><li><p>OS 命令注入</p></li><li><p>HTTP 首部注入攻击</p></li><li><p>邮件首部注入攻击</p></li><li><p>目录遍历攻击</p></li><li><p>远程文件包含漏洞</p><p><strong>因设置或设计上的缺陷引发的安全漏洞：</strong></p></li><li><p>强制浏览</p></li><li><p>不正确的错误信息处理</p></li><li><p>开放重定向</p></li></ul><p><strong>因会话管理疏忽引发的安全漏洞：</strong></p><ul><li>会话劫持</li><li>会话固定攻击</li><li>跨站点请求伪造</li></ul><p><strong>其他安全漏洞：</strong></p><ul><li>密码破解</li><li>点击劫持</li><li>DoS 攻击</li><li>后门程序</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 读书 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PhpStorm 使用 PHPCS 检查代码规范及自动修正和Git提交检查</title>
      <link href="//post/6959bf0.html"/>
      <url>//post/6959bf0.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在团队开发中，每个人的代码风格都不一样，为了日后方便更新和维护，必须考虑协作和编码规范。</p><p>本文就介绍如何在 PhpStorm 中配置 PSR2 代码规范检查和保存自动格式化修复，以及利用 Git Hook 对提交的代码进行检查。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="安装-PHP-CS"><a href="#安装-PHP-CS" class="headerlink" title="安装 PHP-CS"></a>安装 PHP-CS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require &quot;squizlabs/php_codesniffer=*&quot;</span><br></pre></td></tr></table></figure><p>安装完成后会在全局依赖包目录生成 phpcbf 和 phpcs 文件</p><blockquote><p>查看 composer 全局依赖包路径，下面会用到</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global config bin-dir --absolute</span><br></pre></td></tr></table></figure><h3 id="配置-PhpStorm-使用-PSR-2-标准"><a href="#配置-PhpStorm-使用-PSR-2-标准" class="headerlink" title="配置 PhpStorm 使用 PSR-2 标准"></a>配置 PhpStorm 使用 PSR-2 标准</h3><h4 id="1-代码风格"><a href="#1-代码风格" class="headerlink" title="1. 代码风格"></a>1. 代码风格</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/d8bf4d6423310685be6a4bdcd55ff64.png" alt="img"></p><h4 id="2-设置-PHP-CS-路径"><a href="#2-设置-PHP-CS-路径" class="headerlink" title="2. 设置 PHP-CS 路径"></a>2. 设置 PHP-CS 路径</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/150de5624de5b230c93bb636eb794e7.png" alt="img"></p><h4 id="3-代码检查"><a href="#3-代码检查" class="headerlink" title="3. 代码检查"></a>3. 代码检查</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/3eb78dc76568e3656798747eea83e8c.png" alt="img"></p><blockquote><p>如果没有下拉选项，可以点击旁边的刷新按钮</p></blockquote><p>还有这个</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/d9c37df038c2cf0a6538ea4bc5630ca.png" alt="img"></p><p>配置到这里后，打开一个 PHP 文件，就会在不符合 PSR-2 的代码下边加一条波浪线</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141029.png" alt="img"></p><p>使用 <code>Ctrl + Alt + L</code> 将会自动格式化成 PSR-2 的风格</p><h3 id="集成-PHP-CS"><a href="#集成-PHP-CS" class="headerlink" title="集成 PHP-CS"></a>集成 PHP-CS</h3><p>经过上面的操作，Phpstorm 代码格式化的规则基本与 PHP-CS 的规则基本一致了，但也有一小部分不一致，所以后面还要用到 phpcs 和 phpcbf</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141709.png" alt="img"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727141817.png" alt="img"></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>Program：<code>phpcs/phpcbf</code> 路径</p><p>Arguments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--standard=PSR2 $FileDir$/$FileName$ ## 当前文件</span><br><span class="line">--standard=PSR2 $FileDir$ ## 当前文件夹</span><br></pre></td></tr></table></figure><p>Working directory：<code>$ProjectFileDir$</code></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727142731.png" alt="img"></p><h3 id="配置保存自动格式化和修复"><a href="#配置保存自动格式化和修复" class="headerlink" title="配置保存自动格式化和修复"></a>配置保存自动格式化和修复</h3><h5 id="1-为-phpcbf-添加快捷键"><a href="#1-为-phpcbf-添加快捷键" class="headerlink" title="1. 为 phpcbf 添加快捷键"></a>1. 为 phpcbf 添加快捷键</h5><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727142957.png" alt="img"></p><h5 id="2-录制宏"><a href="#2-录制宏" class="headerlink" title="2. 录制宏"></a>2. 录制宏</h5><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143052.png" alt="img"></p><p>步骤：</p><ol><li><code>Ctrl + Alt + L</code></li><li><code>Ctrl + Alt + Shift + P</code> （phpcbf 快捷键）</li><li><code>Ctrl + S</code></li><li>按下编辑器右下角保存录制</li></ol><h5 id="3-为宏配置快捷键"><a href="#3-为宏配置快捷键" class="headerlink" title="3. 为宏配置快捷键"></a>3. 为宏配置快捷键</h5><p>先删除默认的保存快捷键 <code>Ctrl + S</code>，另外配置一个别的快捷键<code>Ctrl + Alt + Shift + S</code></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143522.png" alt="img"></p><p>为宏配置快捷键</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190727143824.png" alt="img"></p><h3 id="利用-Git-Hook-对提交的代码进行检查"><a href="#利用-Git-Hook-对提交的代码进行检查" class="headerlink" title="利用 Git Hook 对提交的代码进行检查"></a>利用 Git Hook 对提交的代码进行检查</h3><h4 id="安装-GrumPHP"><a href="#安装-GrumPHP" class="headerlink" title="安装 GrumPHP"></a>安装 GrumPHP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev phpro/grumphp</span><br></pre></td></tr></table></figure><p>安装完后会自动生成一个 <code>grumphp.yml</code></p><p>请修改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parameters:</span><br><span class="line">  git_dir: .</span><br><span class="line">  bin_dir: vendor/bin</span><br><span class="line">  tasks:</span><br><span class="line">    phpcs:</span><br><span class="line">      standard: PSR2</span><br><span class="line">      ignore_patterns:</span><br><span class="line">        - ./database/*</span><br><span class="line">        - ./vendor/*</span><br></pre></td></tr></table></figure><p>这样 <code>git commit</code> 的时候就会对提交的代码进行检查，只有符合 PSR-2 规范的代码才能通过。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客与画家》-读书笔记</title>
      <link href="//post/d94be22b.html"/>
      <url>//post/d94be22b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本书是硅谷创业之父 Paul Graham 的博客文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。</p><p>本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近读完这本书，写得很不错，适合边读边思考，作者从自身经历讨论了很多问题，包括书呆子、政治、财富、创业、编程语言、设计等问题。</p><p>另外本人看的是阮一峰翻译的版本，文笔非常流畅，一点都没有翻译的腔调，感觉是直接用母语写出一般。</p><p>在此感谢作者 Paul Graham 先生和 译者阮一峰先生。</p><p>声明，这本书的每章都是相互独立的，不必要按顺序阅读。</p><p>全书大致分为 3 部分</p><ul><li>1-4 章解释黑客如何成长以及如何看待世界</li><li>5-9 章介绍创业、工作的方法论</li><li>10-15 章讨论编程语言的特点和使用方法</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1、为什么书呆子不受欢迎"><a href="#1、为什么书呆子不受欢迎" class="headerlink" title="1、为什么书呆子不受欢迎"></a>1、为什么书呆子不受欢迎</h3><p>黑客的特点之一便是高智商，在学校一般表现为书呆子形象，不受欢迎，其主要原因是，他们专注于解决自己感兴趣的事情，而不想花心思去取悦别人。但是学校不是社会，这里并不需要解决问题的人，于是书呆子们完全没有用武之地。但是，一旦这些书呆子走入社会，社会需要能够真正解决问题的人，于是书呆子们的价值就体现出来了。</p><h3 id="2、黑客与画家"><a href="#2、黑客与画家" class="headerlink" title="2、黑客与画家"></a>2、黑客与画家</h3><p>与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。</p><p>从这个基本观点出发，通过借鉴这些创作领域的创作模式，我们可以得出一些重要的启示：</p><ol><li>编程不应该是先将思路完全想好，然后去写代码。思路的完善应该是在代码编写过程中完成的。好的编程语言应是允许动态扩展的语言，编程语言是帮助我们思考的，而 不仅仅是表达已经想好的想法。</li><li>学习编程，应是实践的过程。在敲代码，写程序中去学习。</li><li>保留自己写过的代码，时常翻看。</li><li>大量阅读范例程序，充分利用开源的资源。</li></ol><p>作者也提到在大公司中，并不能发挥一个黑客的所有能力，如果你想开发出的优秀软件，那么可以选择创业，但是这样会导致你必须处理许多与开发软件无关的事情，并且赚钱的软件往往不是好玩的软件，所以解决方法是：找一个养家糊口的”白天工作“，然后在其余时间开发优美的软件。</p><h3 id="3、不能说的话"><a href="#3、不能说的话" class="headerlink" title="3、不能说的话"></a>3、不能说的话</h3><p>先问自己：你是一个随大流的人吗？有没有什么观点不愿说出口？你的观点是别人灌输给你的，还是独立思考得到的？</p><p>不管哪个年代，有一件事都是不会改变的，那就是“祸从口出”。</p><p>满足“不能说的话”的两个条件 ：</p><ol><li>这些话不能说出口</li><li>它们是正确的，或者看起来很可能正确，值得进一步讨论</li></ol><p>其中第二条更重要，很显然，你说一句 5+3=53 并不会引起人们的注意，除了嘲笑和鄙视。因为怒触他人的言论是那些可能会有人相信的言论。我猜想，最令人暴跳如雷的言论，就是被认为说出了真相的言论。</p><p>明确了什么是“不能说的话”，接着，作者给出了五种找出“不能说的话”的方法：</p><ol><li><p>判断言论的真伪</p></li><li><p>关注“异端邪说”</p><blockquote><p>历史上的每一个年代，都会给”异端邪说“贴一些标签，目的是在人们开始思考它们是否为真之前就把它们封杀。其实在当代，也有这样的问题。我们应该多加注意那些贴标签的行为。</p></blockquote></li><li><p>将当代观念与不同时期的古代观念 diff 一下，将当代不同地方的观念 diff 一下</p></li><li><p>寻找那些一本正经的卫道者，看看他们到底在捍卫着什么。作者用一个例子解释，父母在家里会尽量避免说脏话，只是不想让孩子学到。但是，孩子虽然没从父母那里学会说脏话，但是从他的朋友那里学到了。所以在家里，父母和孩子都不说脏话，而在外面都尽情地说。</p></li><li><p>观察禁忌是如何产生的。流行的道德观念往往不是偶然产生的，而是被刻意创造出来的。如果有些观点不能说，可能的原因是某些团体不让我们说。</p><blockquote><p>我猜想，道德禁忌的最大制造者是那些权力斗争中略占上风的一方。你会发现，这一方有实力推行禁忌，同时又软弱到需要禁忌保护自己的利益。</p></blockquote></li></ol><h3 id="4、良好的坏习惯"><a href="#4、良好的坏习惯" class="headerlink" title="4、良好的坏习惯"></a>4、良好的坏习惯</h3><p>黑客往往是不服从管教的，并以违反常理的思维方式思考、行动。虽然他们的行为常常导致平凡大众的反感，甚至厌恶，进而产生了偏见，但是这种“坏习惯”反而利大于弊，让他们保持了一种常人不具备的敏感，尤其是对于一些貌似无关痛痒，却与所有人息息相关的政治行为。</p><p>举例来说，为什么程序员会比其他人更在乎公民自由？表面上来看，政府侵犯公民自由并不会让代码质量下降，而只是逐渐导致一个观点占据上风。而如果一旦极权主义制度形成，那么这种制度就很难废除。黑客对公民自由这一概念比普通人理解的更透彻，更重要的是，他们明白失去知识自由之后未来的样子。所以他们能感知即将到来的暴风雨。</p><p>那些占据高位、本能地想要约束黑客、强迫黑客服从的人们，请小心你们的要求，因为你们真有可能成为千古罪人。</p><h3 id="5、另一条路"><a href="#5、另一条路" class="headerlink" title="5、另一条路"></a>5、另一条路</h3><p>在作者看来，一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。</p><p>要让软件变得可靠，关键是你要全神贯注，而不是开发得很慢。</p><p>如果你亲眼见到某人第一次使用你的软件，你就会知道软件的哪个地方最打动他。</p><p>互联网做起来很辛苦，还有许多特别大的压力，但是它们的唯一作用，就是使得创业公司成功的机会变大。</p><p>管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。只要做到这两点，你就会超过大多数创业公司。</p><p>另外，如果你不打算自己动手开发和设计，那就不要创业。</p><h3 id="6、如何创造财富"><a href="#6、如何创造财富" class="headerlink" title="6、如何创造财富"></a>6、如何创造财富</h3><p>金钱不等于财富，创造有价值的东西就是创造财富。你最好先搞清楚什么是财富。财富与金钱并不是同义词。财富存在的时间与人类历史一样长久，甚至更长久，事实上蚂蚁也拥有财富。金钱是一种历史相对较短的发明。</p><p>要致富，你需要两样东西：可测量性和可放大性。</p><p>如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。</p><p>创业公司通过发明新技术盈利，所以具备可放大性。</p><p>如果你开发出来的技术是竞争对手难于复制的，那就够了，你不需要依靠其他防御手段了。</p><p>不应该收购的危险信号，排在榜首的信号中有一个就是公司由技术顽童掌控，只想解决有趣的技术问题，不考虑用户的需要。你开办创业公司不是单纯地为了解决问题，而是为了解决那些用户关心的问题。</p><p>政府禁止个人积累财富实际上就是命令人民减慢工作的速度。</p><p>只要懂得藏富于民，国家就会变得强大。</p><h3 id="7、关注贫富分化"><a href="#7、关注贫富分化" class="headerlink" title="7、关注贫富分化"></a>7、关注贫富分化</h3><p>进入社会以后，你不能总是靠父母养活，如果你需要什么东西，要么你自己做出来，要么做其他东西与需要的人交换金钱，再用金钱去买你想要的东西</p><p>技术肯定加剧了有技术者与无技术者之间的生产效率差异</p><p>技术在加大收入差距的同时，缩小了大部分的其他差距</p><h3 id="8、防止垃圾邮件的一个方法"><a href="#8、防止垃圾邮件的一个方法" class="headerlink" title="8、防止垃圾邮件的一个方法"></a>8、防止垃圾邮件的一个方法</h3><p>这一节对于现在这个年代的意义不是很大，作者认为过滤垃圾邮件是可以做到的，基于内容的过滤器将发挥作用。 但是在他那个年代，意义很大的。</p><p>要对单个词语进行贝叶斯判断，就能很好地过滤大部分垃圾邮件。后面通过统计学的方法做了一个过滤器，其实有点像现在的机器学习了。</p><h3 id="9、设计者的品味"><a href="#9、设计者的品味" class="headerlink" title="9、设计者的品味"></a>9、设计者的品味</h3><p>他想要的学生不仅应该技术过硬，还应当能够使用技术做出优美的产品</p><p>你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了</p><p>在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果</p><h3 id="10、编程语言解析"><a href="#10、编程语言解析" class="headerlink" title="10、编程语言解析"></a>10、编程语言解析</h3><p>程序员的时间比计算机的时间昂贵得多。</p><p>长期使用某种语言，就会慢慢按照这种语言的思维模式进行思考。</p><p>静态类型语言与动态类型语言没有绝对的好坏之分，每个人都可以有自己的选择。</p><h3 id="11、一百年后的编程语言"><a href="#11、一百年后的编程语言" class="headerlink" title="11、一百年后的编程语言"></a>11、一百年后的编程语言</h3><p>语言只是一种书写法，程序则是一种严格符合规则的描述，以书面形式记录计算机如何解决你的问题。<br>随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。<br>浪费分成好的浪费和坏的浪费，感兴趣的就是好的浪费，即用更多的钱得到更简单的设计。<br>对速度的追求是人类内心根深蒂固的欲望，设计编程语言的时候，应该有意识地问问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。<br>将语言的语义与语言的实现分离。<br>写文章，就是为了试着搞清楚某件事情，对于软件而言也是如此。<br>效率低下的软件并不等于很烂的软件，一种让程序员做无用功的语言才真正称得上很烂，浪费程序员的时间而不是浪费机器的时间才是真正的无效率。<br>面向对象编程，使得可以对代码进行可持续性开发。<br>性能分析器有助于指导程序开发，现在许多人仍然相信程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。</p><ul><li>一百年后的编程语言在理论上今天就能设计出来。</li><li>如果今天真的能设计出这样一种语言，很可能现在适合编程，并且能够产生更好的结果。</li></ul><h3 id="12、拒绝平庸"><a href="#12、拒绝平庸" class="headerlink" title="12、拒绝平庸"></a>12、拒绝平庸</h3><p>这一节作者在推广 Lisp 语言，Lisp 很值得学习，你掌握它以后，会感到它给你带来的极大启发，这会大大提高你的编程水平，使你成为一个更好的程序员，尽管在实际工作中极少会用到 Lisp。</p><h3 id="13、书呆子的复仇"><a href="#13、书呆子的复仇" class="headerlink" title="13、书呆子的复仇"></a>13、书呆子的复仇</h3><p>在某些情况下，一些语言就是比另一些语言更出色。<br>认为所有语言都一样的看法的缺点是自欺欺人，但优点是可以使许多事情变得很简单。<br>编程语言现在的发展不过刚刚赶上 1958 年 Lisp 语言的水平。</p><p>为什么 Lisp 很特别，因为 Lisp 刚诞生的时候包含的 9 种思想：</p><ol><li>条件结构(即 if-else 结构)</li><li>函数也是一种数据结构</li><li>递归</li><li>变量的动态类型</li><li>垃圾回收机制</li><li>程序由表达式组成</li><li>符号类型</li><li>代码使用符号和常量组成的树形表示法</li><li>无论什么时候，整个语言都是可用的（Lisp 不真正区分读取期、编译期、运行期）</li></ol><h3 id="14-梦寐以求的编程语言"><a href="#14-梦寐以求的编程语言" class="headerlink" title="14.梦寐以求的编程语言"></a>14.梦寐以求的编程语言</h3><p>这种语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。</p><p>这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。</p><p>这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。</p><p>这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。</p><h3 id="15、设计与研究"><a href="#15、设计与研究" class="headerlink" title="15、设计与研究"></a>15、设计与研究</h3><p>让用户满意并不等于迎合用户的一切要求，用户不了解所有可能的选择，也经常弄错自己真正想要的东西。<br>编程语言也应该是以人为本。<br>贴近用户的设计思想被归纳为“弱即是强”模式。<br>任何时候，代码都必须能够运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解按位操作符</title>
      <link href="//post/learn-bitwise-operators.html"/>
      <url>//post/learn-bitwise-operators.html</url>
      
        <content type="html"><![CDATA[<p>按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>按位操作符（Bitwise operators） 的计算主要用在二进制中，虽然平时很少有机会用到按位操作符，但不得不承认，在某些时候，这些操作符能够给我们提供很好的解决方案。</p><p>下面介绍操作符时，也会提供一些比较经典的例子，来看看它们是如何巧妙地解决问题的吧。</p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><h3 id="2-1-二进制"><a href="#2-1-二进制" class="headerlink" title="2.1 二进制"></a>2.1 二进制</h3><blockquote><p>本文假设你知道计算机中用二进制数来存储，计算数字，并且熟悉二进制数的表示方法。</p></blockquote><p>讲解位操作符之前，先简单讲一下真值、原码、反码和补码。</p><h4 id="2-1-1-真值"><a href="#2-1-1-真值" class="headerlink" title="2.1.1 真值"></a>2.1.1 真值</h4><p>我们表示自然数包括正数，负数和 0，下面是 1 和-1 的二进制表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 00000001 # +1</span><br><span class="line">- 00000001 # -1</span><br></pre></td></tr></table></figure><h4 id="2-1-2-原码"><a href="#2-1-2-原码" class="headerlink" title="2.1.2 原码"></a>2.1.2 原码</h4><p>但是计算机只能存储 0 和 1，不能存储正负，所以一个数的最高位存放符号，正数为 0，负数为 1，用后面七位来表示真值的绝对值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0000001 # +1</span><br><span class="line">1 0000001 # -1</span><br></pre></td></tr></table></figure><p>由于<code>10000000</code>表示为 -0 ,这个没有意义，所以这个数字被用来表示 -128，所以负数就比整数多一个。</p><h4 id="2-1-3-反码"><a href="#2-1-3-反码" class="headerlink" title="2.1.3 反码"></a>2.1.3 反码</h4><p>反码的表示方法是：正数不变，负数是在其原码的基础上，符号位不变，其余位取反：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0000001 # +1</span><br><span class="line">1 1111110 # -1</span><br></pre></td></tr></table></figure><h4 id="2-1-4-补码"><a href="#2-1-4-补码" class="headerlink" title="2.1.4 补码"></a>2.1.4 补码</h4><p>补码的作用主要是为了简化运算，将减法变为加法而发明的数学表示法，其表示方法是：正数不变，负数是在其反码的基础上+1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0000001 # +1</span><br><span class="line">1 1111111 # -1</span><br></pre></td></tr></table></figure><h4 id="2-1-5-最后"><a href="#2-1-5-最后" class="headerlink" title="2.1.5 最后"></a>2.1.5 最后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [0000 0001]原</span><br><span class="line">     = [0000 0001]反</span><br><span class="line">     = [0000 0001]补</span><br><span class="line">--------------------</span><br><span class="line">[-1] = [1000 0001]原</span><br><span class="line">     = [1111 1110]反</span><br><span class="line">     = [1111 1111]补</span><br></pre></td></tr></table></figure><h3 id="2-2-按位逻辑操作符"><a href="#2-2-按位逻辑操作符" class="headerlink" title="2.2. 按位逻辑操作符"></a>2.2. 按位逻辑操作符</h3><p>从概念上讲，按位逻辑操作符遵循下面规则：</p><ul><li><p>操作数被转换成 32 位整数，用比特序列（0 和 1 组成）表示。超过 32 位的数字会被丢弃。</p></li><li><p>第一个操作数的每个比特位与第二个操作数的相应比特位匹配：第一位对应第一位，第二位对应第二位，以此类推。</p></li><li><p>位运算符应用到每对比特位，结果是新的比特值。</p></li></ul><p>下面开始讲解各种位操作符。</p><p>注意：</p><blockquote><p>前面提到操作会被转换成 32 位整数，但为了简化，将使用 8 位整数来演示运算过程。</p></blockquote><h4 id="2-2-1-AND（与）"><a href="#2-2-1-AND（与）" class="headerlink" title="2.2.1 AND（与）"></a>2.2.1 AND（与）</h4><p>对每一对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。与操作的真值表如下：</p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">a AND b</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>下面展示<code>11 &amp; 14</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 = 0000 1011</span><br><span class="line">14 = 0000 1110</span><br><span class="line">     0000 1010 = 10</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>任何数和 0 进行 AND 都为 0：<code>x &amp; 0 = 0</code>。</li><li>任何数和 -1 进行 AND 都为自身：<code>x &amp; -1 = x</code>。</li></ul><p>例子 1（判断一个数的奇偶）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n &amp; 1 === 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> &amp; <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> &amp; <span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原因：所有偶数的最低位都是0，所有奇数的最低位都是1。</span></span><br><span class="line"><span class="comment">实例1：</span></span><br><span class="line"><span class="comment">16 = 10000</span></span><br><span class="line"><span class="comment">1 =  00001</span></span><br><span class="line"><span class="comment">     00000 = 0</span></span><br><span class="line"><span class="comment">实例2：</span></span><br><span class="line"><span class="comment">15 = 1111</span></span><br><span class="line"><span class="comment">1 =  0001</span></span><br><span class="line"><span class="comment">     0001 = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>例子 2（判断一个数是否为 2 的整数幂）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n &amp; (n-1) === 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span> &amp; (<span class="number">4</span> - <span class="number">1</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> &amp; (<span class="number">5</span> - <span class="number">1</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原因：如果是2的幂，n 一定是 100...，而 n-1 一定是 111...</span></span><br><span class="line"><span class="comment">实例1：</span></span><br><span class="line"><span class="comment">16 = 10000</span></span><br><span class="line"><span class="comment">15 = 01111</span></span><br><span class="line"><span class="comment">     00000 = 0</span></span><br><span class="line"><span class="comment">实例1：</span></span><br><span class="line"><span class="comment">15 = 1111</span></span><br><span class="line"><span class="comment">14 = 1110</span></span><br><span class="line"><span class="comment">     1110 = 14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-OR（或）"><a href="#2-2-2-OR（或）" class="headerlink" title="2.2.2 OR（或）"></a>2.2.2 OR（或）</h4><p>对每一对比特位执行或（OR）操作。只有 a 或者 b 中至少有一位是 1 时， <code>a</code> OR <code>b</code> 才为 1。或操作的真值表：</p><table><thead><tr><th>a</th><th>b</th><th>a OR b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>下面展示<code>11 | 14</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 = 0000 1011</span><br><span class="line">14 = 0000 1110</span><br><span class="line">     0000 1111 = 15</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>任何数和 0 进行 OR 都为自身：<code>x | 0 = x</code>。</li><li>任何数和 -1 进行 OR 都为 -1：<code>x | -1 = -1</code>。</li></ul><h4 id="2-2-3-XOR（异或）"><a href="#2-2-3-XOR（异或）" class="headerlink" title="2.2.3 XOR（异或）"></a>2.2.3 XOR（异或）</h4><p>对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，<code>a</code> XOR <code>b</code> 的结果为 1。异或操作真值表：</p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">a XOR b</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>下面展示<code>11 ^ 14</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 = 0000 1011</span><br><span class="line">14 = 0000 1110</span><br><span class="line">     0000 0101 = 5</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>任何数和 0 进行 XOR 都为自身：<code>x ^ 0 = x</code>。</li><li>任何数和 -1 进行 OR 都为 ~x：<code>x | -1 = ~x</code>。</li></ul><p>例子 1（不用临时变量交换两个数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>,</span><br><span class="line">  b = <span class="number">20</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 20,10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原因（公式）：</span></span><br><span class="line"><span class="comment">20 ^ 10 = 30 # c = a ^ b</span></span><br><span class="line"><span class="comment">30 ^ 20 = 10 # b = c ^ a</span></span><br><span class="line"><span class="comment">30 ^ 10 = 20 # a = c ^ b</span></span><br><span class="line"><span class="comment">实例：</span></span><br><span class="line"><span class="comment">a = 01010</span></span><br><span class="line"><span class="comment">b = 10100</span></span><br><span class="line"><span class="comment">c = 11110 # a ^ b的结果，其中的1是 a 和 b 中不同的部分</span></span><br><span class="line"><span class="comment">d = 01010 # b ^ c的结果，有没有发现和a是一样的</span></span><br><span class="line"><span class="comment">e = 10100 # c ^ d的结果，有没有发现是b是一样的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a = a ^ b # 得到c 11110</span></span><br><span class="line"><span class="comment">b = b ^ a # 得到d 01010</span></span><br><span class="line"><span class="comment">a = a ^ b # 得到e 10100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>例子 2（找到数组中出现奇数次的元素）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个非空数组，只有一个元素出现奇数次，其余出现偶数次，找出那个元素:</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  res ^= arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，</span></span><br><span class="line"><span class="comment">   那么最终的结果刚好是那个只出现奇数次的数字，因为那些出现偶数次的数字全部在异或中抵消掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-2-4-NOT（非）"><a href="#2-2-4-NOT（非）" class="headerlink" title="2.2.4 NOT（非）"></a>2.2.4 NOT（非）</h4><p>对每一个比特位执行非（NOT）操作。NOT <code>a</code> 结果为 a 的反转（即反码）。非操作的真值表：</p><table><thead><tr><th align="center">a</th><th align="center">NOT a</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>下面展示<code>~11</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11 = [0000 1011‬]原</span><br><span class="line">   = [0000 1011‬]反</span><br><span class="line">   = [‭0000 1011]补 # 将操作数转成补码</span><br><span class="line"> -----------------------------</span><br><span class="line">     [‭0000 1011]补</span><br><span class="line">   = [1111 0100]补 # 然后按位取反</span><br><span class="line"> -----------------------------</span><br><span class="line">     [1111 0100]补</span><br><span class="line">   = [1111 0011]反</span><br><span class="line">   = [1000 1100]原 # 转成原码</span><br><span class="line">   = -12</span><br></pre></td></tr></table></figure><p>接着展示<code>~-11</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-11 = [1000 1011‬]原</span><br><span class="line">    = [1111 0100‬]反</span><br><span class="line">    = [‭1111 0101]补 # 将操作数转成补码</span><br><span class="line"> -----------------------------</span><br><span class="line">      [‭1111 0101]补</span><br><span class="line">    = [0000 1010]补 # 然后按位取反</span><br><span class="line"> -----------------------------</span><br><span class="line">      [0000 1010]补</span><br><span class="line">    = [0000 1010]反</span><br><span class="line">    = [0000 1010]原 # 转成原码</span><br><span class="line">    = 10</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>对任何数 x 进行 NOT 操作的结果为 -(x + 1)，<code>~x = -(x+1)</code>。</li></ul><h3 id="2-3-按位移动操作符"><a href="#2-3-按位移动操作符" class="headerlink" title="2.3 按位移动操作符"></a>2.3 按位移动操作符</h3><p>按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。</p><p>按位移动会先将操作数转换为高位字节顺序的 32 位整数，并返回与左操作符相同的类型。右操作数小于 32 位，否则只有最低 5 个字节会被使用。</p><h4 id="2-3-1-lt-lt-（左移）"><a href="#2-3-1-lt-lt-（左移）" class="headerlink" title="2.3.1 &lt;&lt;（左移）"></a>2.3.1 &lt;&lt;（左移）</h4><p>该操作数会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</p><p>下面展示<code>11&lt;&lt;2</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 = [0000 1011]原</span><br><span class="line">   = [0000 1011]反</span><br><span class="line">   = [0000 1011]补</span><br><span class="line">---------------------------------</span><br><span class="line">      0000 1011</span><br><span class="line">   00 0010 1100 # 向左移2位，用0补充</span><br><span class="line">      1101 0100 # 被移出的位被丢弃</span><br><span class="line">---------------------------------</span><br><span class="line">     [1101 0100]补</span><br><span class="line">   = [1101 0011]反</span><br><span class="line">   = [1010 1100]原 # 转成原码</span><br><span class="line">   = -44</span><br></pre></td></tr></table></figure><p>接着是<code>-11&lt;&lt;2</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 = [1000 1011]原</span><br><span class="line">   = [1111 0100]反</span><br><span class="line">   = [1111 0101]补</span><br><span class="line">---------------------------------</span><br><span class="line">      1111 0101</span><br><span class="line">   11 1101 0100 # 向左移2位，用0补充</span><br><span class="line">      1101 0100 # 被移出的位被丢弃</span><br><span class="line">---------------------------------</span><br><span class="line">     [1101 0100]补</span><br><span class="line">   = [1101 0011]反</span><br><span class="line">   = [1010 1100]原 # 转成原码</span><br><span class="line">   = -44</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在数字 x 上左移 y 位得到 x * 2y：<code>x &lt;&lt; y === x * pow(2,y)</code>。</li></ul><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获得 int 型最大值</span></span><br><span class="line"><span class="built_in">console</span>.log(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) <span class="comment">// 2147483647</span></span><br><span class="line"><span class="comment">// 2.获得 int 型最小值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// 3.乘以2的m次方</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="number">1</span> * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)) <span class="comment">// 1024,1024</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-gt-gt-（有符号右移）"><a href="#2-3-2-gt-gt-（有符号右移）" class="headerlink" title="2.3.2 &gt;&gt;（有符号右移）"></a>2.3.2 &gt;&gt;（有符号右移）</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。</p><p>下面展示<code>11&gt;&gt;2</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 = [0000 1011]原</span><br><span class="line">   = [0000 1011]反</span><br><span class="line">   = [0000 1011]补</span><br><span class="line">---------------------------------</span><br><span class="line">      0000 1011</span><br><span class="line">      0000 0010 11 # 向右移2位，填充最左侧的值</span><br><span class="line">      0000 0010 # 被移出的位被丢弃</span><br><span class="line">---------------------------------</span><br><span class="line">     [0000 0010]补</span><br><span class="line">   = [0000 0010]反</span><br><span class="line">   = [0000 0010]原 # 转成原码</span><br><span class="line">   = 2</span><br></pre></td></tr></table></figure><p>接着是<code>-11&gt;&gt;2</code>的运算过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 = [1000 1011]原</span><br><span class="line">   = [1111 0100]反</span><br><span class="line">   = [1111 0101]补</span><br><span class="line">---------------------------------</span><br><span class="line">      1111 0101</span><br><span class="line">      1111 1101 01 # 向右移2位，填充最左侧的值</span><br><span class="line">      1111 1101 # 被移出的位被丢弃</span><br><span class="line">---------------------------------</span><br><span class="line">     [1111 1101]补</span><br><span class="line">   = [1111 1100]反</span><br><span class="line">   = [1000 0011]原 # 转成原码</span><br><span class="line">   = -3</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.求两个整数的平均值（结果有小数点时抛弃小数点）</span></span><br><span class="line"><span class="built_in">console</span>.log(  （<span class="number">1</span> + <span class="number">4</span>） &gt;&gt; <span class="number">1</span> ) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2.除以2的m次方</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> &gt;&gt; <span class="number">10</span>, <span class="number">1</span> * <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>) ) <span class="comment">// 1024,1024</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-gt-gt-gt-（无符号右移）"><a href="#2-3-3-gt-gt-gt-（无符号右移）" class="headerlink" title="2.3.3 &gt;&gt;&gt;（无符号右移）"></a>2.3.3 &gt;&gt;&gt;（无符号右移）</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用 0 填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</p><p>对于非负数，有符号右移和无符号右移总是返回相同的结果。例如：<code>11 &gt;&gt; 2 === 11 &gt;&gt;&gt; 2</code>。</p><p>而对于负数却不尽相同，下面展示<code>-11&gt;&gt;&gt;2</code>的运算过程（这里需要用到的位数较多，所以用 32 位整数演示）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-11 = [‭1000 0000 0000 0000 0000 0000 0000 1011]原</span><br><span class="line">    = [‭1111 1111 1111 1111 1111 1111 1111 0100]反</span><br><span class="line">    = [‭1111 1111 1111 1111 1111 1111 1111 0101]补</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">       ‭1111 1111 1111 1111 1111 1111 1111 0101</span><br><span class="line">       0011 1111 1111 1111 1111 1111 1111 1101 01 # 向右移2位，左侧填充0</span><br><span class="line">       0011 1111 1111 1111 1111 1111 1111 1101 # 被移出的位被丢弃</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">      [0011 1111 1111 1111 1111 1111 1111 1101]补</span><br><span class="line">    = [0011 1111 1111 1111 1111 1111 1111 1101]补</span><br><span class="line">    = [0011 1111 1111 1111 1111 1111 1111 1101]原 # 转成原码</span><br><span class="line">    = 1073741821</span><br></pre></td></tr></table></figure><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul><li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解</a></li><li><a href="https://blog.csdn.net/oscar999/article/details/8928789">真值，原码，反码，补码和移码 释义</a></li><li><a href="https://yanhaijing.com/javascript/2016/07/20/binary-in-js/">聊聊 JavaScript 中的二进制数</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">按位操作符 MDN</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/6275483.html">JS 按位非(~)运算符与~~运算符的理解分析</a></li><li><a href="https://blog.csdn.net/zmazon/article/details/8262185">优秀程序员不得不知道的 20 个位运算技巧</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window上更方便的软件安装方式 — Chocolatey</title>
      <link href="//post/8159b49a.html"/>
      <url>//post/8159b49a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在经历了多次重装系统、重新安装各种常用软件后，我突然萌生了一个想法，难道 Window 就没有一个像 Linux 一样可以使用一行命令安装软件的包管理器吗？</p><p>答案是：有的。</p><p>我分别使用了 Chocolatey 和 Scoop，得出的结论就是：</p><ol><li>Chocolatey : 软件更多、速度快。</li><li>Scoop：可定制性较强、速度较慢（也有可能是我网络不好）。</li></ol><p>不过这两款包管理器的使用都差不多，这里主要是介绍 Chocolatey，对其他包管理器感兴趣的可以自行查看。</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>安装 Chocolatey 前，你需要对检查一下自身系统是否达到所需的要求。</p><ul><li>Windows 7+ / Windows Server 2003+</li><li>PowerShell v2+</li><li>.NET Framework 4+</li></ul><p>如果已经满足要求，就可以打开命令行 copy 下面的命令执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;(iex ((new-object net.webclient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))) &gt;$null 2&gt;&amp;1&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</span><br></pre></td></tr></table></figure><p>如果没报红字错误，应该是安装成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.10.11</span></span><br></pre></td></tr></table></figure><p>接下来你可以打开下方的链接，查看一下可以安装的软件列表。</p><p><a href="https://chocolatey.org/packages">https://chocolatey.org/packages</a></p><p>比如，安装 Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install git</span><br></pre></td></tr></table></figure><p>安装 Node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install nodejs.install</span><br></pre></td></tr></table></figure><p>也可以加上<code>-y</code>，安装时就不需要等待确认了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install firefox -y</span><br></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>安装 <code>choco install baretail</code></li><li>升级 <code>choco upgrade baretail</code></li><li>卸载 <code>choco uninstall baretail</code></li><li>搜索 <code>choco search something</code></li><li>列出已安装 <code>choco list -lo</code></li></ol><p>关于更多用法可点击以下链接查看：</p><p><a href="https://chocolatey.org/docs">https://chocolatey.org/docs</a></p><h2 id="修改默认安装目录"><a href="#修改默认安装目录" class="headerlink" title="修改默认安装目录"></a>修改默认安装目录</h2><p>但是，Chocolatey 安装的软件默认存放在 C 盘，对于我这种不太喜欢把软件装到 C 盘的人来说是不能忍的。</p><p>虽然 Chocolatey 自己提供了一个修改默认安装目录的命令，但是需要注册（收费），对于资金充裕的同学我还是建议使用这种方法。</p><p>这里我提供另外一个思路，既然他存到默认安装目录，那我们把这个默认安装目录改一下就好了。</p><p>比如我要默认存放到<code>E</code>盘，打开注册表，把 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion</code> 下的：</p><ol><li><code>ProgramFilesDir</code>的值改为：<code>E:\Program Files</code></li><li><code>ProgramFilesDir (x86)</code>的值改为：<code>E:\Program Files (x86)</code></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些好用的 Chrome 扩展</title>
      <link href="//post/549a6198.html"/>
      <url>//post/549a6198.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用浏览器扩展程序可以使你的工作效率提高数倍不止，那么下面我就向大家分享一下我日常使用的扩展，可能大多数扩展大家都已经在使用了，不过也难免有一两个是你不知道的。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>以下排名并不分先后，请坚持看到最后，或许你会有惊喜。</p></blockquote><h3 id="1-谷歌访问助手"><a href="#1-谷歌访问助手" class="headerlink" title="1.谷歌访问助手"></a>1.谷歌访问助手</h3><p>本来想了一波广告词来吹它，但想到…</p><p>算了，别问，问就是好用。</p><p><strong>注</strong>：装了这个就可以访问之后介绍的扩展链接了。</p><blockquote><p>链接：<a href="http://www.ggfwzs.com/">谷歌访问助手</a></p></blockquote><h3 id="2-新浪微博图床"><a href="#2-新浪微博图床" class="headerlink" title="2. 新浪微博图床"></a>2. 新浪微博图床</h3><p>感谢新浪微博提供的免费图床（对外链无限制），以及吊炸天的 cdn 图片加速服务，从此妈妈再也不用担心我的图床不能用了，另外还支持在网页图片右键菜单中一键上传。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04uhwp8ozj30hs0b4aal.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf">新浪微博图床</a></p></blockquote><h3 id="3-AdBlock"><a href="#3-AdBlock" class="headerlink" title="3. AdBlock"></a>3. AdBlock</h3><p>最受欢迎的 Chrome 扩展，拥有超过 6000 万用户！拦截网页上的广告。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04un3rn1fj30hs0b4ac4.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom">AdBlock</a></p></blockquote><h3 id="4-WEB-前端助手"><a href="#4-WEB-前端助手" class="headerlink" title="4. WEB 前端助手"></a>4. WEB 前端助手</h3><p>前端神器，包括 JSON 格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown 与 HTML 互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax 接口调试、密码生成器、JSON 比对工具、网页编码设置、便签笔记。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04zik8xc7j31460lm41y.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad">WEB 前端助手</a></p></blockquote><h3 id="5-JSON-Viewer"><a href="#5-JSON-Viewer" class="headerlink" title="5. JSON Viewer"></a>5. JSON Viewer</h3><p>前面介绍的 WEB 前端工具也有 JSON 查看工具，但是它那个太丑了，所以我用这个，内置多种主题，是我见过最好看的 JSON 查看工具。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04z6k4eubj31460lm76k.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh">JSON Viewer</a></p></blockquote><h3 id="6-Standardized-Screenshot"><a href="#6-Standardized-Screenshot" class="headerlink" title="6. Standardized Screenshot"></a>6. Standardized Screenshot</h3><p>一个非常好用的截图扩展，自动加上 macOS 的标题栏、以及阴影，配合微博图床一键上传根本不用保存在本地。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04v1q134fj31460lmzlf.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/pabdhaakclnechgfhmnhkcbmjobeoope">Standardized Screenshot</a></p></blockquote><h3 id="7-Chromoji-Emoji"><a href="#7-Chromoji-Emoji" class="headerlink" title="7. Chromoji - Emoji"></a>7. Chromoji - Emoji</h3><p>在某些系统中并不能显示 Emoji 表情，安装此扩展后就能在浏览器中显示和输入，你也能选择显示 Apple 或 Google 风格的 Emoji。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04x45wnh6j31460lmjvq.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/chromoji-emoji-for-google/cahedbegdkagmcjfolhdlechbkeaieki">Chromoji - Emoji</a></p></blockquote><h3 id="8-Clear-Cache"><a href="#8-Clear-Cache" class="headerlink" title="8. Clear Cache"></a>8. Clear Cache</h3><p>如果你是前端开发人员，调试时需要经常清空浏览器缓存，以往我们需要经过几个步骤才能完成动作，现在只需单击一下按钮即可清除缓存和浏览数据。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04w1j4tumj31460lmwg3.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/clear-cache/cppjkneekbjaeellbfkmgnhonkkjfpdn">Clear Cache</a></p></blockquote><h3 id="9-二维码生成器"><a href="#9-二维码生成器" class="headerlink" title="9. 二维码生成器"></a>9. 二维码生成器</h3><p>把当前页面或者你输入的任何内容转化成二维码，生成后的二维码可以保存，并且无需联网，谁用谁知道。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04wsm1d8yj31460lmdhx.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp?hl=zh-CN">二维码生成器</a></p></blockquote><h3 id="10-翻译侠"><a href="#10-翻译侠" class="headerlink" title="10. 翻译侠"></a>10. 翻译侠</h3><p>这是我用了众多翻译扩展后最喜欢的一个，貌似之前的作者已经不再维护了，现在由网友接手，挺好的，从此不再需要打开谷歌翻译网站。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04xejq3ocj31460lmajm.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/translate-man/fnjoonbenhhijnoegpfkpagjamomgjjm/related?hl=zh-CN">翻译侠</a></p></blockquote><h3 id="11-图流"><a href="#11-图流" class="headerlink" title="11. 图流"></a>11. 图流</h3><p>这个厉害了，你是否曾为了看图片，一张一张的点，看完一个系列手都费了，简直痛不欲生，现在，福音来了。</p><p>让我们打开知乎问题《<a href="https://www.zhihu.com/question/50426133/answer/243675284">平常人可以<em>漂亮</em>到什么程度？</a>》，查看全部答案，开启图流，你会发现。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04xrb65foj31460lm7wh.jpg"></p><p>另外它还支持轮播展示，如果你经常逛一些你懂得网站，那它简直是老司机神器。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/%E5%9B%BE%E6%B5%81-%E7%9C%8B%E5%9B%BE%E5%8A%A9%E6%89%8B/gpcdnjdgomhddecjpknmfodkpkgibajh?utm_source=chrome-ntp-icon">图流</a></p></blockquote><h3 id="12-阅读模式"><a href="#12-阅读模式" class="headerlink" title="12. 阅读模式"></a>12. 阅读模式</h3><p>提供与 Safari 阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。</p><p>唯一美中不足之处就是在阅读模式下无法选中文字（更不能使用划词翻译）。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04y2ubyw8j31460lm76c.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl">阅读模式</a></p></blockquote><h3 id="13-Octotree"><a href="#13-Octotree" class="headerlink" title="13. Octotree"></a>13. Octotree</h3><p>这个估计不少人知道，它可以在 GitHub 左侧显示当前项目的目录结构，能轻松找到代码的位置。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04ybfedo9j31460lmwhn.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a></p></blockquote><h3 id="14-Enhanced-Github"><a href="#14-Enhanced-Github" class="headerlink" title="14. Enhanced Github"></a>14. Enhanced Github</h3><p>这个可以在 GitHub 中显示仓库大小，每个文件的大小，下载链接和复制文件内容的选项。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04yg4kl8pj31460lm76j.jpg"></p><p>要是能够支持单文件夹下载那就更好了。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/enhanced-github/anlikcnbgdeidpacdbdljnabclhahhmd">Enhanced Github</a></p></blockquote><h3 id="15-Isometric-Contributions"><a href="#15-Isometric-Contributions" class="headerlink" title="15. Isometric Contributions"></a>15. Isometric Contributions</h3><p>装 X 神器，值得拥有。这里放上我心中的偶像 Linus 的贡献图。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g04ylt3ugmj31460lmtay.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions</a></p></blockquote><h3 id="16-Git-History"><a href="#16-Git-History" class="headerlink" title="16. Git History"></a>16. Git History</h3><p>这个扩展可以很炫酷地展示 GitHub 中任意一个文件的历史修改情况。</p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/git-history-browser-exten/laghnmifffncfonaoffcndocllegejnf">Git History</a></p></blockquote><h3 id="17-Tampermonkey"><a href="#17-Tampermonkey" class="headerlink" title="17. Tampermonkey"></a>17. Tampermonkey</h3><p>油猴怕是没有人不知道，它基本上是所有扩展中的佼佼者了。这里给两个可以发现好用的脚本的网站：</p><ul><li><a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a></li><li><a href="https://openuserjs.org/">https://openuserjs.org/</a></li></ul><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a></p></blockquote><h3 id="18-Stylus"><a href="#18-Stylus" class="headerlink" title="18. Stylus"></a>18. Stylus</h3><p>其实类似的扩展还有 Stylish，但它会窃取用户的浏览历史（虽然某位药王说我们更愿意用隐私换便利）。</p><p>而 Stylus 就不会。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g051rdn2pqj31460lmjtk.jpg"></p><blockquote><p>链接：<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Stylus</a></p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如何你觉得安装太多扩展后严重挤占地址栏的话，可以使用隐藏扩展+快键键的方式。</p><p>最后，如果你也有一些好用的扩展，不妨向我推荐下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
            <tag> Chrome 扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel Eloquent 时间日期比较和分组</title>
      <link href="//post/3e85f2e1.html"/>
      <url>//post/3e85f2e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个订单日收入模块的时候，涉及到日期比较和分组查询的问题，经过一番探索，总算是找到了解决方法，特地记录一下，以方便日后翻阅。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>假设我们有一个<code>orders</code>表，数据如下：</p><table><thead><tr><th align="center">id</th><th align="center">amout</th><th align="center">created_at</th><th align="center">updated_at</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">100</td><td align="center">2019-01-01</td><td align="center">2019-01-01</td></tr><tr><td align="center">2</td><td align="center">100</td><td align="center">2019-01-01</td><td align="center">2019-01-01</td></tr><tr><td align="center">3</td><td align="center">200</td><td align="center">2019-01-02</td><td align="center">2019-01-02</td></tr><tr><td align="center">4</td><td align="center">200</td><td align="center">2019-01-02</td><td align="center">2019-01-02</td></tr><tr><td align="center">5</td><td align="center">300</td><td align="center">2019-01-03</td><td align="center">2019-01-03</td></tr></tbody></table><p>然后我们有以下需求：</p><ol><li>获取每天的收入情况。</li><li>查询某个日期段（或者是某天）的订单，并显示各天的收入情况。</li></ol><h3 id="获取每天的收入情况"><a href="#获取每天的收入情况" class="headerlink" title="获取每天的收入情况"></a>获取每天的收入情况</h3><p>其实这个问题的难点就在于如何按照日期来分组，我的解决方案如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getIncome</span>(<span class="params">Request <span class="variable">$request</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$list</span> = Order::query() <span class="comment">// 这里可以用 where 先限制一些条件</span></span><br><span class="line">                -&gt;select(</span><br><span class="line">                    DB::raw(<span class="string">&#x27;Date(created_at) as date&#x27;</span>),</span><br><span class="line">                    DB::raw(<span class="string">&#x27;COUNT(id) as count&#x27;</span>),</span><br><span class="line">                    DB::raw(<span class="string">&#x27;SUM(amount) as income&#x27;</span>)</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$list</span>-&gt;groupBy(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">                -&gt;orderBy(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;DESC&#x27;</span>)</span><br><span class="line">                -&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2019-01-03&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;income&quot;</span>: <span class="number">300</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2019-01-02&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;income&quot;</span>: <span class="number">400</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2019-01-01&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;income&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="获取某个日期段的各天收入情况"><a href="#获取某个日期段的各天收入情况" class="headerlink" title="获取某个日期段的各天收入情况"></a>获取某个日期段的各天收入情况</h3><p>这里就涉及到日期比较了，因此我们可以使用<code>whereDate</code>方法。</p><p><strong>注</strong> ：</p><blockquote><p><code>whereDate</code>方法只能在 <code>Laravel 5.0</code>之后才能使用。</p><p>关于更多类似日期方法可以访问: <a href="https://www.cnblogs.com/huangshoushi/p/5875022.html">链接</a></p></blockquote><p>我们需要接受两个参数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getIncome</span>(<span class="params">Request <span class="variable">$request</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$list</span> = Order::query() <span class="comment">// 这里可以用 where 先限制一些条件</span></span><br><span class="line">                -&gt;select(</span><br><span class="line">                    DB::raw(<span class="string">&#x27;Date(created_at) as date&#x27;</span>),</span><br><span class="line">                    DB::raw(<span class="string">&#x27;COUNT(id) as count&#x27;</span>),</span><br><span class="line">                    DB::raw(<span class="string">&#x27;SUM(amount) as income&#x27;</span>)</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request</span>-&gt;has(<span class="string">&#x27;date&#x27;</span>))&#123;</span><br><span class="line">            <span class="variable">$date</span> = <span class="variable">$request</span>-&gt;input(<span class="string">&#x27;date&#x27;</span>);</span><br><span class="line">            <span class="variable">$list</span> = <span class="variable">$list</span>-&gt;whereDate(<span class="string">&#x27;created_at&#x27;</span>,<span class="string">&#x27;&gt;=&#x27;</span>,<span class="variable">$date</span>[<span class="number">0</span>])</span><br><span class="line">                         -&gt;whereDate(<span class="string">&#x27;created_at&#x27;</span>,<span class="string">&#x27;&lt;=&#x27;</span>,<span class="variable">$date</span>[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$list</span>-&gt;groupBy(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">                -&gt;orderBy(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;DESC&#x27;</span>)</span><br><span class="line">                -&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2019-01-02&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;income&quot;</span>: <span class="number">400</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2019-01-01&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;income&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="获取当天"><a href="#获取当天" class="headerlink" title="获取当天"></a>获取当天</h4><p>获取当天可以这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Order-&gt;whereDate(<span class="string">&#x27;created_at&#x27;</span>, date(<span class="string">&quot;Y-m-d&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="满足其他条件"><a href="#满足其他条件" class="headerlink" title="满足其他条件"></a>满足其他条件</h4><p>假设我们还要当天总收入超过多少才行，我们可以这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list</span> = <span class="variable">$list</span>-&gt;havingRaw(<span class="string">&#x27;SUM(amount) &#x27;</span> . <span class="string">&#x27;&gt;&#x27;</span> . <span class="string">&#x27; &#x27;</span> . <span class="variable">$minAmount</span>);</span><br></pre></td></tr></table></figure><p>或者需要当订单数量超过多少：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list</span> = <span class="variable">$list</span>-&gt;havingRaw(<span class="string">&#x27;COUNT(id) &#x27;</span> . <span class="string">&#x27;&gt;&#x27;</span> . <span class="string">&#x27; &#x27;</span> . <span class="variable">$minCount</span>);</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当然，我这个可能不是最佳方案，如果您有更好的方法，还请多多指教。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些好用的网站</title>
      <link href="//posts/share-site.html"/>
      <url>//posts/share-site.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两年收藏了不少网站，特地整理一下，把一些大家都可能用得上的分享出来，希望能对你有用。</p><p>考虑到有一些网站大多数人都知道，所以我就不列出来了。</p><p>我把这些网站分为了几大类：</p><ul><li>工具类</li><li>素材类</li><li>社区类</li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="1、start-me（收藏工具）"><a href="#1、start-me（收藏工具）" class="headerlink" title="1、start.me（收藏工具）"></a>1、start.me（收藏工具）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kfsb325j31460lm78s.jpg"></p><p>它不仅仅是一个网址收藏管理器，它还可以：推送、嵌入任何东西、集成、自定义、分享你的收藏夹、浏览器扩展。</p><p>很明显本文所分享的网站就是靠它来保存的，用它的理由两个就够了：</p><ol><li>可以在不同设备中共享书签。</li><li>域名好记。</li></ol><blockquote><p>网站链接：<a href="https://start.me/">https://start.me</a></p></blockquote><h3 id="2、Placemat（快速生成占位图片器）"><a href="#2、Placemat（快速生成占位图片器）" class="headerlink" title="2、Placemat（快速生成占位图片器）"></a>2、Placemat（快速生成占位图片器）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01kofjhs1j31460lm0v6.jpg"></p><p>如果你是前端，就有可能会遇到需要占位图来填充网页的情况，而 Placemat 就是用来生成占位图的。</p><p>最基本的用法是：给定参数<code>w</code>或<code>h</code>，Placemat 会随机返回相应尺寸的图片，其他用法自行探究。</p><p>使用 Placemat 的好处显而易见。</p><blockquote><p>网站链接：<a href="https://placem.at/">https://placem.at</a></p></blockquote><h3 id="3、Carbon（代码界美图秀秀）"><a href="#3、Carbon（代码界美图秀秀）" class="headerlink" title="3、Carbon（代码界美图秀秀）"></a>3、Carbon（代码界美图秀秀）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01l4ctkw0j31460lm40t.jpg"></p><p>这个无需多言，明眼人一看就知道是用来装什么的 :)</p><blockquote><p>网站链接：<a href="https://carbon.now.sh/">https://carbon.now.sh</a></p></blockquote><h3 id="4、TinyPNG（在线压缩图片）"><a href="#4、TinyPNG（在线压缩图片）" class="headerlink" title="4、TinyPNG（在线压缩图片）"></a>4、TinyPNG（在线压缩图片）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01l85eym5j31460lmqgs.jpg"></p><p>图片压缩界的一哥了，支持同时上传多张图片。很好用，压缩率也很高，最重要的是，速度很快。</p><blockquote><p>网站链接：<a href="https://tinypng.com/">https://tinypng.com</a></p></blockquote><h3 id="5、两个在线截图工具"><a href="#5、两个在线截图工具" class="headerlink" title="5、两个在线截图工具"></a>5、两个在线截图工具</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01lebp7hsj31460lm0ur.jpg"></p><p>BrowserFrame 是一个生成浏览器外壳的网站，它提供了两种方式来生成截图，分别是：</p><ol><li>上传本地截图</li><li>输入网址生成截图（可能挂了，经常不成功）</li></ol><p><strong>注：</strong>推荐另一个功能类似的网站 Screen Guru，它可以实现通过网址生成截图功能，看下图。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01lqsaguqj315s0sa0uf.jpg"></p><p>这样截图逼格瞬间提升百倍有木有 :)</p><blockquote><p>网站链接 1：<a href="https://browserframe.com/">https://browserframe.com</a></p><p>网站链接 2：<a href="https://screen.guru/">https://screen.guru</a></p></blockquote><h3 id="6、ColorSpark（在线随机颜色）"><a href="#6、ColorSpark（在线随机颜色）" class="headerlink" title="6、ColorSpark（在线随机颜色）"></a>6、ColorSpark（在线随机颜色）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m1i2yflj31460lmmy5.jpg"></p><p>随机生成好看的颜色、渐变色，可以一键复制 CSS 代码。</p><blockquote><p>网站链接：<a href="https://colorspark.app/">https://colorspark.app</a></p></blockquote><h3 id="7、FontSpark（在线预览字体）"><a href="#7、FontSpark（在线预览字体）" class="headerlink" title="7、FontSpark（在线预览字体）"></a>7、FontSpark（在线预览字体）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m2n6sy4j31460lm0ts.jpg"></p><p>随机字体在线预览，用过都说好。</p><blockquote><p>网站链接：<a href="https://fontspark.app/">https://fontspark.app</a></p></blockquote><h3 id="8、easy-PDF（在线-PDF-工具）"><a href="#8、easy-PDF（在线-PDF-工具）" class="headerlink" title="8、easy PDF（在线 PDF 工具）"></a>8、easy PDF（在线 PDF 工具）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01m69eod2j31460lmwg6.jpg"></p><p>功能看上图。</p><blockquote><p>网站链接：<a href="https://easypdf.com/cn">https://easypdf.com/cn</a></p></blockquote><h2 id="素材类"><a href="#素材类" class="headerlink" title="素材类"></a>素材类</h2><h3 id="1、觅元素（免抠素材）"><a href="#1、觅元素（免抠素材）" class="headerlink" title="1、觅元素（免抠素材）"></a>1、觅元素（免抠素材）</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01mae8r2xj31460lmapg.jpg"></p><p>在国内算是相对良心的网站了，一天有 5 次免费下载机会，上面素材质量很高，简直是做 PPT 必备。</p><blockquote><p>网站链接：<a href="http://www.51yuansu.com/">http://www.51yuansu.com</a></p></blockquote><h3 id="2、高清无版权图片网站"><a href="#2、高清无版权图片网站" class="headerlink" title="2、高清无版权图片网站"></a>2、高清无版权图片网站</h3><p>这里只列出国内访问速度还算可以的，但是不一一贴图了，有兴趣可以自行查看。</p><ol><li><a href="https://www.pexels.com/">Pexels</a></li><li><a href="https://picjumbo.com/">Picjumbo</a></li><li><a href="https://magdeleine.co/">Magdeleine</a></li><li><a href="https://pixabay.com/">Pixabay</a></li><li><a href="https://www.ssyer.com/home">Ssyer</a></li><li><a href="https://www.lifeofpix.com/">Lifeofpix</a></li></ol><h3 id="3、UI-设计师导航"><a href="#3、UI-设计师导航" class="headerlink" title="3、UI 设计师导航"></a>3、UI 设计师导航</h3><p>想看更多的可以去这几个导航看看。</p><ol><li><a href="http://so.uigreat.com/">http://so.uigreat.com/</a></li><li><a href="http://hao.shejidaren.com/">http://hao.shejidaren.com/</a></li><li><a href="http://hao.uisdc.com/">http://hao.uisdc.com/</a></li><li><a href="http://www.tuyiyi.com/hao/">http://www.tuyiyi.com/hao/</a></li></ol><h2 id="社区类"><a href="#社区类" class="headerlink" title="社区类"></a>社区类</h2><h3 id="1、CSS-TRICKS"><a href="#1、CSS-TRICKS" class="headerlink" title="1、CSS-TRICKS"></a>1、CSS-TRICKS</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nfctm73j31460lmqal.jpg"></p><p>一个国外的优秀前端开发博客，主要分享使用 CSS 样式的技巧，经验和教程等。值得前端开发者阅读收藏的国外网站。</p><blockquote><p>网站链接：<a href="https://css-tricks.com/">https://css-tricks.com</a></p></blockquote><h3 id="2、踏得网"><a href="#2、踏得网" class="headerlink" title="2、踏得网"></a>2、踏得网</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01ni3d6wpj31460lmjwh.jpg"></p><p>算是国内版的 <a href="https://codepen.io/">CodePen</a>，其中不乏一些惊艳的动画、特性。</p><h3 id="3、免费资源网络社区"><a href="#3、免费资源网络社区" class="headerlink" title="3、免费资源网络社区"></a>3、免费资源网络社区</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nm0f36ej31460lmaf0.jpg"></p><p>免费资源网络社区是一个以免费为主题的台湾网站、部落格，内容包含科技新知、免费软体、线上工具、图库素材、WordPress 架站及应用程式介绍教学。</p><p>我不会告诉你上面大多数网站都是从这里看到的。</p><blockquote><p>网站链接：<a href="https://free.com.tw/">https://free.com.tw</a></p></blockquote><h3 id="4、前端里"><a href="#4、前端里" class="headerlink" title="4、前端里"></a>4、前端里</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01nnppxtrj31460lm49o.jpg"></p><p>前端里专注于分享最前沿的 Web 开发技术，教程，资源和素材，是面向网站开发人员和设计师的学习交流平台。</p><blockquote><p>网站链接：<a href="http://www.yyyweb.com/">http://www.yyyweb.com</a></p></blockquote><h3 id="5、伯乐在线"><a href="#5、伯乐在线" class="headerlink" title="5、伯乐在线"></a>5、伯乐在线</h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1g01no7r779j31460lmwgo.jpg"></p><p>伯乐在线资源收录各种开发、设计、系统管理与安全相关的工具与资源。</p><blockquote><p>网站链接：<a href="http://hao.jobbole.com/">http://hao.jobbole.com</a></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>拥有自己的工具箱可以有效地提高你的工作效率，从而有更多的时间投入到真正开发之中。</p><p>下一篇，我打算分享一些我在 Chrome 中常用的那些扩展（本文截图使用的工具就是 Chrome 的扩展，Standardized Screenshot）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Element UI + Lumen 实现通用表格功能 - 分页</title>
      <link href="//post/64f1da47.html"/>
      <url>//post/64f1da47.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个前后端分离的项目，前端使用 <code>Vue</code>+ <code>Element UI</code>，而后端则使用 <code>Lumen</code> 做接口开发，其中分页是必不可少的一部分，本文就介绍如何基于以上环境做一个简单、可复用的分页功能。</p><h2 id="先说后端"><a href="#先说后端" class="headerlink" title="先说后端"></a>先说后端</h2><p>后端做的事情不多，只需要接受几个参数，根据参数来获取数据即可。</p><p>需要获取的参数如下：</p><ul><li><code>pageSize</code>（一页数据的数量）</li><li><code>pageIndex</code>（第几页的数据）</li></ul><p>然后就可以根据这两个参数计算出偏移量，再从数据库中取出相应的数据。</p><p>假如现在给出的参数为：<code>pageSize=10</code>，<code>pageIndex = 2</code>，也就是说每一页要 10 条记录，要第二页。</p><p>计算偏移量的公式为：<code>pageSize * (pageIndex - 1)</code>。</p><p>基本代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">Request <span class="variable">$request</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$pageSize</span> = <span class="variable">$request</span>-&gt;input(<span class="string">&#x27;pageSize&#x27;</span>);</span><br><span class="line">    <span class="variable">$pageIndex</span> = <span class="variable">$request</span>-&gt;input(<span class="string">&#x27;pageIndex&#x27;</span>);</span><br><span class="line">    <span class="variable">$offset</span> = <span class="variable">$pageSize</span> * (<span class="variable">$pageIndex</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> User::offset(<span class="variable">$offset</span>)</span><br><span class="line">                -&gt;limit(<span class="variable">$pageSize</span>)</span><br><span class="line">                -&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端基本上只需要做这么多，就可以完成一个分页的功能了，但还是有几处地方需要改进一下：</p><ul><li>给参数一个默认值</li><li>前端还需要知道整个表的数据的总数</li><li>把分页做成一个公用的函数</li></ul><p>改进后的代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="variable">$default_page_size</span> = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$default_page_index</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公用分页</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pagination</span>(<span class="params"><span class="variable">$request</span>, <span class="variable">$list</span></span>) </span>&#123;</span><br><span class="line"><span class="variable">$pageSize</span> = <span class="variable">$request</span>-&gt;input(<span class="string">&#x27;pageSize&#x27;</span>, <span class="keyword">$this</span>-&gt;default_page_size);</span><br><span class="line"><span class="variable">$pageIndex</span> = <span class="variable">$request</span>-&gt;input(<span class="string">&#x27;pageIndex&#x27;</span>, <span class="keyword">$this</span>-&gt;default_page_index);</span><br><span class="line"><span class="variable">$offset</span> = <span class="variable">$pageSize</span> * (<span class="variable">$pageIndex</span> - <span class="number">1</span>);</span><br><span class="line"><span class="variable">$total</span> = <span class="variable">$list</span>-&gt;count();</span><br><span class="line"><span class="variable">$list</span> = <span class="variable">$list</span></span><br><span class="line">            -&gt;offset(<span class="variable">$offset</span>)</span><br><span class="line">            -&gt;limit(<span class="variable">$pageSize</span>);</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="string">&#x27;list&#x27;</span> =&gt; <span class="variable">$list</span>-&gt;get(),</span><br><span class="line"><span class="string">&#x27;total&#x27;</span> =&gt; <span class="variable">$total</span>,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">Request <span class="variable">$request</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$list</span> = User::query();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里可以做一些查询之类的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pagination(<span class="variable">$request</span>, <span class="variable">$list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再说前端"><a href="#再说前端" class="headerlink" title="再说前端"></a>再说前端</h2><p>前端相对于需要做的事情就比较多了，需要考虑几点：</p><ul><li>获取数据时需要带上分页的参数</li><li>分页参数需要进行本地持久化，以免刷新页面回到第一页（后端设置的默认值）</li><li>同样要抽象出一个通用的分页组件</li></ul><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>这里我们用 <code>vuex</code>来管理状态，然后在请求时带上分页数据：</p><p>store.js：</p><blockquote><p><strong>注意</strong>：</p><ul><li>这里为了方便展示代码，并没有使用模块化，项目中，最好将使用模块化方便管理。</li><li>这里默认读者清楚 ES6 的语法</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">list</span>: [],</span><br><span class="line">      <span class="attr">total</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">pageIndex</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateUser</span>(<span class="params">state, data</span>)</span> &#123;</span><br><span class="line">      state.user = &#123;</span><br><span class="line">        ...state.user,</span><br><span class="line">        ...data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">getUser</span>(<span class="params">&#123; commit, state, getters &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// $axios 只是我自己封装的一个函数 这里并不重要</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> $axios.get(<span class="string">&#x27;/user&#x27;</span>, getters.requestData(state.user))</span><br><span class="line">      commit(<span class="string">&#x27;updateUser&#x27;</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">requestData</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">origin</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; pageIndex, pageSize &#125; = origin</span><br><span class="line">        <span class="keyword">const</span> data = &#123;</span><br><span class="line">          pageIndex,</span><br><span class="line">          pageSize</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>现在如何获取数据已经搞定了，数据持久化我使用 <a href="https://github.com/crossjs/vuex-localstorage">vuex-localstorage</a>，安装后，只需要在上面代码的基础上添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPersist <span class="keyword">from</span> <span class="string">&#x27;vuex-localstorage&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 接着上面的</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    createPersist(&#123;</span><br><span class="line">      <span class="attr">namespace</span>: <span class="string">&#x27;studio-user&#x27;</span>,</span><br><span class="line">      <span class="attr">initialState</span>: &#123;&#125;,</span><br><span class="line">      <span class="comment">// ONE_WEEK</span></span><br><span class="line">      <span class="attr">expires</span>: <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1e3</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="公用分页组件"><a href="#公用分页组件" class="headerlink" title="公用分页组件"></a>公用分页组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-Pagination</span></span></span><br><span class="line"><span class="tag">    <span class="attr">background</span></span></span><br><span class="line"><span class="tag">    <span class="attr">layout</span>=<span class="string">&quot;total, sizes, prev, pager, next, jumper&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:total</span>=<span class="string">&quot;module.total&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:current-page.sync</span>=<span class="string">&quot;module.pageIndex&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:page-sizes</span>=<span class="string">&quot;module.pageSizes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:page-size.sync</span>=<span class="string">&quot;module.pageSize&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">size-change</span>=<span class="string">&quot;handleSizeChange&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-Pagination</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">module</span>: <span class="built_in">Object</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;get-data&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">handleCurrentChange</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.getData()</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">handleSizeChange</span>(<span class="params">val</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.getData()</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用分页组件"><a href="#使用分页组件" class="headerlink" title="使用分页组件"></a>使用分页组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;user.list&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in columns&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:prop</span>=<span class="string">&quot;item.prop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:label</span>=<span class="string">&quot;item.label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">align</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pagination</span> <span class="attr">:module</span>=<span class="string">&quot;user&quot;</span> @<span class="attr">get-data</span>=<span class="string">&quot;getData&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Pagination <span class="keyword">from</span> <span class="string">&#x27;@/common/components/Pagination&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; mapActions, mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      Pagination</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">columns</span>: [</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">prop</span>: <span class="string">&#x27;name&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">label</span>: <span class="string">&#x27;姓名&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">prop</span>: <span class="string">&#x27;性别&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">label</span>: <span class="string">&#x27;sex&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">prop</span>: <span class="string">&#x27;年龄&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">label</span>: <span class="string">&#x27;age&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      ]</span></span><br><span class="line"><span class="javascript">    &#125;),</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.getData()</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      ...mapActions(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">getData</span>: <span class="string">&#x27;getUser&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      ...mapState([<span class="string">&#x27;user&#x27;</span>])</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>将一些常用的功能抽象出来，打造一个自己的工具库，从而使开发效率更高。</p><p>最后，安利一下文章开头说的项目：<a href="https://github.com/gd4Ark/learn_english">清技背单词</a>，上面的代码就是从这个项目中<code>copy</code>出来后略作修改的。</p><p>感谢观看，希望我的文章能对您有一些帮助！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> PHP </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Laravel JWT 多表认证时获取不到当前认证用户的问题</title>
      <link href="//post/834cec76.html"/>
      <url>//post/834cec76.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在做一个项目，需要多表认证，分别为<code>admin</code>和<code>user</code>表，我采用的<code>JWT</code>认证方式，但今天遇到了一个问题：使用<code>Auth::user()</code>返回<code>null</code>，也就是说无法获得当前认证的用户。</p><p>网上搜索后，并没有找到直接的解决方案，然后经过几次尝试居然误打误撞地解决了，所以特地记录下来，希望遇到同样问题的人不要再在这问题上耗费太多时间。</p><p><strong>注意：</strong>这里并不介绍<code>JWT</code>的工作原理和配置，如果想理解更多请参考以下文章：</p><ul><li><a href="https://learnku.com/articles/10885/full-use-of-jwt">JWT 完整使用详解</a></li><li><a href="https://learnku.com/articles/10889/detailed-implementation-of-jwt-extensions">JWT 扩展具体实现详解</a></li></ul><h2 id="大致配置"><a href="#大致配置" class="headerlink" title="大致配置"></a>大致配置</h2><p>先讲一下我的配置。</p><p><code>auth.php</code>文件如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;defaults&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;guard&#x27;</span> =&gt; env(<span class="string">&#x27;AUTH_GUARD&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;guards&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;admin&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;driver&#x27;</span> =&gt; <span class="string">&#x27;jwt&#x27;</span>,                           <span class="comment">#### 更改为JWT驱动</span></span><br><span class="line">            <span class="string">&#x27;provider&#x27;</span> =&gt; <span class="string">&#x27;admins&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;driver&#x27;</span> =&gt; <span class="string">&#x27;jwt&#x27;</span>,                           <span class="comment">#### 更改为JWT驱动</span></span><br><span class="line">            <span class="string">&#x27;provider&#x27;</span> =&gt; <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;providers&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;admins&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;driver&#x27;</span> =&gt; <span class="string">&#x27;eloquent&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;model&#x27;</span>  =&gt; \App\Admin::class,        <span class="comment">#### 指定用于token验证的模型类</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;users&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;driver&#x27;</span> =&gt; <span class="string">&#x27;eloquent&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;model&#x27;</span>  =&gt; \App\User::class,        <span class="comment">#### 指定用于token验证的模型类</span></span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;passwords&#x27;</span> =&gt; [</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>在<code>auth.php</code>中，我们有两个<code>guard</code>，而默认的<code>guard</code>指向的是<code>admin</code>，这时候如果是<code>user</code>经过的验证的话，是无法通过<code>Auth::user()</code>获取到当前认证用户信息的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法很简单，只要使用<code>Auth::guard(&#39;user&#39;)</code>指明使用哪个<code>guard</code>即可，这里我是通过公用的控制器中的一个方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAuthUser</span>(<span class="params"><span class="variable">$guard</span> = <span class="string">&#x27;admin&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Auth::guard(<span class="variable">$guard</span>)-&gt;user();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感谢观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 JavaScript 中的原型</title>
      <link href="//post/6a052002.html"/>
      <url>//post/6a052002.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中的原型一直是我很惧怕的一个主题，理由很简单，因为真的不好理解，但它确实是 JavaScript 中很重要的一部分，而且是面试的必考题，就算现在不懂，以后迟早有一天要把它弄懂，不然的话永远都没办法把自己的技术能力往上提高一个层次，所以今天就来讲讲 JavaScript 中的原型。</p><p>本文是这系列的第四篇，往期文章：</p><ol><li><a href="https://juejin.im/post/5c386bd96fb9a04a03796f93">理解 JavaScript 中的作用域</a></li><li><a href="https://juejin.im/post/5c3893bc6fb9a049d37f530f">理解 JavaScript 中的闭包</a></li><li><a href="https://gd4ark.github.io/2019/01/16/%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84this/">理解 JavaScript 中的 this</a></li></ol><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>首先要说一下为什么会有原型这个东西，那是因为在 JavaScript 中并没有 “类” 的概念，它是靠原型和原型链实现对象属性的继承，即便在 ES6 中新出了<code>class</code>的语法，但那也只是一个语法糖，它的底层依然是原型。</p><p>要理解原型（原型链），最重要的是理解两个属性以及它们之间的关系：</p><ul><li><code>__proto__</code></li><li><code>prototype</code></li></ul><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>JavaScript 中，万物皆对象，所有的对象都有<code>__proto__</code>属性（<code>null</code>和<code>undefined</code>除外），而且指向创造这个对象的函数对象的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.__proto__ === <span class="built_in">String</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ === <span class="built_in">Number</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>前面说了，在 JavaScript 中，一切皆对象（可以理解为它们都是从对象那里继承过来的），所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而因为<code>Object.prototype</code>的<code>__proto__</code>已经是终点了，所以它的指向是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，虽然大多数浏览器都支持通过<code>__proto__</code>来访问，但它并不是<code>ECMAScript</code>的标准，在 ES5 中可以通过<code>Object.getPrototypeOf()</code>来获取这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h3><p><code>prototype</code>是每个函数对象都具有的属性（它也有<code>__proto__</code>，因为函数也是对象），实例化创建出来的对象会共享此<code>prototype</code>里的属性和方法（通过<code>__proto__</code>）。</p><p>在上面的例子中已经看到过<code>prototype</code>的身影，下面通过一个例子来讲述它的作用。</p><p>现在我们有一个构造函数<code>Person</code>，并且对它进行实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是：&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Person(<span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a.sayName() <span class="comment">// 我的名字是：小明</span></span><br><span class="line">b.sayName() <span class="comment">// 我的名字是：小红</span></span><br></pre></td></tr></table></figure><h4 id="new-运算符的缺点"><a href="#new-运算符的缺点" class="headerlink" title="new 运算符的缺点"></a>new 运算符的缺点</h4><p>但是，用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p><p>例如上面例子中的<code>a</code>和<code>b</code>，它们都有<code>sayName</code>方法，虽然做的事相同，但它们却是独立的，这就会造成极大的资源浪费，因为每一个实例对象，都有自己的属性和方法的副本。</p><h4 id="prototype-属性的引入"><a href="#prototype-属性的引入" class="headerlink" title="prototype 属性的引入"></a>prototype 属性的引入</h4><p>考虑到这一点，Brendan Eich 决定为构造函数设置一个<code>prototype</code>属性。</p><p>这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面，而不需要共享属性和方法，就放在构造函数里面，这个对象就是<code>prototype</code>对象。</p><p>实例对象一旦创建，将自动引用<code>prototype</code>对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p><p>现在对上面的例子进行改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是：&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Person(<span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line">a.sayName() <span class="comment">// 我的名字是：小明</span></span><br><span class="line">b.sayName() <span class="comment">// 我的名字是：小红</span></span><br></pre></td></tr></table></figure><p>现在无论<code>Person</code>被实例化多少次，它的实例对象都共享同一个<code>sayName</code>方法，这就是<code>prototype</code>最大的用处。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>讲原型一个不可避免的概念就是原型链，原型链是通过<code>__proto__</code>来实现的。</p><p>现在我们以<code>Person</code>的例子来讲整个原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象的 __proto__ 指针指向构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === Person.prototype)</span><br><span class="line"><span class="comment">// 构造函数的原型是一个对象，它的 __proto__ 指向对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// 函数也是一个对象，它的 __proto__ 指向 函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="comment">// 函数的原型是一个对象，它的 __proto__ 指向对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// 对象的原型的__proto__ 指向 null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>以上就是<code>a</code>对象的整个原型链。</p><h2 id="属性查找机制"><a href="#属性查找机制" class="headerlink" title="属性查找机制"></a>属性查找机制</h2><p>当访问一个对象的属性时，Javascript 会从对象本身开始往上遍历整个原型链，直到找到对应属性为止。如果此时到达了原型链的顶部，也就是上例中的 <code>Object.prototype</code>，仍然未发现需要查找的属性，那么 Javascript 就会返回 <code>undefined</code>值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen 使用 throttle 限制接口访问频率</title>
      <link href="//post/618b271f.html"/>
      <url>//post/618b271f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天碰到过这样一个情况，我需要限制用户请求某个<code>API</code>接口的频率，比如登录、反馈等提交操作，经过一番搜索+折腾，总算是实现了。</p><blockquote><p>在<code>Laravel 5.2</code>的新特性中增加了一个<code>throttle</code>中间件，通过它可以在路由层限制<code>API</code>访问的频率。例如限制频率为 1 分钟 50 次，如果一分钟内超过了这个限制，它就会响应：429: Too Many Attempts。</p></blockquote><p>但我在项目中使用的是<code>Lumen</code>框架（它只有<code>Laravel</code>中的一部分功能），它并没有集成这个中间件，所以本文主要是记录如何在<code>Lumen</code>框架中加入<code>throttle</code>中间件。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先我们要在<code>app\Http\Middleware</code>中新建<code>ThrottleRequests.php</code>文件。</p><p>并且把以下链接中的代码拷贝到这个文件中：</p><p><a href="https://github.com/illuminate/routing/blob/master/Middleware/ThrottleRequests.php">https://github.com/illuminate/routing/blob/master/Middleware/ThrottleRequests.php</a></p><p>接着修改文件中的命名空间：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</span><br></pre></td></tr></table></figure><h3 id="标记同一用户端请求"><a href="#标记同一用户端请求" class="headerlink" title="标记同一用户端请求"></a>标记同一用户端请求</h3><p>因为<code>Lumen</code>框架缺失部分功能，我们需要修改<code>ThrottleRequests.php</code>中的<code>resolveRequestSignature</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveRequestSignature</span>(<span class="params"><span class="variable">$request</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sha1(</span><br><span class="line">        <span class="variable">$request</span>-&gt;method() .</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span> . <span class="variable">$request</span>-&gt;server(<span class="string">&#x27;SERVER_NAME&#x27;</span>) .</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span> . <span class="variable">$request</span>-&gt;path() .</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span> . <span class="variable">$request</span>-&gt;ip()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抛出响应"><a href="#抛出响应" class="headerlink" title="抛出响应"></a>抛出响应</h3><p><code>throttle</code>超过限制时抛出的是<code>Illuminate\Http\Exceptions\ThrottleRequestsException</code>，同样<code>Lumen</code>框架缺少这个文件，需要自己定义一下，在<code>app/Exceptions</code>中新建<code>ThrottleException.php</code>，写入以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThrottleException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$isReport</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isReport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;isReport;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>app/Exceptions/Handler.php</code>捕获该抛出异常，在<code>render</code>方法增加以下判断：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$exception</span> <span class="keyword">instanceof</span> ThrottleException) &#123;</span><br><span class="line"><span class="keyword">return</span> response([</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span> =&gt; <span class="variable">$exception</span>-&gt;getCode(),</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span> =&gt; <span class="variable">$exception</span>-&gt;getMessage()</span><br><span class="line">], <span class="number">429</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>ThrottleRequests.php</code>文件中的<code>buildException</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildException</span>(<span class="params"><span class="variable">$key</span>, <span class="variable">$maxAttempts</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$retryAfter</span> = <span class="keyword">$this</span>-&gt;getTimeUntilNextRetry(<span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">$this</span>-&gt;getHeaders(</span><br><span class="line">        <span class="variable">$maxAttempts</span>,</span><br><span class="line">        <span class="keyword">$this</span>-&gt;calculateRemainingAttempts(<span class="variable">$key</span>, <span class="variable">$maxAttempts</span>, <span class="variable">$retryAfter</span>),</span><br><span class="line">        <span class="variable">$retryAfter</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 修改了这一行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThrottleException(<span class="string">&#x27;Too Many Attempts.&#x27;</span>, <span class="number">429</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需在文件头部中添加这一行：<code>use App\Exceptions\ThrottleException;</code></p></blockquote><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在<code>bootstrap/app.php</code>中注册：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$app</span>-&gt;routeMiddleware([</span><br><span class="line">     <span class="string">&#x27;throttle&#x27;</span> =&gt; App\Http\Middleware\ThrottleRequests::class,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>到这里我们就加入成功了，接着在路由中添加中间件即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable">$router</span>-&gt;group([<span class="string">&#x27;middleware&#x27;</span> =&gt; [<span class="string">&#x27;throttle:10,2&#x27;</span>]],<span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$router</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="variable">$router</span>-&gt;post(<span class="string">&#x27;feedback&#x27;</span>,<span class="string">&#x27;UserController@addFeedback&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>throttle:10,2</code>表示的是 2 分钟内访问 10 次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 JavaScript 中的 this</title>
      <link href="//post/8b423d03.html"/>
      <url>//post/8b423d03.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>理解<code>this</code>是我们要深入理解 JavaScript 中必不可少的一个步骤，同时只有理解了 <code>this</code>，你才能更加清晰地写出与自己预期一致的 JavaScript 代码。</p><p>本文是这系列的第三篇，往期文章：</p><ol><li><a href="https://juejin.im/post/5c386bd96fb9a04a03796f93">理解 JavaScript 中的作用域</a></li><li><a href="https://juejin.im/post/5c3893bc6fb9a049d37f530f">理解 JavaScript 中的闭包</a></li></ol><h2 id="什么是-this"><a href="#什么是-this" class="headerlink" title="什么是 this"></a>什么是 this</h2><h3 id="消除误解"><a href="#消除误解" class="headerlink" title="消除误解"></a>消除误解</h3><p>在解释什么是<code>this</code>之前，需要先纠正大部分人对<code>this</code>的误解，常见的误解有：</p><ol><li>指向函数自身。</li><li>指向它所在的作用域。</li></ol><blockquote><p>关于为何会误解的原因这里不多讲，这里只给出结论，有兴趣可以自行查询资料。</p></blockquote><p><code>this</code> 在任何情况下都不指向函数的词法作用域。你不能使用 <code>this</code> 来引用一个词法作用域内部的东西。</p><h3 id="this-到底是什么"><a href="#this-到底是什么" class="headerlink" title="this 到底是什么"></a>this 到底是什么</h3><p>排除了一些错误理解之后，我们来看看 <code>this</code>到底是一种什么样的机制。</p><p><code>this</code>是在运行时（<code>runtime</code>）进行绑定的，<strong>而不是在编写时绑定的</strong>，它的上下文（对象）取决于函数调用时的各种条件。<code>this</code>的绑定和函数声明的位置没有任何关系，<strong>只取决于函数的调用方式</strong>。</p><p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。**<code>this</code>就是记录的其中一个属性**，会在函数执行的过程中用到。（PS:所以<code>this</code>并不等价于执行上下文）</p><h2 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h2><p>前面 我们排除了一些对于 <code>this</code>的错误理解并且明白了每个函数的<code>this</code>是在调用时被绑定的，完全取决于函数的调用位置。</p><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>通常来说，寻找调用位置就是寻找“函数被调用的位置“，其中最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><p>下面我们来看看到底什么是调用栈和调用位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：foo</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  bar() <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是foo -&gt; bar</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// &lt;-- foo 的调用位置</span></span><br></pre></td></tr></table></figure><blockquote><p>你可以把调用栈想象成一个函数调用链， 就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。 另一个查看调用栈的方法是使用浏览器的调试工具。 绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。</p></blockquote><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>在找到调用位置后，则需要判定代码属于下面四种绑定规则中的哪一种，然后才能对<code>this</code>进行绑定。<br><strong>注意:</strong> <code>this</code>绑定的是上下文<strong>对象</strong>,<strong>并不是函数自身也不是函数的词法作用域</strong></p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>这是最常见的函数调用类型：<strong>独立函数调用</strong>：</p><p>对函数直接使用而不带任何修饰的函数引用进行调用，简单点一个函数直接是<code>func()</code>这样调用，不同于通过对象属性调用例如<code>obj.func()</code>，也没有通过 new 关键字<code>new Function()</code>，也没有通过<code>apply</code>、<code>call</code>、<code>bind</code>强制改变<code>this</code>指向。</p><p>当被用作独立函数调用时（不论这个函数在哪被调用，不管全局还是其他函数内），<code>this</code>默认指向到<code>Window</code>。（**注意：在严格模式下<code>this</code>不再默认指向全局，而是<code>undefined</code>**）。</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line">foo() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a><strong>隐式绑定</strong></h4><p>函数被某个对象拥有或者包含，也就是函数被作为对象的属性所引用，例如<code>obj.func()</code>，此时<code>this</code>会绑定到该对象上，这就是隐式绑定。</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p><strong>隐式丢失</strong>：</p><p>大部分的<code>this</code>绑定问题就是被“隐式绑定”的函数会丢失绑定对象，也就是说它会应用“默认绑定”，从而把<code>this</code>绑定到<code>Window</code>或<code>undefined</code>上，这取决于是否是严格模式。</p><p>最常见的情况就是把对象方法作为回调函数进行传递时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.foo, <span class="number">1000</span>) <span class="comment">// 一秒后输出 window</span></span><br></pre></td></tr></table></figure><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a><strong>显式绑定</strong></h4><p>我们可以通过<code>apply</code>、<code>call</code>、<code>bind</code>方法来显示地修改<code>this</code>的指向。</p><p>关于这三个方法的定义（它们第一个参数都是接受<code>this</code>的绑定对象）：</p><ol><li><code>apply</code>：调用函数，第二个参数传入一个参数数组。</li><li><code>call</code>：调用函数，其余参数正常传递。</li><li><code>bind</code>：返回一个已经绑定<code>this</code>的函数，其余参数正常传递。</li></ol><p>比如我们可以使用<code>bind</code>方法解决上一节“隐式丢失”中的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.foo.bind(obj), <span class="number">1000</span>) <span class="comment">// 一秒后输出 obj</span></span><br></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建(或者说构造)一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的<code>this</code>。</li><li>如果函数没有返回其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>直接上结论:</p><blockquote><p>new 绑定=显示绑定&gt;隐式绑定&gt;默认绑定</p></blockquote><p><strong>判断 this：</strong><br>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p><ol><li><p>使用 new 绑定，<code>this</code>绑定的是新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure></li><li><p>通过<code>call</code>之类的显式绑定，<code>this</code>绑定的是指定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo.call(obj2)</span><br></pre></td></tr></table></figure></li><li><p>在某个上下文对象中调用(隐式绑定)，this 绑定的是那个上下文对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = obj1.foo()</span><br></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。<code>this</code>绑定到<code>Window</code>或<code>undefined</code>上，这取决于是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo()</span><br></pre></td></tr></table></figure><p>对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。</p></li></ol><h3 id="this-词法"><a href="#this-词法" class="headerlink" title="this 词法"></a>this 词法</h3><p>ES6 中介绍了一种无法使用上面四条规则的特殊函数类型：<strong>箭头函数</strong>。</p><p><strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。</strong>(而传统的 this 与函数作用域没有任何关系,它只与调用位置的上下文对象有关)。</p><p><strong>重要:</strong></p><ul><li>箭头函数最常用于回调函数中，例如事件处理器或者定时器.</li><li>箭头函数可以像<code>bind</code> 一样确保函数的<code>this</code>被绑定到指定对象</li><li>箭头函数用更常见的词法作用域取代了传统的<code>this</code>机制。</li></ul><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)) <span class="comment">// obj</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure><p>这在 ES6 之前是这样解决的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(self.name)) <span class="comment">// obj</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之如果要判断一个运行中函数的<code>this</code>绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断<code>this</code>的绑定对象。</p><ol><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply(或者 bind)调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认:在严格模式下绑定到<code>undefined</code>，否则绑定到全局对象。</li></ol><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 <code>this</code>，具体来说，箭头函数会继承外层函数调用的 <code>this</code>绑定(无论 <code>this</code>绑定到什么)。这其实和 ES6 之前代码中的 <code>self = this</code> 机制一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 JavaScript 中的闭包</title>
      <link href="//post/b5597874.html"/>
      <url>//post/b5597874.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继上一篇《理解 JavaScript 中的作用域》后，我又立刻写下了这篇文章，因为这两者是存在关联的，在理解闭包前，你需要知道作用域。</p><p>而对于那些有一点 JavaScript 使用经验的人来说，理解闭包可以看做是某种意义上的重生，但这并不简单，你需要付出非常多的努力和牺牲才能理解这个概念。</p><p>如果你理解了闭包，你会发现即便是没理解闭包之前，你也用到了闭包，但我们要做的就是根据自己的意愿正确地识别、使用闭包。</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包的定义，你需要掌握它才能理解和识别闭包：</p><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即便函数是在当前词法作用域之外执行。</p></blockquote><p>下面用一些代码来解释这个定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>很明显这是一个嵌套作用域，而<code>bar</code>的作用域也确实能够访问外部作用域，但这就是闭包吗？</p><p>不，不完全是，但它是闭包中很重要的一部分：根据词法作用域的查找规则，它能够访问外部作用域。</p><p>下面再来看这段代码，它清晰地使用了闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line">baz() <span class="comment">// 2 —— 这就是闭包</span></span><br></pre></td></tr></table></figure><p>由于<code>bar</code>的词法作用域能够访问<code>foo</code>的内部作用域，然后我们把<code>bar</code>这个函数本身当作返回值，然后在调用<code>foo</code>时把<code>bar</code>引用的函数赋值给<code>baz</code>（其实是两个标识符引用同一个函数），所以<code>baz</code>能够访问<code>foo</code>的内部作用域。</p><p>而这里正是印证前面的定义：函数是在当前词法作用域之外执行。</p><p>其实按正常情况下，引擎有垃圾回收器用来释放不再使用的内存空间，当<code>foo</code>执行完毕时，自然会将其回收，但闭包的神奇之处正是可以阻止这件事情的发生，因为内部作用域依然存在，<code>bar</code>在使用它。</p><p>由于<code>bar</code>声明位置的原因，它涵盖了<code>foo</code>内部作用域的闭包，使得该作用域能够一直存活，以供<code>bar</code>在之后任何时间进行引用。</p><p><code>bar</code>依然有对该作用域的引用，而这个引用就叫做闭包。</p><p>因此，当<code>baz</code>在调用时，它自然能够访问到<code>foo</code>的内部作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包的存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn() <span class="comment">// 2 —— 这也是闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把内部函数<code>baz</code>作为<code>fn</code>参数传递给<code>bar</code>，当调用<code>fn</code>时，它能够访问到<code>foo</code>的内部作用域。</p><p>传递函数也可以是间接的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  fn = baz</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">fn() <span class="comment">// 2 —— 这也是闭包</span></span><br></pre></td></tr></table></figure><p>所以：</p><blockquote><p>无论通过何种方式将内部函数传递到所在的词法作用于之外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p></blockquote><h2 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h2><p>既然前面说闭包无处不在，那不妨看看几个平时经常看到的片段，看看闭包的妙用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="string">&#x27;Hello, closure!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将一个内部函数（这里叫做<code>timer</code>）作为参数传递给<code>setTimeout</code>，而<code>timer</code>能够访问<code>wait</code>的内部作用域。</p><p>如果你使用过<code>jQuery</code>，不难发现下面代码中也使用了闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name, selector</span>) </span>&#123;</span><br><span class="line">  $(selector).click(<span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Activating:&#x27;</span> + name)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setupBot(<span class="string">&#x27;Closure Bot 1&#x27;</span>, <span class="string">&#x27;#btn_1&#x27;</span>)</span><br><span class="line">setupBot(<span class="string">&#x27;Closure Bot 2&#x27;</span>, <span class="string">&#x27;#btn_2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>本质上无论何时何地，如果将函数（ 访问它们各自的词法作用域）当作第一级的值类型并到处传递， 你就会看到闭包在这些函数中的应用。 在定时器、 事件监听器、Ajax 请求、 跨窗口通信、Web Workers 或者任何其他的异步（ 或者同步）任务中， 只要使用了回调函数，实际上就是在使用闭包！</p><p>再来看一个很经典的闭包面试题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，我们对这段代码行为的预期是每秒一次输出 1~5。</p><p>但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p><p>为什么？</p><p>首先解释 6 是从哪里来的，这个循环的终止条件是<code>i</code>不再<code>&lt;=5</code>，所以当条件成立时，<code>i</code>等于 6。因此，输出显示的是循环结束时<code>i</code>的最终值。</p><p>也就是我们陷入了一个这样的误区：以为循环中每个迭代在运行时都会复制一个<code>i</code>的副本，但根据作用域的工作原理，它们都共享同一个全局作用域，因此实际上只有一个<code>i</code>。</p><p>要使这段代码的运行与我们预期一致，解决方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中我们使用了<code>IIFE</code>，将<code>i</code>作为参数<code>j</code>传递进去，在每个迭代<code>IIFE</code>会生成一个自己的作用域，它们接受参数<code>j</code>不一样，所以这段代码能够符合我们预期地运行。</p><p>还有别的解决方案吗？</p><p>是的，使用 ES6 新出的<code>let</code>可以解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仅仅把<code>var</code>替换为<code>let</code>就轻松地解决了该问题，原因如下：</p><ul><li><code>for</code>中有自己的块作用域（<code>()</code>是父级作用域，<code>&#123;&#125;</code>是子级作用域）。</li><li>使用<code>let</code>能够创建块作用域的变量。</li></ul><p>好了，到现在你应该能够很容易地识别闭包，那么接下来，我们继续介绍闭包更高级的用法。</p><p>假设我们有这样一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(box.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>然而这里有一个问题，那就是属性<code>age</code>可以随意改变，如果我们使用闭包，就可以实现私有化，将<code>age</code>属性保护起来，只做允许的修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">birthday</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      age++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">box.birthday()</span><br><span class="line">box.sayAge() <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><p>这样我们就保证<code>age</code>属性只能增加，而不能减少，毕竟没有人能够越活越年轻。</p><p><strong>注意：</strong></p><blockquote><ol><li>其实对象也有方法可以控制属性的修改，但这里主要讲述闭包，就不过多赘述。</li><li>使用闭包能够轻松实现原本在 JavaScript 较复杂的设计。</li></ol></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实当你理解了闭包之后，你就会发现一切都是那么的理所当然，就仿佛它本该如此。</p><p>最后，如果你已经理解了闭包并且想练习一下，那么我可以出一道题目给你：</p><blockquote><p>实现一个<code>add</code>函数，功能：<code>add(1)(2)(3); // 6</code></p><p>难一点的：</p><p>实现一个<code>add</code>函数，功能：<code>add(3)(‘*’)(3); // 9</code></p><p>有几点：</p><ol><li><code>add</code>函数可以被无限调用。</li><li>调用完毕后将结果输出到控制台。</li></ol></blockquote><p>感谢观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 JavaScript 中的作用域</title>
      <link href="//post/b845344a.html"/>
      <url>//post/b845344a.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>学习 JavaScript 也有一段时间，今天抽空总结一下作用域，也方便自己以后翻阅。</p><h2 id="2-什么是作用域"><a href="#2-什么是作用域" class="headerlink" title="2. 什么是作用域"></a>2. 什么是作用域</h2><p>如果让我用一句简短的话来讲述什么是作用域，我的回答是：</p><blockquote><p>其实作用域的本质是一套规则，它定义了变量的可访问范围，控制变量的可见性和生命周期。</p></blockquote><p>既然作用域是一套规则，那么究竟如何设置这些规则呢？</p><p>先不急，在这之前，我们先来理解几个概念。</p><h3 id="2-1-编译到执行的过程"><a href="#2-1-编译到执行的过程" class="headerlink" title="2.1 编译到执行的过程"></a>2.1 编译到执行的过程</h3><p>下面我们就拿这段代码来讲述 JavaScript 编译到执行的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>首先我们来看一下在这个过程中，几个功臣所需要做的事。</p><ol><li><p>引擎（总指挥）：</p><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p></li><li><p>编译器（劳工）：</p><ol><li><p>词法分析（分词）</p><p>解析成词法单元，<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>。</p></li><li><p>语法分析（解析）</p><p>将单词单元转换成抽象语法树（AST）。</p></li><li><p>代码生成</p><p>将抽象语法树转换成机器指令。</p></li></ol></li><li><p>作用域（仓库管理员）：</p><p>负责收集并维护所有生命的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ol><p>然后我们再来看，执行这段代码时，每个功臣是怎么协同工作的。</p><p>引擎：</p><blockquote><p>其实这段代码有两个完全不同的声明，<code>var a</code>和<code>a = 2</code>，一个由编译器在编译时处理，另一个则由引擎在运行时处理。</p></blockquote><p>编译器：</p><blockquote><ol><li>一套编译器常规操作下来，到代码生成步骤。</li><li>遇到<code>var a</code>，会先询问作用域中是否已经存在同名变量，如果是，则忽略该声明，继续进行编译；否则它会要求作用域声明一个新的变量<code>a</code>。</li><li>为引擎生成运行<code>a = 2</code>时所需的代码。</li></ol></blockquote><p>引擎：</p><blockquote><p>会先询问作用域是否存在变量<code>a</code>，如果是，就会使用这个变量进行赋值操作；否则一直往外层嵌套作用域找（详见作用域嵌套），直至到全局作用域都没有时，抛出一个异常。</p></blockquote><p><strong>总结：</strong>变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对它赋值。</p><h3 id="2-2-LHS-amp-RHS-查询"><a href="#2-2-LHS-amp-RHS-查询" class="headerlink" title="2.2 LHS &amp; RHS 查询"></a>2.2 LHS &amp; RHS 查询</h3><p>从上面可知，引擎在获得编译器给出的代码后，还会对作用域进行询问变量。</p><p>聪明的你肯定一眼就看出，<code>L</code>和<code>R</code>的含义，它们分别代表左侧和右侧。</p><p>现在我们把代码改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b</span><br></pre></td></tr></table></figure><p>这时引擎对<code>a</code>进行 LHS 查询，对<code>b</code>进行 RHS 查询，但是<code>L</code>和<code>R</code>并不一定指操作符的左右边，而应该这样理解：</p><blockquote><p>LHS 是为了找到赋值的目标。 RHS 是赋值操作的源头。也就是 LHS 是为了找到变量这个容器本身，给它赋值，而 RHS 是为了取出这个变量的值。</p></blockquote><h4 id="2-2-1-作用域嵌套"><a href="#2-2-1-作用域嵌套" class="headerlink" title="2.2.1 作用域嵌套"></a>2.2.1 作用域嵌套</h4><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套，进而形成了一条作用域链。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。</p><h2 id="3-词法作用域"><a href="#3-词法作用域" class="headerlink" title="3. 词法作用域"></a>3. 词法作用域</h2><p>作用域分为两种：</p><ol><li>词法作用域（较为普遍，JavaScript 所使用的也是这种）</li><li>动态作用域（使用较少，比如 Bash 脚本、Perl 中的一些模式等）</li></ol><blockquote><p>词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。</p></blockquote><p>看以下代码，这个例子中有三个逐级嵌套的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">// 作用域1 全局</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span> <span class="comment">// 作用域2 局部</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = a * b <span class="comment">// 作用域3 局部</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>作用域是由你书写代码所在位置决定的。</li><li>子级作用域可以访问父级作用域，而父级作用域则不能访问子级作用域。</li></ol></blockquote><h2 id="4-引擎对作用域的查找"><a href="#4-引擎对作用域的查找" class="headerlink" title="4. 引擎对作用域的查找"></a>4. 引擎对作用域的查找</h2><p>作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。也就是说查找时会从运行所在的作用域开始，逐级往上查找，直到遇见第一个标识符为止。</p><p>全局变量（全局作用域下定义的变量）会自动变成全局对象（比如浏览器中的 window 对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>非全局的变量如果被遮蔽了，就无论如何都无法被访问到，所以在上述代码中，<code>bar</code>内的作用域无法访问到<code>foo</code>下定义的变量<code>a</code>。</p><p>词法作用域查找只会查找一级标识符，比如<code>a</code>、<code>b</code>，如果是<code>foo.bar</code>，词法作用域查找只会试图查找<code>foo</code>标识符，找到这个变量后，由对象属性访问规则接管属性的访问。</p></blockquote><h2 id="5-欺骗语法"><a href="#5-欺骗语法" class="headerlink" title="5. 欺骗语法"></a>5. 欺骗语法</h2><p>虽然词法作用域是在代码编写时确定的，但还是有方法可以在引擎运行时动态修改词法作用域，有两种机制：</p><ol><li><code>eval</code></li><li><code>with</code></li></ol><h3 id="5-1-eval"><a href="#5-1-eval" class="headerlink" title="5.1 eval"></a>5.1 eval</h3><p>JavaScript 的 <code>eval</code>函数可以接受一个字符串参数并作为代码语句来执行， 就好像代码是原本就在那个位置一样，考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str) <span class="comment">// 欺骗</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo(<span class="string">&#x27;var a = 2;&#x27;</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>仿佛<code>eval</code>中传入的参数语句原本就在那一样，会创建一个变量<code>a</code>，并遮蔽了外部作用域的同名变量。</p><p><strong>注意</strong>：</p><blockquote><ul><li><code>eval</code>通常被用来执行动态创建的代码，可以根据程序逻辑动态地将变量和函数以字符串形式拼接在一起之后传递进去。</li><li>在严格模式下，<code>eval</code>无法修改所在的作用域。</li><li>与<code>eval</code>相似的还有，<code>setTimeout</code>、<code>setInterval</code>、<code>new Function</code>。</li></ul></blockquote><h3 id="5-2-with"><a href="#5-2-with" class="headerlink" title="5.2 with"></a>5.2 with</h3><p><code>with</code>通常被当作重复引用同一个对象中的多个属性的快捷方式， 可以不需要重复引用对象本身。</p><p>使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure><p>然而考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b = <span class="number">3</span></span><br><span class="line">    c = <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj2)</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 4 不好，c被泄露到全局作用域下</span></span><br></pre></td></tr></table></figure><p>尽管<code>with</code>可以将对象处理为词法作用域，但是这样块内部正常的<code>var</code>操作并不会限制在这个块的作用域下，而是被添加到<code>with</code>所在的函数作用域下，而不通过<code>var</code>声明变量将视为声明全局变量。</p><h3 id="5-3-性能"><a href="#5-3-性能" class="headerlink" title="5.3 性能"></a>5.3 性能</h3><p><code>eval</code>和<code>with</code>会在运行时修改或创建新的作用域，以此来欺骗其他书写时定义的词法作用域，然而 JavaScript 引擎会在编译阶段进行性能优化，有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有的变量和函数的定义位置，才能在执行过程中快速找到标识符。但是通过<code>eval</code>和<code>with</code>来欺骗词法作用域会导致引擎无法知道他们对词法作用域做了什么样的改动，只能对部分不进行优化，因此如果在代码中大量使用<code>eval</code>或<code>with</code>就会导致代码运行起来变得非常慢。</p><h2 id="6-函数作用域和块作用域"><a href="#6-函数作用域和块作用域" class="headerlink" title="6. 函数作用域和块作用域"></a>6. 函数作用域和块作用域</h2><h3 id="6-1-函数作用域"><a href="#6-1-函数作用域" class="headerlink" title="6.1 函数作用域"></a>6.1 函数作用域</h3><p>在 JavaScript 中每声明一个函数就会创建一个函数作用域，同时属于这个函数的所有变量在整个函数的范围内都可以使用。</p><h3 id="6-2-块作用域"><a href="#6-2-块作用域" class="headerlink" title="6.2 块作用域"></a>6.2 块作用域</h3><p>从 ES3 发布以来，JavaScript 就有了块作用域，创建块作用域的几种方式有：</p><ul><li><p><code>with</code></p><p>上面已经讲了，这里不再复述。</p></li><li><p><code>try/catch</code></p><p><code>try/catch</code> 的 <code>catch</code> 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>let</code>和<code>const</code></p><p>ES6 引入的新关键词，提供了除 <code>var</code> 以外的变量声明方式，它们可以将变量绑定到所在的任意作用域中（通常是<code>&#123;&#125;</code>内部）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 <code>let</code>和<code>const</code> 进行的声明不会在块作用域中进行提升。</p></li></ul><h2 id="7-提升"><a href="#7-提升" class="headerlink" title="7. 提升"></a>7. 提升</h2><p>考虑这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输入结果是<code>undefined</code>，而不是<code>ReferenceError</code>。</p><p>为什么呢？</p><p>前面说过，编译阶段时，会把声明分成两个动作，也就是只把<code>var a</code>部分进行提升。</p><p>所以第二段代码真正的执行顺序是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="comment">// 这时 a 是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>编译阶段时会把所有的声明操作提升，而赋值操作原地执行。</li><li>函数声明会把整个函数提升，而不仅仅是函数名。</li></ul></blockquote><h2 id="8-函数优先"><a href="#8-函数优先" class="headerlink" title="8. 函数优先"></a>8. 函数优先</h2><p>虽然函数和变量都会被提升，但函数声明的优先级高于变量声明，所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个代码片段会被引擎理解为如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个值得一提的是，尽管<code>var foo</code>出现在<code>function foo()...</code>之前，但由于函数声明会被优先提升，所以它会被忽略（因为重复声明了）。<br><strong>注意：</strong></p><blockquote><p>JavaScript 会忽略前面已经声明过的声明，不管它是变量还是函数，只要其名称相同。</p></blockquote><h2 id="9-后记"><a href="#9-后记" class="headerlink" title="9. 后记"></a>9. 后记</h2><p>因为篇幅原因，有一部分内容只是大概提到，并没有太过于详细的讲解，如果你感兴趣，那么我推荐你看看<strong>《你不知道的 JavaScript（上）》</strong>这本书，书上对此内容有很详细的说明。</p><p>本文也是作者一边查看此书一边结合自己的理解来进行编写的。</p><p>其实作用域还有一个非常重要的概念，那就是<strong>闭包</strong>。但闭包也是 JavaScript 中的一个非常重要却又难以掌握的，所以需要另开一篇文章来介绍。</p><p>最后，我想说的就是，在这个框架工具流行的时代，我们往往会被这些新东西所吸引，却忽略了最本质的东西，诸诸不知，恰恰是这些我们所忽略的东西才是最重要的，所有的 JavaScript 框架工具都是基于这些内容。所以，不妨回过头来看看这些原生的东西，相信你会更上一层楼。</p><p>谢谢观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》-读书笔记</title>
      <link href="//post/2a0a222a.html"/>
      <url>//post/2a0a222a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看<a href="https://book.douban.com/subject/27016319/">《程序员的自我修养》</a>，作者陈逸鹤，这是一本值得深读的书。前半册较详细的介绍了一个程序员成长所需要经历和学习的内容，从工作、沟通、生活协调等方面给出了不同建议，其中也介绍了一些有用的网站和工具，</p><p>而后半册则是关于作者自学设计的经历以及如何教导孩子学习编程，对于我这样的年轻程序员可能暂时没多大兴趣，最后只能匆匆看完，或许以后会有机会再来翻阅一下。</p><p>然而即便是前半册，给我的感触也是很大的，同时也该庆幸在我步入社会前能读到一本这么好的书，在此对作者表示由衷的感谢。</p><p>如果你是一个职场新人、或像我一样准备步入社会工作的话，那么我推荐你去读一下这本书，这会给你带来很大的帮助。</p><p>下面我将总结一下书中对我影响较大的部分内容以及我个人的感想。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="第一章-谈职业生涯"><a href="#第一章-谈职业生涯" class="headerlink" title="第一章 谈职业生涯"></a>第一章 谈职业生涯</h3><h4 id="一、写给年轻程序员的启示"><a href="#一、写给年轻程序员的启示" class="headerlink" title="一、写给年轻程序员的启示"></a>一、写给年轻程序员的启示</h4><ol><li><p>正确认识自己</p><p>在网上形容程序员的词汇有很多，其中大部分都略带贬义，然而不管别人如何称呼你，最重要的是你内心如何形容自己，如果连自己都将自己当成一个码农，那你可能就真的是一个码农。这里作者说到他更喜欢用技匠来形容自己，因为程序员应该是那些不断追求更高技术，并有着自己的产品梦想的工匠。一个程序员，应该有自己的目标，自己的期待，并通过不断地努力去实现那些梦想。</p></li><li><p>比一般人努力</p><p>这里作者讲述了一个故事：一个普通人每天都很努力，而另一个天才却整天不务正业，过了一段时间，天才终于醒悟并开始努力，不久便超越了普通人，普通人很羡慕他，但他回过头才发现，他也已经成为了大部分人眼中的佼佼者。</p><p>程序员往往会被称为天才，那只是因为在你看不到的时候人家花了更多时间工作或者学习而已，当你也坚持这么做时，你也会变得和他们一样优秀。</p></li><li><p>适时建立个人权威</p><p>当你开始抱怨自己的职业生涯毫无起色时，不妨想想你是否已经习惯了听命于人，而缺少自己的观点和主观，久而久之便成为了别人眼中的平庸之人。你应该在适当的时机表现自己，让别人看到你的不同之处。</p></li><li><p>遵循最佳实践</p><p>无论新兴技术如何发展，技术的本质是不变的，你应该去理解那些软件领域最本质的东西，比如最佳实践，那些最佳实践是无数优秀程序员通过大量实践总结出来的，通过理解它们，能够让你站在前人的肩膀之上，从而对软件开发本身有更深入的理解和认识。</p></li><li><p>保持好奇心并乐于探索新的事物</p><p>优秀的程序员往往不会满足于对手头工作的认识和理解，他们会去理解更深入的东西，也乐于探索那些看似于工作无关的技术，通过对其他事物的学习，也能对你目前的工作有所帮助。</p></li><li><p>抛开代码与人沟通</p><p>不要忽视与人的沟通，当你的能力不断提升，被赋予更多职责时，你更需要与人沟通来管理好自己的团队，所以尝试离开你的电脑桌去与人沟通，这会给你的工作和生活带来积极的变化。</p></li><li><p>要为优秀的人工作</p><p>当你发现你所处的环境和周围的人已经无法让你获得提升时，那么你应该去选择一个更好的环境，尽可能与那些优秀的人一起工作。</p></li><li><p>生活、睡眠、旅行</p><p>我们时常听到关于程序员因疲劳过度而猝死的新闻，这从侧面说明程序员不懂得生活。每个程序员都应该明白，工作、技术、写代码这些并不是你存在的意义，而生活才是，你需要懂得生活，并且学会生活。</p><p>生活：你需要合理规划自己的时间分配（学习、阅读、写代码）并持之以恒地去做。</p><p>睡眠：不要熬夜，充足的睡眠会使你更有效率地投入到新一天的工作，你也会变得更优创造力。</p><p>旅行：旅行不是为了轻松，往往旅行比工作还累，但你还是应该出去走走，去感受新的东西，而这些是无法从电脑屏幕前获得的。</p><p>人生不应该只有工作，还应该去感受更多更美好的东西，有一个爱好，有一项坚持的事情。</p></li><li><p>相信自己的天赋和创造力</p><p>每个人都有属于自己的天赋和创造力，但它们绝不是与生俱来，你需要在生活中不断地培养和发掘它们，比如阅读优秀的书籍、记录和收集、尝试动手。</p></li></ol><h4 id="二、那些程序员后知后觉的职涯经验"><a href="#二、那些程序员后知后觉的职涯经验" class="headerlink" title="二、那些程序员后知后觉的职涯经验"></a>二、那些程序员后知后觉的职涯经验</h4><ol><li><p>你的薪酬与工作量无关</p><p>你的薪酬其实取决于很多因素，技术能力、经验资历、工作量等，但最本质的却是，你对公司是否重要，简单说就是你是否具有不可替代性。所以努力让自己变得越来越重要，相信你的薪资也会随之提升的。</p></li><li><p>尽可能持续做一件事</p><p>总是跟随新兴技术或框架，那你很难在某一项技术上达到理想的深度，同样，在一个公司里，如果你总是更换项目，那你也很难提升自己的价值，也不会具有不可替代性。所以你应该追求技术深度和具有完整项目经验。</p></li><li><p>唯一不变的就是变化本身</p><p>总所周知，我们使用的技术更新迭代很快。那么我们该如何去应对这些变化呢？你需要培养自己持续学习的能力，当你学的越多，往往就能学的越快，因为知识之间总是存在关联性的。</p></li><li><p>你的声誉很重要</p><p>优秀的程序员除了一些常见的良好特征之外，最重要的一点就是严谨。严谨的程序员会非常认真地对待分配自己的任务，这能大大减少工作中的出错率，从而给团队或公司中的其他人留下良好的印象。</p></li><li><p>理解沟通的意义</p><p>接到任务时不要着急干活，而应该去尽可能多地与客户沟通，去理解他们真正希望解决的问题，如果我们是这方面的专家，应该有负责去引导他们接受我们更专业的方案或设计</p></li><li><p>你的右脑将是你成功的关键</p><p>一个成功的技术人员，除了写代码外，往往还会伴随着其他方面的能力，如编写文档、演讲、说服他人等等，这将成为你与其他水平相当的竞争对手脱颖而出的关键。</p></li><li><p>不要轻易说简单或不可能</p><p>不要轻易做出过于绝对的判断，应尽可能去使用科学方法进行有效的表达，这样你提出的观点才能让大家感到信服。</p></li><li><p>你不应该总是单打独斗</p><p>不要总是单打独斗，要学会在团队中协作，并尽可能让优秀的人围绕在你身边，这将扩展你的能力范围，让你变得更加强大。</p></li><li><p>你的能力显而易见</p><p>程序员的能力来自大量的编码实践，以及持续学习的能力和勤于思考的习惯。任何自作聪明，不懂装懂，以及投机取巧在明眼人看来都只会是东施效颦，显得如此微不足道。</p></li></ol><h4 id="三、如何招到一个靠谱的程序员"><a href="#三、如何招到一个靠谱的程序员" class="headerlink" title="三、如何招到一个靠谱的程序员"></a>三、如何招到一个靠谱的程序员</h4><ol><li><p>简历看人</p><p>阅读简历永远是面试的第一步，你的简历中不应该包含错别字、文字不通或没有逻辑性，因为如果一个程序员连自己的简历都不愿意去仔细检查并完善的话，很难想象他写出来的代码质量会如何。然后你需要用简练的文字去描述自己，优秀的程序员往往善于归纳，并能够一针见血地发现问题或把一个问题说清楚。</p></li><li><p>给面试者 10 分钟介绍自己最擅长的</p><p>这样做的好处在于，可以很快地发现面试者的亮点，他能否有效地进行沟通，是否适合这个团队。</p></li><li><p>基础打牢了吗</p><p>有经验的面试官往往能够通过几个最简单的技术问题，判断出面试者的技术基础是否牢固，这不是为了证明他有多优秀，而是是用来判断他是否是一个合格的程序员。</p></li><li><p>技术的深度够了吗</p><p>具备牢固的技术技术，一般可以满足项目中普通程序员的要求了，但如果你需要找的是一个资深的程序员，那么你还需要对面试者的技术深度进行考察。</p></li><li><p>选择适合所在企业文化的人</p><p>一个常见的误区是，总是希望能为团队招到技术能力最强的人，而忽略了他是否与整个公司和团队的文化相匹配。这往往会造成不久后因为理念不同而不欢而散的结果。因此，在招聘程序员时，选择合适的往往比选择最优秀的更重要。</p></li><li><p>行为面试法</p><p>一个程序员是否能够很好地工作，不仅取决于他能否顺利完成开发任务，更重要的是在遇到一些特殊场景或问题时，他能否合理有效地处理和解决。因为程序员除了技术能力外，最应该具备的就是较强的独立解决问题的能力。</p></li><li><p>给他们一个虚拟任务</p><p>给面试者一个虚拟的任务，你能够看到很多细节，比如，面试者是否有良好的编码习惯，异常处理是否规范，代码逻辑是否缜密高效，以及他的开发效率是否足够高。</p></li></ol><h4 id="四、每个程序员都应该了解的一件事"><a href="#四、每个程序员都应该了解的一件事" class="headerlink" title="四、每个程序员都应该了解的一件事"></a>四、每个程序员都应该了解的一件事</h4><ol><li><p>读与技术无关的书</p><p>例如读一些，历史、经济、人文、艺术类的书籍，它们都能够帮助你丰富自己的知识和思想，使你变得更加全面和完善。</p></li><li><p>会写文档</p><p>当代码实现了它的功能之后，就很少有人会再去看它。但文档被阅读的概率就会大很多，优秀的文档能够让人们对你产生信任和好感，相反，质量差的文档则会使你的声誉受损。</p></li><li><p>学会包装</p><p>包装并不是一件坏事，通过包装自己可以非常有效的自我营销，包装之前我们需要知道什么是优秀的，然后精心制作。</p></li><li><p>尝试多讲</p><p>程序员的性格特点大多是内敛含蓄的，在一些正式的场合他们会显得对自己缺乏信心，这需要通过平时多锻炼来克服，比如可以在一些不那么重要的会议上去有意识地锻炼讲话，另外你还需要注意你讲的意思一定与你内心所想表达的是一致的。</p></li><li><p>建立社会化联系</p><p>一个完全封闭的程序员一定不是一个优秀的程序员。优秀的程序员往往愿意并善于与他人交流，分享自己的经验和想法，并在交流中获得有益的东西。</p></li></ol><h4 id="五、程序员的烦恼"><a href="#五、程序员的烦恼" class="headerlink" title="五、程序员的烦恼"></a>五、程序员的烦恼</h4><ol><li><p>是否还应该留在一线城市</p><p>对于这个问题，我是无法给出正确答案的。买房本身并不会给你带来持久的快乐，因为当你买完房后，你会欠一大笔债，需要用几十年才能还清；当你终于把欠款还清时，你又会觉得这套房子太小，已经不够一家人住，需要换一套更大的房子。你不会得到快乐，因为这些客观条件（钱财、房子）总是无法与你的主观期望相符。相反地，如果买房能够给你的家庭带来更稳定的生活，为孩子提供更好的成长环境，而这一切都能为你的生活赋予意义，并让你感到更加快乐的话，那你还是应该更坚定地留下，而非选择离开。</p></li><li><p>小公司做的事情太繁杂</p><p>在小型公司工作经常需要处理各种各样与开发无关的事情，这让他们无法专心专研技术。然而你却可以从中获得沟通能力、管理能力、建立更广的人脉、建立影响力，况且小事杂事更能体现你的能力，想站得越高，越需要具备解决各种繁杂问题的能力。</p></li><li><p>创业公司中的危机感</p><p>如果你所在的创业公司长时间没有起色的时候，你可能会想着换一份工作，但参与创业的过程对你来说仍会是一份宝贵的经历，是你应该加倍珍惜的，无论成功与否，经历一次完整的创业都会让你受益匪浅，你将学到很多在大公司仅仅做一颗螺丝钉所学不到的东西。</p></li><li><p>技术单一，想学习更多</p><p>程序员很应该去涉猎不通的技术甚至领域，但前提是你必须首先在某一门技术中扎得很深，技术是需要深耕的，深入学习一门主流的开发技术，并不断提升编程思维，比对很多技术栈都浅尝辄止要好很多，甚至当你学好一门技术后再去学习其他技术后你会发现会变得容易许多，因为它们之间往往都是相通的。</p></li><li><p>我想自学编程，应该学习哪一门语言</p><p>每一种编程语言都有它特定的目标和应用场景，你应该要有一个方向并选择适合的编程语言，但如果你真的没有任何思路，只是希望你学的这门编程语言能够有用，那么我推荐你学习<code>JavaScript</code>，因为它看起来是唯一可能在未来所有领域内得到应用的编程语言，从我们的移动设备，到传统的<code>Web</code>应用，再到服务端开发甚至硬件编程，它几乎无处不在。</p></li><li><p>大专学历，能进大公司吗？</p><p>目前所有大公司都以全日制本科学历作为最低要求，所以学历上的缺失缺失会成为你进入大公司的障碍。但也有一些例外情况：</p><ul><li>通过内部员工的推荐。</li><li>通过外包公司进入后，再转为内部员工。</li><li>努力成为某一领域的专家，或者建立个人影响力。</li></ul></li><li><p>非计算机专业学生，未来想从事软件开发</p><p>事实上，非计算机相关专业的学生很难与科班出生的应届生竞争，你应该慎重考虑自己是否真的有兴趣从事这一行业，而不是只是单纯为了高薪，因为没有足够的兴趣你将很难学好编程，而如果你已认清自己的方向，那么你应该努力学好一门编程语言，然后尽可能地做出一些实际的项目。</p></li><li><p>总是熬夜，睡眠不足</p><p>不要熬夜，通过牺牲睡眠来获得一两个小时的时间，到头来只会是恶性循环，得不偿失。合理安排时间，提升效率，保证有充足的睡眠，这将更有效率地投入到第二天的工作中。</p></li></ol><h4 id="六、提给年轻程序员的职涯建议"><a href="#六、提给年轻程序员的职涯建议" class="headerlink" title="六、提给年轻程序员的职涯建议"></a>六、提给年轻程序员的职涯建议</h4><ol><li><p>尽早确定你想做的事情</p><p>那些成功的人，往往是有着坚定目标，并持续努力的人。</p></li><li><p>10000 小时定律</p><p>无论你在哪个领域，只要能坚持为同一目标持续不断地努力，花费超过 10000 小时进行练习和钻研，那么你也一定能够成为该领域的杰出人才，并成为他人眼中的异类。</p></li><li><p>提高工作效率</p><p>对于提高工作效率，有两个建议：尝试不断加快自己的工作节奏，善于寻找或创造可以提高你工作效率（也可以是减少重复工作）的工具。</p></li><li><p>简明的沟通方式</p><p>尝试使用更简明的沟通方式，这不仅能使自己的工作更清晰，也能显著提高你与他人的沟通效率。</p></li><li><p>PKSS 与持续学习</p><p>PKSS 也就是说在业余的时间进行比拼，如果你把每天的碎片时间拿来进行学习，持续一段时间，你将比大多数人优秀。</p></li><li><p>学会情绪控制</p><p>如果提高自己的情绪控制能力，一个简单的方法就是对事不对人。当你对某一件事非常气愤时，首先，你需要问问自己发火有没有用，如果答案是否定的，那么为什么不静下心来想想怎样去解决问题呢？其次，你需要换位思考，你会发现很多时候对方不是故意为难你，而是也有他的考量和存在的现实问题。</p></li><li><p>让最优秀的人围绕在你身边</p><p>世界上大多优秀的作品，都是由很多非常优秀的人共同创造的，所以你需要和优秀的人结伴，他们能够指出你的错误，帮助你朝着正确的方向前进。</p></li><li><p>善于归纳和表达</p><p>很多情况需要你去汇报或发表，这时归纳与表达能力将显得非常重要，如果你不善言辞，你可以创造机会来进行训练，比如每天模拟进行一次讲演，经过一段时间，你会惊讶于自己所取得的突破。</p></li><li><p>掌握英语</p><p>英语能力对于程序员来说非常重要，所以你非常应该学习英语（这也是本人的痛点）。</p></li></ol><h3 id="第二章-谈实践与认知"><a href="#第二章-谈实践与认知" class="headerlink" title="第二章 谈实践与认知"></a>第二章 谈实践与认知</h3><h4 id="一、突破程序员思维"><a href="#一、突破程序员思维" class="headerlink" title="一、突破程序员思维"></a>一、突破程序员思维</h4><ol><li><p>什么是程序员思维</p><p>程序员思维是一种常人的思维+编程思维，在长期相互作用下产生的一种思维模式。它能够帮助程序员快速找到以程序方式解决现实问题的最优解。</p><p>对于有助于提升程序员思维的几点建议：</p><ul><li>长期不间断地编程实践。</li><li>持续学习与借鉴（参考）。</li><li>学会反思，并像专家一样思考。</li></ul></li><li><p>为什么要突破程序员思维</p><p>既然程序员思维对我们如此重要，那么我们为什么要突破它呢？有以下一些原因：</p><ul><li>新一代程序员不仅需要具备很强的编程能力，还需具备从设计、运营、测试等各种不同角度去进行分析和判断的能力。</li><li>当你从程序员转变为高级程序员、架构师等更高的职位时，需要你突破程序员思维，从更加人性化的角度去识别和解决问题。</li><li>突破程序员思维对你的生活也有帮助，多数程序员随着编程时间的增加，他们会变得不善与人沟通、甚至排斥与人交流，这使他们无法扮演好自己在生活中的角色。</li></ul><p>程序员思维是一把双刃剑，它既能帮助程序员写出优秀的代码，也能会阻碍程序员们的发展，成为进阶路上过不去的一道坎。</p></li><li><p>如何突破程序员思维</p><p>突破程序员的几种方法：</p><ul><li><p>透过技术发现问题的本质：</p><p>思考问题出现的原因，采用真正能解决问题的手段，而不是一味使用技术解决。</p></li><li><p>像专家一样给出意见：</p><p>沟通需求时，去理解用户所提出需求背后的真正原因，并像专家一样给出最优方案。</p></li><li><p>杂学并从中获得不同的视角：</p><p>要做到以上两点其实并不简单，这不仅需要你具备极强的技术功底，更需要你对问题所涉及的相关领域有足够的认识。你必须通过大量地学习编程之外的各种知识来完善自己的知识体系，并从中获得不同的视角。</p></li><li><p>找回创造力：</p><p>不可否认的是，目前的开发工作需要我们的创造力的情况并不多了，但我们仍需要创造力。关于如果找回创造力，有很多方法，关键在于你是否愿意坚持那样去做，比如：每天阅读、记录下那些转瞬即逝的想法。</p></li></ul></li></ol><h4 id="十、我似乎理解了编程的意义"><a href="#十、我似乎理解了编程的意义" class="headerlink" title="十、我似乎理解了编程的意义"></a>十、我似乎理解了编程的意义</h4><ol><li><p>编程是一项技能</p><p>在初学时，我们热爱编程技术，我们需要不断编程去提升技术，此时，编程的意义在于技术本身。</p></li><li><p>编程是去解决问题</p><p>在工作时，需要利用编程去解决一些问题，此时，编程的意义就不再局限于技术本身，而成了解决问题的理想工具。</p></li><li><p>编程是在表达，也是在创作</p><p>在进阶时，仿佛感受不到那些技术上的牵绊，开始自如地运用编程来实现那些你认为优秀的东西，此时，你是在通过编程进行着自我表达与创作。</p></li><li><p>编程是为了留下痕迹</p><p>在退休时，可能你以前写的优秀代码现在还运行在世界上的某个系统，支撑着一些人日常生活使用的工具。这些优秀代码是你留下的痕迹。</p></li></ol><h3 id="第三章-谈个人发展"><a href="#第三章-谈个人发展" class="headerlink" title="第三章 谈个人发展"></a>第三章 谈个人发展</h3><h4 id="一、那些优秀程序员身上的共同特质"><a href="#一、那些优秀程序员身上的共同特质" class="headerlink" title="一、那些优秀程序员身上的共同特质"></a>一、那些优秀程序员身上的共同特质</h4><ol><li><p>至少深入理解一门编程语言</p><p>优秀的程序员不仅熟练的掌握一门编程语言的语法和语义，他们还会：</p><ul><li>掌握这门语言的使用哲学：包括最佳实践、设计模式以及它们背后所蕴含的原则。</li><li>深入理解语言的特性：充分了解这些特性，能够帮助程序员更准确、高效地使用它们。</li><li>了解语言的局限：了解这些局限，并知道如何使用一些方法或技巧去绕过这些限制并解决问题。</li><li>理解语言的缺陷：了解这些缺陷，并尽可能在编程中避免涉及这些缺陷，会让你的程序在日后更易于维护。</li><li>了解语言的未来：了解语言的发展未来，才能让你更有信心地去应对未来。</li></ul></li><li><p>看上去有点傻</p><p>这因为程序员有点“傻”——知道自己不够强大，反而能使他们变得更加强大，他们一般：</p><ul><li>不会停止学习的脚步</li><li>使得他们在工作中变得更加严谨</li><li>帮助他们获得更好的想法</li></ul></li><li><p>他们都是现实主义者</p><p>那些成熟的程序员更加现实，他们关注于如何高效地解决问题，并在此基础上给用户带来好的感受。</p><ul><li>懂得平衡：他们理解时间、人力资源有限，所以他们会选择最简明有效的方法去实现需求或解决问题。</li><li>完成即是价值：与其进行飘无虚渺的设想，倒不如尝试用较小的代价先实现出某一个功能或产品，然后通过实际使用去证明它，继而在反复的迭代中不断完善。</li><li>尊重流程：他们尊重这些流程，但在某些时候他们也会对流程中阻碍自己效率的部分做适当的裁剪。</li><li>都很现实：这使得他们在不同的环境、团队、项目中都能快速获得成功。</li></ul></li><li><p>从自己的失败中学习</p><p>如果你希望变得更加优秀，那你必须具备直面失败的勇气，并学会从每一次失败中获得进步。</p></li><li><p>很懒却很高效</p><p>优秀的程序员非常珍视自己的时间，他们会利用一切手段提高效率，主要体现在：</p><ul><li>熟练操作键盘</li><li>熟练使用各种开发工具</li><li>善于使用或发明工具</li></ul></li><li><p>善于发现并改造轮子</p><ul><li>善于搜索</li><li>善于提问</li></ul></li><li><p>并行工作，有效利用时间</p><p>优秀的程序员能将所有的可支配的时间碎片化，利用这些时间片段，他们阅读、学习、开发、做个人项目。他们并不比任何人有更多的时间，他们只是更会利用时间。</p></li><li><p>具备不错的软技能</p><p>优秀的程序员往往具备：</p><ul><li>一定的语言表达能力</li><li>学会聆听</li><li>有足够的信心成为一个领导者</li><li>指导他人的能力</li><li>持续学习的能力</li><li>谦逊的态度</li><li>尊重每一个人</li><li>敢于承担责任</li></ul></li></ol><h4 id="六、建立自己的个人品牌"><a href="#六、建立自己的个人品牌" class="headerlink" title="六、建立自己的个人品牌"></a>六、建立自己的个人品牌</h4><ol start="3"><li>如何建立个人品牌<ul><li>起一个好名字：提高你的标示性。</li><li>打造一个个人网站：能方便的找到你。</li><li>写技术博客：能让更多人认识你。</li><li>开源自己的业余项目：获得追随者。</li><li>参与知名的开源项目：在将关领域成为专家，提升个人品牌。</li><li>参与更多线下活动：可以认识更多技术大牛、行业专家。</li></ul></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>读一本好书，能让你激起很多共鸣。读一个知识阅历比你丰富的人写的书，能让你少走很多弯路。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个前端在校生的2018年终总结</title>
      <link href="//post/5330f5ce.html"/>
      <url>//post/5330f5ce.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看到各大社区都有人发布自己的年终总结，我觉得这是一个很好的习惯，所以也来写一篇，既可以回顾这一年来到底做了什么，也能更好地明确下一年的目标。</p><p>先简单介绍一下自己，我今年 18 岁，是一名计算机专业的技校生。</p><p>这是学习前端开发的第二年，由于去年没有写，所以很有必要说一下我的前端入门经历。</p><h2 id="初入前端"><a href="#初入前端" class="headerlink" title="初入前端"></a>初入前端</h2><p>2016 年初，读技校，由于从小就对电脑感兴趣，所以我一下就选中了计算机专业。</p><p>同年年底，一次偶然的机会接触到前端，我立刻对此充满兴趣，并且展开了漫长的学习之路。</p><p>在去年的学习中，我掌握了网站基础布局、简单的<code>JS</code>函数式编程、使用<code>PHP</code>对数据库进行增删改查。</p><p>期间，写过一些简单的动画效果、小游戏以及图书后台管理系统（<a href="https://gd4ark.github.io/2018/09/13/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E4%B9%8B%E5%89%8D%E7%9A%84%E5%B0%8FDemo%EF%BC%88%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%89/">分享一些之前的小 Demo</a>）。</p><p>我之所以可以坚持下来，除了自身感兴趣外，要感谢菜鸟教程这个网站，在我什么都不懂时，没有它系统的<code>HTML</code>、<code>CSS</code> 教程，我很难坚持下来。</p><p>另外还要感谢我的师兄，他带给我很多思想上的教导和启发，让我认识到编程的奇妙。</p><p>说完入门经历，就来说说今年的学习经历。</p><h2 id="2-3-月-参加世赛选拔赛"><a href="#2-3-月-参加世赛选拔赛" class="headerlink" title="2-3 月 参加世赛选拔赛"></a>2-3 月 参加世赛选拔赛</h2><p>在上学期初，我参加了 45 届世界技能大赛的广东省选拔赛《网站设计与开发》这一项目，由于上一届的代表是我师兄，他获得了省第一、国第三的好成绩，所以我压力山大，经过一个月的练习、三天的角逐，最终以第七名（取前四）的成绩止步选拔，对此深感遗憾。</p><p>比赛采用 44 届世赛题目，分为三个模块：</p><ul><li>Global Fashion 2017（五小时、30%）</li><li>游戏设计与开发（五小时、35%）</li><li>公交路线查询系统开发（六小时、35%）</li></ul><h3 id="模块一"><a href="#模块一" class="headerlink" title="模块一"></a>模块一</h3><p>主要涉及内容有：<code>WordPress</code>主题、插件开发、<code>UI</code> 设计。</p><p>此模块成绩偏低，也在预料之中，设计能力欠佳，而主观分占比例较大。</p><h3 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h3><p>主要涉及内容有：<code>JavaScript</code>、<code>Canvas</code>。</p><p>个人比较擅长，提到的点基本做到。</p><p>但由于上午粗心漏交文件，导致扣了冤枉分。</p><p>github：<a href="https://github.com/gd4Ark/Star_Battle">https://github.com/gd4Ark/Star_Battle</a></p><h3 id="模块三"><a href="#模块三" class="headerlink" title="模块三"></a>模块三</h3><p>主要涉及的内容有：<code>Laravel</code>、<code>Vue</code>、<code>寻路算法</code>。</p><p>本题个人觉得较难，比较偏后端，接触不多，做得也是勉勉强强。</p><p>上午提交到服务器时数据库配置错误，导致上午的<code>API</code>测试进行不了，无法得分。</p><h3 id="赛后总结"><a href="#赛后总结" class="headerlink" title="赛后总结"></a>赛后总结</h3><p>成绩比我预想的要低，归根到底是自己太粗心、并且没有在试机时验证一些配置上的坑，导致丢了这么多冤枉分。</p><p>做题过程中，也接触到很多新内容，但时间过短加上本人资质不高，无法在短短一个月内啃完，且较偏后端，与我目前的学习方向不一致。</p><p>比赛专业度较高，但个人并不喜欢这种比赛的氛围，我较倾向经过思考后写出好的代码设计，而不是为了速度反复默写代码甚至为了更快写出嵌套十几层的<code>for</code>和<code>if</code>。</p><h2 id="4-6-月-成为工作室组长"><a href="#4-6-月-成为工作室组长" class="headerlink" title="4-6 月 成为工作室组长"></a>4-6 月 成为工作室组长</h2><p>比完赛后，我成为了我校的《网站开发工作室》的组长，主要帮助其他工作室人员解决问题、或提出问题并提供思路、引导他们学习新内容。</p><p>期间，帮助学校的英语老师开发用于发布教学文章的博客系统（基于<code>WordPress</code>）、更新并修复学校的“妙记单词”小游戏。</p><h2 id="9-月-一名合格的程序员"><a href="#9-月-一名合格的程序员" class="headerlink" title="9 月 一名合格的程序员"></a>9 月 一名合格的程序员</h2><p>这是一个新学期，我给自己定了几个目标：<code>做项目</code>、<code>写博客</code>、<code>学英语</code>。</p><p>其实之前我就注册过一个<code>GitHub</code>账号，但是在这个月开始我才正式使用这个平台，并且上传了一些自己写的小项目，同时也养成了在上面学习优秀代码和编程习惯，也开始使用别人的开源来避免重复造轮子、提高自己的工作效率。</p><p>还使用<code>Hexo</code>+<code>Github Page</code>搭建了属于自己的博客，以便我在上面发布一些学习记录文章以及生活点滴。</p><p>另外我也下载了一个百词斩 App 来增加自己的词汇量。</p><h2 id="10-月-Vue-入门项目-清技背单词"><a href="#10-月-Vue-入门项目-清技背单词" class="headerlink" title="10 月 Vue 入门项目 清技背单词"></a>10 月 Vue 入门项目 清技背单词</h2><p>这是学校的一个老师托我做的 WEB 小应用，于是我拿来做我正式入门<code>Vue</code>的第一个项目。</p><p>github：<a href="https://github.com/gd4Ark/learn_english">https://github.com/gd4Ark/learn_english</a></p><h2 id="11-月-参加市赛"><a href="#11-月-参加市赛" class="headerlink" title="11 月 参加市赛"></a>11 月 参加市赛</h2><p>我参加了本市的《网络空间安全》竞赛，全程 3 个小时，分为三个模块为：</p><ul><li>网络环境搭建（思科）</li><li>服务器渗透及安全加固（Linux、Win 2008）</li><li>网站渗透及安全加固</li></ul><p>比赛内容较为简单，专业度也不高，就不细说了，但有几点值得一提：</p><ol><li>开始不发布大致方向，所以我从开始就想太多，题目跟我练习的内容完全不一样。</li><li>最后一个星期发布题目，不过较简单，但坑的是最后一题只有题目没有源代码，幸好后来我按照题目内容写了一个网站来测试。</li><li>最后两天才公布源代码，遥想而知如果不会写网站，这一题就没法做了。</li><li>评分标准写得不明不白。</li></ol><p>结果可想而知，主办方选手以一小时不到的速度完成，最终痛失亚军，含泪夺冠。</p><p>而我抱着亚军笑出了猪声：“哈哈哈哈，又混了一个证书！”。</p><h2 id="12-月-第二个-Vue-项目"><a href="#12-月-第二个-Vue-项目" class="headerlink" title="12 月 第二个 Vue 项目"></a>12 月 第二个 Vue 项目</h2><p>这个月我迎来了一个新项目，这次我依然是前端使用<code>Vue</code>，而后端是使用<code>Lumen</code>框架。</p><p>在这个项目中，我开始慢慢熟用<code>Vue</code>，开始使用<code>Vue</code>的一些高级特性，等项目结束后，我会以写文章的形式来记录项目过程中遇到的问题和解决方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在是凌晨 2 点，一口气从晚上十点写到现在，写作过程中不断回忆这一年来的学习经历，才发现，学习已经成了习惯、成了我日常的一部分。</p><p>最后感谢自己的坚持，感谢自己在每次遇到问题时的冷静执着，不轻言放弃。这影响了我的性格，或也将影响我的一生。</p><h2 id="展望-2019"><a href="#展望-2019" class="headerlink" title="展望 2019"></a>展望 2019</h2><h3 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h3><p>在校时间还有一个学期，明年 6 月份就要离校找工作了，那么我希望通过下个学期来完成几个目标：</p><ul><li>对所有已学知识进行梳理、深挖，目的是写出一篇通熟易懂的文章。</li><li>继续增加英语词汇量。</li></ul><h3 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h3><p>希望能在广州找到一份喜欢的工作，尽快投入到工作中，以获得更多成长机会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS题目系列（4） - 文字穿透遮罩层</title>
      <link href="//post/105732a8.html"/>
      <url>//post/105732a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在我刚开始学习前端开发不久的时候，曾在一个网站看到过一个效果，当时费尽脑筋，又是<code>Canvas</code>、又是<code>SVG</code>，还是无法实现（其实<code>SVG</code>好像是有办法可以实现的，但当时觉得麻烦就没弄）。</p><p>效果就是这样的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxlh53ze9sj31es0lmq6s.jpg"></p><p>这个效果的难点在于，如何让文字穿透过遮罩层，但是这样好像很难。</p><p>直到最近，我看到了张鑫旭大神的一篇<a href="https://www.zhangxinxu.com/wordpress/2011/04/%E5%B0%8Ftipcss3%E4%B8%8B%E7%9A%84%E6%B8%90%E5%8F%98%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">文章</a>，文中讲述了如何给文字添加背景颜色（也可以是背景图片），顿时醍醐灌顶，想到了这样一个解决方案：</p><ol><li>里外两个层，尺寸一样，设置同一个背景图片。</li><li>外层通过伪元素实现遮罩。</li><li>里层绝对定位，将背景添加到文字上。</li></ol><p>可能我文字表达地不是很清晰，下面用代码讲解一下。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果你点进了上面张鑫旭大神的那篇文章，你就知道主要是两行：</p><ol><li><code>-webkit-text-fill-color: transparent</code></li><li><code>-webkit-background-clip: text</code></li></ol><p>简单说一下作用：</p><p><code>-webkit-text-fill-color: transparent</code></p><blockquote><p>将文字颜色变成透明，但是经过尝试，发现使用<code>color：transparent</code>效果也一样，应该是浏览器为向后兼容所拟定的一个新属性，因为如果不支持文字添加背景，但又通过<code>color：transparent</code>将文字变成了透明，文字就显示不出来了。</p></blockquote><p><code>-webkit-background-clip: text</code></p><blockquote><p>背景被裁剪为文字的前景色。</p></blockquote><p>那么，下面我们试一下实现，这里只展示主要代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>I ❤ CSS<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>,</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;https://gd4ark.github.io/CSS-Carousel/image/2.jpg&#x27;</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  -webkit-text-fill-<span class="attribute">color</span>: transparent;</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>: text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线查看，可以修改文字哦： <a href="https://gd4ark.github.io/blog_demos/2018-11-26/02.html">链接</a></p><p>完整代码：<a href="https://github.com/gd4Ark/blog_demos/blob/master/2018-11-26/02.html">链接</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>没错，这个困扰我多年的效果就是这么简单，果然还是懂得少，哪知道张鑫旭大神早在<code>2011</code>年就给出了答案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS题目系列（3）- 实现文字切割效果</title>
      <link href="//post/bdd845bb.html"/>
      <url>//post/bdd845bb.html</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有一天逛 <a href="https://codepen.io/">Codepen</a> 的时候，看到这么一个效果：将文字上下切开两半。</p><p>点进去看了一下代码，发现原理很简单，大概就是通过伪类使用<code>attr()</code>函数获取内容，然后进行定位。</p><p>你可以点下方链接查看效果：</p><p><a href="https://gd4ark.github.io/blog-demos/2018-11-26/01.html">https://gd4ark.github.io/blog-demos/2018-11-26/01.html</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先让两个伪元素获取到属性的值，并且将位置调好。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">data-content</span>=<span class="string">&quot;I Love CSS&quot;</span>&gt;</span>I Love CSS<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="comment">/* 通过 attr 获取属性的值 */</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-content);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#cc3333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切割部分 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="comment">/* 上对齐 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 剩余部分 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="comment">/* 下对齐 */</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候的效果是这样的，所以我们要把剩余部分的文字进行底部对齐。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxlfhxdtoyj30xa0h474y.jpg"></p><p>这里使用<code>flex</code>布局对齐，剩余部分改为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 剩余部分 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxlfobhqnbj30wj0eyaap.jpg"></p><p>到现在，就已经做好，只要在切割部分上应用动画，即可实现炫酷的切割效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 切割部分 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: action <span class="number">5s</span> <span class="number">1s</span> ease alternate infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> action &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">5vw</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">60%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">5vw</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：<a href="https://github.com/gd4Ark/blog-demos/blob/master/2018-11-26/01.html">https://github.com/gd4Ark/blog-demos/blob/master/2018-11-26/01.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不得不说那些大神们的脑洞真是大，如果没见过这个效果之前，我是无论如何都想不到可以如此简单的实现这么炫酷的切割效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS题目系列（2） - 实现一个固定比例盒子</title>
      <link href="//post/c6e0afe2.html"/>
      <url>//post/c6e0afe2.html</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在开发过程中，会有这么一个情况，需要将一个盒子的尺寸定义为固定比例，且尺寸需根据视图的尺寸来进行缩放，也就是响应式，常见的多如有矩形、圆形等。</p><p>下面我将使用下面的例子为大家进行讲解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxl6othpvtg31af0pxgtv.gif"></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实实现这个效果，有多种方法，下面逐一介绍。</p><h3 id="1、垂直方向的-padding"><a href="#1、垂直方向的-padding" class="headerlink" title="1、垂直方向的 padding"></a>1、垂直方向的 padding</h3><p>相信大家对<code>padding</code>都不陌生，但你知道他是如何取值的吗？</p><p>看一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding">MDN</a>中对<code>padding</code>给出的解释：</p><blockquote><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>指定一个，两个，三个或四个下列的值：</p><ul><li><p><code>&lt;长度&gt;</code></p><p>可指定非负的固定宽度. See <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length"><code>&lt;length&gt;</code></a> for details</p></li><li><p><code>&lt;百分比&gt;</code></p><p>相对于包含块的宽度</p></li><li><p><strong>指定一个值时 该值指定四个边的内边距</strong></p></li><li><p><strong>指定两个值时 第一个值指定上下两边的内边距 第二个指定左右两边的内边距</strong></p></li><li><p><strong>指定三个值时 第一个指定上边的内边距</strong> <strong>.第二个指定左右两边 第三个指定下边</strong></p></li><li><p><strong>指定四个值时分别为上 右 下 左（顺时针顺序）</strong></p></li></ul></blockquote><p>也就是说，<strong>给<code>padding</code>的值设定为百分比时，将根据父容器的宽度来计算。</strong></p><p>现在假设我们有一个<code>div</code>，我们希望它的尺寸能根据<code>body</code>（它的父容器）的宽度来实现固定比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实这里的<code>padding-bottom</code>换成<code>padding-top</code>也一样可以实现。</p></blockquote><p>没错，就这么简单，我们已经实现了文章开头所展示的效果。</p><p>但是我们使用这种方法的时候需要注意几点：</p><ol><li>不需要设定<code>height</code>，最好就是手动设定为<code>0</code>。</li><li>子元素需要设定为绝对定位（父容器为相对定位），否则子元素将被<code>padding</code>挤出去。</li></ol><h4 id="其它比例"><a href="#其它比例" class="headerlink" title="其它比例"></a>其它比例</h4><p>前面实现的是一个正方形比例的，那如果我想要是<code>16:9</code>的呢？</p><p>那我们将根据一个公式：<code>width * x / y</code>计算，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(<span class="number">50%</span> * <span class="number">9</span> / <span class="number">16</span>);</span><br><span class="line">  <span class="comment">/* 或者 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">28.125%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、视窗单位"><a href="#2、视窗单位" class="headerlink" title="2、视窗单位"></a>2、视窗单位</h3><blockquote><p>视窗是你的浏览器实际显示内容的区域——换句话说是你的不包括工具栏和按钮的网页浏览器。这些单位是<code>vw</code>,<code>vh</code>,<code>vmin</code>和<code>vmax</code>。它们都代表了浏览器（视窗）尺寸的比例和窗口大小调整产生的规模改变。</p></blockquote><p>也就是说，<strong>网页的宽度是<code>100vw</code>，取一半就是<code>50vw</code>，无论怎么缩放都是一半，而且这个一半不止可以用在<code>width</code>上。</strong></p><p>所以：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个正方形就出来了，简单吗？？？</p><h4 id="其它比例-1"><a href="#其它比例-1" class="headerlink" title="其它比例"></a>其它比例</h4><p>跟上面一样，通过公式可以得到：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(<span class="number">50vw</span> * <span class="number">9</span> / <span class="number">16</span>);</span><br><span class="line">  <span class="comment">/* 或者 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">28.125vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.w3cplus.com/css/aspect-ratio.html">https://www.w3cplus.com/css/aspect-ratio.html</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/">https://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/</a></li><li><a href="https://blog.csdn.net/qq_36367494/article/details/79266037">https://blog.csdn.net/qq_36367494/article/details/79266037</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>通过以上两种方法，以后实现固定比例的盒子是不是变得简单起来了？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS题目系列（1） - 可滚动的Table</title>
      <link href="//post/abb77fd2.html"/>
      <url>//post/abb77fd2.html</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在开发中，有这样一个需求，<code>Table</code>的表头不动，表身可以滚动，效果请点击以下链接查看：</p><p><a href="https://gd4ark.github.io/blog-demos/2018-11-25/01.html">https://gd4ark.github.io/blog-demos/2018-11-25/01.html</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>假设我们有一个这样结构的表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Position<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Score<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Time<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里为了方便展示 只显示一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>15<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置表身样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tbody</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，表身已经实现了滚动，但是有个问题，<code>td</code>缩在了一堆，如下：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxkejbopq1j30e907c0sp.jpg"></p><p>加上这个就好了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">thead</span>,</span><br><span class="line"><span class="selector-tag">tbody</span> <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">table-layout</span>: fixed; <span class="comment">/* 使用表格固定算法 必须配合上面一起使用 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/006mS5wEgy1fxkejbopq1j30e907c0sp.jpg"></p><p>完整代码：<a href="https://github.com/gd4Ark/blog-demos/blob/master/2018-11-25/01.html">https://github.com/gd4Ark/blog-demos/blob/master/2018-11-25/01.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>刚刚开始写文章，很多地方写的不够好，望谅解，我会慢慢改进的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win2008 R2 FTP 服务器实训</title>
      <link href="//post/e751de68.html"/>
      <url>//post/e751de68.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求使用 <code>IIS</code> 服务器搭建 <code>FTP</code>服务，具体：</p><p>在根目录<code>ftp_root</code>下，创建两个子目录<code>pub</code>和<code>root</code>。</p><p>其中：</p><ol><li><code>ftp_user</code>用户对两个子目录均有完全控制权限。</li><li>匿名用户对<code>pub</code>有写权限（只能创建，不能修改或删除），对<code>root</code>有读权限。</li><li>在根目录只有读权限。</li></ol><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>本次实训的服务器安装在虚拟机上，通过桥接模式，在本机上进行测试。</p><p>这里假设你已经安装好 <code>IIS</code>以及<code>FTP</code>服务器，并且按题目要求创建好目录以及用户（<code>ftp_user</code>）。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="创建-FTP-服务器"><a href="#创建-FTP-服务器" class="headerlink" title="创建 FTP 服务器"></a>创建 FTP 服务器</h3><p>1、创建 <code>FTP</code> 站点</p><ul><li>打开 <code>IIS</code>-&gt; 展开主机名-&gt; 网站 -&gt; 右键 -&gt; 添加 <code>FTP</code>站点</li></ul><p>2、填写站点信息</p><ul><li>填写站点名称 -&gt; 选择物理路径（你的 ftp 根目录） -&gt; 下一步</li></ul><p>3、绑定和 SSL 设置</p><ul><li>填写 你的 IP 地址 -&gt; 端口默认（21） -&gt; SSL（无） -&gt; 下一步</li></ul><p>4、身份验证与授权信息</p><ul><li>这里我们后面再设置，直接完成</li></ul><h3 id="配置相关权限"><a href="#配置相关权限" class="headerlink" title="配置相关权限"></a>配置相关权限</h3><h4 id="1、根目录的权限"><a href="#1、根目录的权限" class="headerlink" title="1、根目录的权限"></a>1、根目录的权限</h4><p>点击左侧 ftp 站点（小地球图标），在 ftp 主页点击身份验证，勾选基本和匿名。</p><p>在 ftp 主页点击授权规则，添加两个允许规则</p><ul><li>所有匿名用户，权限是读取，完成</li><li>指定的用户，填写上面创建的用户<code>ftp_users</code>，权限是读取，完成</li></ul><blockquote><p>如果配置正常，<code>FTP</code> 已经可以访问（通过基本验证和匿名登录）</p></blockquote><h4 id="2、pub-目录的权限"><a href="#2、pub-目录的权限" class="headerlink" title="2、pub 目录的权限"></a>2、pub 目录的权限</h4><p>展开左侧 ftp 站点（小地球图标），点击<code>pub</code>，在 pub 主页点击授权规则，把两个规则的权限都改成：读取和写入。</p><h5 id="配置匿名用户的权限"><a href="#配置匿名用户的权限" class="headerlink" title="配置匿名用户的权限"></a>配置匿名用户的权限</h5><p>再点左侧<code>pub</code>，右侧操作 -&gt; 编辑权限 -&gt; 安全 -&gt; 编辑 -&gt; 添加 -&gt; 输入 <code>IUSR</code> -&gt; 确定</p><p>接着上面，高级 -&gt; <code>IUSR</code> -&gt; 更改权限 -&gt; 编辑 ，权限设置如下：</p><ul><li>允许 ： 完全控制</li><li>拒绝 ：<ul><li>删除子文件夹及文件</li><li>删除</li><li>更改权限</li></ul></li></ul><blockquote><p>可以测试下 在匿名登录下，<code>pub</code> 目录是否只能创建不能删除或修改</p></blockquote><h5 id="配置基本用户的权限"><a href="#配置基本用户的权限" class="headerlink" title="配置基本用户的权限"></a>配置基本用户的权限</h5><p>接着上面 -&gt; 编辑权限 -&gt; 安全 -&gt; 编辑 -&gt; 添加 -&gt; 输入 <code>ftp_user</code> -&gt; 允许（完全控制） -&gt; 确定</p><blockquote><p>可以测试下 在基本登录下，是否对<code>pub</code>目录完全控制权限</p></blockquote><h4 id="3、root-目录的权限"><a href="#3、root-目录的权限" class="headerlink" title="3、root 目录的权限"></a>3、root 目录的权限</h4><p>展开左侧 ftp 站点（小地球图标），点击<code>root</code>，在 root 主页点击授权规则，把基本用户规则的权限改成：读取和写入。</p><h5 id="配置基本用户的权限-1"><a href="#配置基本用户的权限-1" class="headerlink" title="配置基本用户的权限"></a>配置基本用户的权限</h5><p>接着上面 -&gt; 编辑权限 -&gt; 安全 -&gt; 编辑 -&gt; 添加 -&gt; 输入 <code>ftp_user</code> -&gt; 允许（完全控制） -&gt; 确定</p><blockquote><p>在基本登录下，是否对<code>root</code>目录完全控制权限</p></blockquote><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>实训过程中，遇到了几个坑，记录一下。</p><h4 id="虚拟主机名"><a href="#虚拟主机名" class="headerlink" title="虚拟主机名"></a>虚拟主机名</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>在我创建 <code>FTP</code>服务时，填写了一个虚拟主机名（想要通过域名访问），结果发现，无论是域名还是 IP 都无法打开，提示无法访问文件夹。</p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><blockquote><p>对于虚拟主机名，FTP 客户端需要使用带有“ <strong>ftp.contoso.com | username</strong> ” 等语法的管道（垂直线）字符来指定其登录凭据。<a href="https://forums.iis.net/t/1226421.aspx?Enable+Virtual+Host+Name">链接</a></p></blockquote><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>答案自然是删除虚拟主机名。</p><p>在<code>ftp</code>主页右侧 -&gt; 绑定</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>前一个问题中提到，想要添加一个域名访问，但除了虚拟主机名，我们还能用什么方法呢？</p><h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><p>经过尝试，我发现直接在<code>DNS</code>服务器中添加一个主机头为<code>ftp</code>的记录即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，在 Win2008 上搭建一个服务器不算太难，但相对于用鼠标操作，我更倾心于在 <code>Linux</code>上用命令完成。</p><p>感谢您的观看，希望能对您有帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Windows 中设置静态 IP 却始终变回 DHCP 获取问题</title>
      <link href="//post/28baf5fd.html"/>
      <url>//post/28baf5fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>不知道为什么，我们学校的工作室里每一台电脑都存在这样一个 <code>BUG</code>，当你设置了静态 <code>IP</code> 后，点击确定，打开 <code>ipconfig</code> 查看，<code>IP</code> 已经设置上了，然而当你再次打开配置 <code>IP</code> 的界面时，却惊讶地发现，他居然神奇地变回了自动获取，这时你重新配置了一个<code>IP</code>，<code>ipconfig</code>再一看，居然有两个 <code>IP</code> 。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>当我使用中文去 Google 搜索时，并没有得到能够解决问题的答案，然后我把关键词转换成英文，发现了这个帖子：</p><p><a href="https://support.managed.com/kb/a433/bug-ip-addresses-do-not-save-and-always-reset-to-dhcp.aspx">https://support.managed.com/kb/a433/bug-ip-addresses-do-not-save-and-always-reset-to-dhcp.aspx</a></p><p>并且成功的解决了我的问题。</p><p>以下是解决方法：</p><ol><li>打开 <code>运行</code>，输入 <code>regedit</code>，进入注册表</li><li>找到 <code>HKEY_LOCAL_MACHINE \SYSTEM\CurrentControlSet\Control\Network</code></li><li>删除 <code>config</code></li><li>打开 <code>运行</code>，输入 <code>ncpa.cpl</code>，进入网络连接</li><li>本地连接 - 右键 - 属性 - 确定</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锐捷无线AP学习笔记 - 入门篇</title>
      <link href="//post/d69467be.html"/>
      <url>//post/d69467be.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>我的 AP 型号为： RG-AP220-SE</p><p>系统版本为： RGOS 11.1(5)B8</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>本次实训目的是创建一个热点，需求如下：</p><ul><li>创建一个 SSID 为 <code>ruijie</code> 的 WLAN</li><li>能够自动获取 IP 地址（DHCP）</li><li>为 WLAN 添加一种加密方式</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先，我们要先把 AP 切换到胖模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie#</span><span class="bash"> ap-mode fat</span></span><br></pre></td></tr></table></figure><p>可以用以下命令查看 AP 当前的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie#</span><span class="bash"> show ap-mode</span></span><br></pre></td></tr></table></figure><p>接着开启一下无线广播转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> data-plane wireless-broadcast <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure><p>好了，现在就可以开始我们的实例了。</p><h3 id="创建-WLAN"><a href="#创建-WLAN" class="headerlink" title="创建 WLAN"></a>创建 WLAN</h3><p>创建一个 VLAN</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> vlan 1</span></span><br><span class="line"><span class="meta">Ruijie(config-vlan)#</span><span class="bash"> ex</span></span><br></pre></td></tr></table></figure><p>以太网接口封装 VLAN</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> int gigabitEthernet 0/1</span></span><br><span class="line">Ruijie(config-if-GigabitEthernet 0/1)# encapsulation dot1Q 1 // 对应 vlan</span><br><span class="line">Ruijie(config-if-GigabitEthernet 0/1)# ex</span><br></pre></td></tr></table></figure><p>设置一下 AP 的管理地址（管理地址与网关处于相同网段下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> int bVI 1</span></span><br><span class="line">Ruijie(config-if-BVI 1)# ip address 10.10.34.250 255.255.255.0</span><br><span class="line">Ruijie(config-if-BVI 1)# ex</span><br></pre></td></tr></table></figure><blockquote><p>注：此时，在你本机上 ping 这个地址，是可以通的（若不能 ping 通，且配置正确，请看文章结尾）。</p></blockquote><p>定义 SSID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> dot11 wlan 1</span></span><br><span class="line"><span class="meta">Ruijie(dot11-wlan-config)#</span><span class="bash"> vlan 1</span></span><br><span class="line"><span class="meta">Ruijie(dot11-wlan-config)#</span><span class="bash"> broadcast-ssid</span></span><br><span class="line"><span class="meta">Ruijie(dot11-wlan-config)#</span><span class="bash"> ssid ruijie</span></span><br><span class="line"><span class="meta">Ruijie(dot11-wlan-config)#</span><span class="bash"> ex</span></span><br></pre></td></tr></table></figure><p>创建射频卡子接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> int dot11radio 1/0.1</span></span><br><span class="line">Ruijie(config-subif-Dot11radio 1/0.1)# encapsulation dot1Q 1 // 对应 vlan</span><br><span class="line">Ruijie(config-subif-Dot11radio 1/0.1)# ex</span><br></pre></td></tr></table></figure><p>SSID 和 射频卡进行关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> int dot11radio 1/0</span></span><br><span class="line">Ruijie(config-if-Dot11radio 1/0)# wlan-id 1 // 对应 wlan-id</span><br><span class="line">Ruijie(config-if-Dot11radio 1/0)# ex</span><br></pre></td></tr></table></figure><blockquote><p>注： 这时 AP 已经发出了无线信号，你可以在手机上搜索得到。</p></blockquote><p>设置 AP 的默认路由（也就是这个局域网的网关）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> ip route 0.0.0.0 0.0.0.0 10.10.34.254</span></span><br></pre></td></tr></table></figure><blockquote><p>注：做这一步之前，最好确认一下 AP 是否与默认路由相通</p></blockquote><p>这时，通过手动配置静态 IP，是可以成功连接 WLAN 的。</p><h3 id="DHCP-服务"><a href="#DHCP-服务" class="headerlink" title="DHCP 服务"></a>DHCP 服务</h3><p>通常来说，一个网络环境下会有专门的 DHCP 服务器，所以不需要 AP 来分配地址。</p><p>然而，我这里并没有 DHCP 服务器，那就只能靠 AP 来分配了。</p><p>首先，开启 DHCP 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> service dhcp</span></span><br></pre></td></tr></table></figure><p>排除地址，low - high</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> ip dhcp excluded-address 10.10.34.8 10.10.34.254</span></span><br></pre></td></tr></table></figure><blockquote><p>注：我把 8 - 254 的 IP 排除了，所以剩下的范围就是 1 - 7。</p></blockquote><p>配置地址池，名字为 test，以及地址段、网关、DNS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> ip dhcp pool <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">Ruijie(dhcp-config)#</span><span class="bash"> network 10.10.34.0 255.255.255.0</span></span><br><span class="line"><span class="meta">Ruijie(dhcp-config)#</span><span class="bash"> default-router 10.10.34.254</span></span><br><span class="line"><span class="meta">Ruijie(dhcp-config)#</span><span class="bash"> dns-server 8.8.8.8</span></span><br></pre></td></tr></table></figure><p>这时，手机上是可以通过 DHCP 方式 获取到 IP 地址的。</p><h2 id="WLAN-加密"><a href="#WLAN-加密" class="headerlink" title="WLAN 加密"></a>WLAN 加密</h2><p>常见的 WLAN 加密方式分为三种：</p><ul><li>WEP 加密</li><li>PSK 接入认证</li><li>802.1x 接入认证</li></ul><p>关于加密方式详细的介绍，请看：<a href="http://www.ruijiery.com/uploadfile/2016/0621/20160621124933455.pdf">手册 WLAN 安全节章</a> 。</p><p>配置加密方式都需要进入到相关的 wlan-id 下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config)#</span><span class="bash"> wlansec 1 // 对应 wlan-id</span></span><br></pre></td></tr></table></figure><h3 id="WEP-方式"><a href="#WEP-方式" class="headerlink" title="WEP 方式"></a>WEP 方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security static-wep-key encryption 40 ascii 1 12345</span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security static-wep-key authentication  shellare-key</span></span><br></pre></td></tr></table></figure><blockquote><p>注： 密码长度可选为 （40 | 103），40 = 5 个，103 = 13 个</p></blockquote><h3 id="PSK-接入认证-WPA"><a href="#PSK-接入认证-WPA" class="headerlink" title="PSK 接入认证 (WPA)"></a>PSK 接入认证 (WPA)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security wpa <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security wpa ciphers aes <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security wpa akm psk <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security wpa akm psk set-key ascii 123456789</span></span><br></pre></td></tr></table></figure><blockquote><p>注：密码不得少于 8 个 字符</p></blockquote><h3 id="PSK-接入认证-WPA2"><a href="#PSK-接入认证-WPA2" class="headerlink" title="PSK 接入认证 (WPA2)"></a>PSK 接入认证 (WPA2)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security rsn <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security rsn ciphers aes <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security rsn akm psk <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash"> security rsn akm psk set-key ascii 123456789</span></span><br></pre></td></tr></table></figure><blockquote><p>注：密码不得少于 8 个 字符</p></blockquote><h3 id="802-1x-接入认证"><a href="#802-1x-接入认证" class="headerlink" title="802.1x 接入认证"></a><strong>802.1x</strong> 接入认证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash">security wpa <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Ruijie(config-wlansec)#</span><span class="bash">security wpa ciphers aes <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure><h2 id="说一下遇到的问题"><a href="#说一下遇到的问题" class="headerlink" title="说一下遇到的问题"></a>说一下遇到的问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在这次实训中，我用到 vlan 1，一切正常。</p><p>但是，当我使用另外的 vlan （vlan 10）时，发现在本机并不能 ping 通 AP 的管理地址。</p><p>这个时候，AP 不能与网关连通，所以无法正确配置 DHCP 服务器（手动配置静态没有问题）。</p><h3 id="看法"><a href="#看法" class="headerlink" title="看法"></a>看法</h3><p>初步看来，可能是因为我机房的二层交换机的所有接口都在 vlan 1 下，且没有配置为 trunk 模式，故不能 ping 通。</p><p>但是我不知道这个交换机的密码，所以无法取证。</p><p>如果你也遇到这个问题，且有靠谱的解决方案，请联系我，谢谢。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="http://www.ruijiery.com/uploadfile/2016/0621/20160621124933455.pdf">http://www.ruijiery.com/uploadfile/2016/0621/20160621124933455.pdf</a></p></li><li><p><a href="https://blog.csdn.net/u012318074/article/details/52599540">https://blog.csdn.net/u012318074/article/details/52599540</a></p></li><li><p><a href="https://wenku.baidu.com/view/ab3addf8af1ffc4ffe47ac93.html">https://wenku.baidu.com/view/ab3addf8af1ffc4ffe47ac93.html</a></p></li><li><p><a href="https://wenku.baidu.com/view/fcc1dda9d0d233d4b14e6973.html">https://wenku.baidu.com/view/fcc1dda9d0d233d4b14e6973.html</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 无线AP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
