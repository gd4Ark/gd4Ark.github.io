<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>4Ark × Blog</title>
    <link>https://4ark.me/</link>
    
    <atom:link href="https://4ark.me/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Art and beauty can be created on a computer.</description>
    <pubDate>Tue, 06 Feb 2024 18:11:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2023 年度总结</title>
      <link>https://4ark.me/post/2023-summary.html</link>
      <guid>https://4ark.me/post/2023-summary.html</guid>
      <pubDate>Wed, 07 Feb 2024 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今年无疑是我最摆烂的一年，竟然整整一年没有更新过博客，所以上一篇文章还停留在&lt;a href=&quot;https://4ark.me/post/20</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年无疑是我最摆烂的一年，竟然整整一年没有更新过博客，所以上一篇文章还停留在<a href="https://4ark.me/post/2022-summary.html">《2022 年度总结》</a>。</p><p>着实惭愧，是因为我今年变懒了吗？是也不是，但可以说今年是我参加工作以来，变化最大的一年。</p><h2 id="一段奇妙的经历"><a href="#一段奇妙的经历" class="headerlink" title="一段奇妙的经历"></a>一段奇妙的经历</h2><p>年后复工不久，我所在的项目组就被解散了，团队成员接连离职，一时间变得很迷茫，不知道该何去何从。</p><p>那段时间心态有点蚌埠住，这打乱了我的计划，导致晚上经常失眠，所以下班后，索性也不去想太多、开摆！</p><p>长期以来，我发现每当自己在工作中面对具有挑战性的工作或能从中得到满足感时，便会激发学习和写作的动力。反之，如果在工作缺乏挑战性和无趣，就会陷入消极的摆烂状态。对于这种现象，我称之为：「动力反馈循环」。</p><p>这种现象既有好的一面也有不好的一面，但它确实让我摆烂了一段时间。</p><p>但在某天，事情发生了变化，机缘巧合下，我为帮助一位朋友解决他所面临的问题，用相近一个小时写了个插件。出乎意料的是，这个插件竟然在接下来的数个月里为我带来了远超日常工资的额外收入。</p><p>这个插件技术含量并不高，对任何程序员来说都是易如反掌的事情，但对普通人来说，它能让成本降低无数倍，所以他们拥有强烈的付费意愿，最终一传十、十传百，很快，我的微信好友从 200 人不到变成 1000+。</p><p>我承认这完全是靠运气，并不意味着我拥有多厉害的商业洞察力，更无法保证能够复刻商业模式，一切皆运气。</p><p>我知道这只是一项短暂的副业，不具有持续性。因此，当收入开始下滑时，我便决定将插件出售。</p><p>在这过程中，最大的收获肯定是金钱，我从来没有想象过，赚钱竟然如此容易。</p><p>请原谅我这种没见过世面的人借用并改编一下罗格那句话：「睡觉睡到自然醒， 收钱收到手抽筋」。</p><p>但除此之外，我还收获了什么呢？我认为，首先要明白了一个<del>鸡汤</del>道理：</p><blockquote><p>成功的关键也许不是英明的决策，运气也起着关键作用。然而，这种运气并非完全偶然，它是你日常积累的结果。为了在机遇到来时能够比别人更快地抓住它，关键仍在于持续的付出和努力。</p></blockquote><p>我以前也开发过类似的插件，但未曾考虑过收费。以往，能够获得满足感的事情就是别人的答谢以及小额红包，这是我第一次尝试盈利，没想到效果出奇地好。当你要考虑对产品进行收费时，不妨先问一下自己是否愿意付费。</p><p>还有不必一开始追求完美，试想一小时不到写出来的插件肯定很粗糙，甚至是半自动的，但并不妨碍它正常工作。正如 <a href="https://lutaonan.com/blog/my-extension-sold-1k-yuan/#%E6%80%BB%E7%BB%93">Randy</a> 所说：自动化可以做也必须做，但不是从 day one 就开始做。</p><p>在没有摸清楚客户的习惯前，就贸然通过现有思维去解决问题，哪怕做得再多，方向错了，也许都是徒劳。</p><p>举个例子，如果我们要搞个下单或会员功能，可能大家都会想着弄个小程序或网站，让客户自己来操作。然而事实上客户并不买单，你要相信并理解，哪怕现在都 2024 年了，还真有人用不来这些东西。客户作为衣食父母，有时你要兼容他们，在这些客户的思维里，远不如直接微信转账给你来得方便，而不是一个冷冰冰的小程序。</p><p>所以上面那句「收钱收到手抽筋」可不是开玩笑的。想想看，如果每天有几百人微信转账给你，但每笔就几块钱…</p><p>当然即便是这样的局面，也是有方法可以在不改变客户习惯的前提去实现自动化的，而此时做自动化才是真正有价值的，但已经不是一开始想象的那样客户通过小程序充值云云这种思路，所以关键点仍是让客户能够接受。</p><p>以上是我觉得除了金钱以外，更为宝贵的经验，它可以让我在下一次做出更多正确的选择，少踩一些坑。</p><h2 id="送自己的礼物"><a href="#送自己的礼物" class="headerlink" title="送自己的礼物"></a>送自己的礼物</h2><p>今年，我给自己送了两份礼物。首先，在年初，我决定换一台电脑。在综合考虑了 M1 Pro 和 M2 Pro 之后，我最终选择了 M1 Pro，配置为 16GB RAM + 512GB 存储，通过 PDD 的百亿补贴以 10500 元的价格入手，香的嘞。一年的使用下来，它的性能完全满足我的需求，从未出现过卡顿，是我今年最满意的购物之一。</p><p>第二个礼物是我心动很久的小牛 U+B 电动车，虽然花 6、7k 买一台代步的电动车似乎过于奢侈，但实际使用后，其实非常值得。每天骑它上下班，不仅让我的心情变得格外愉快，还拓大了我的生活半径，生活幸福感拉满。</p><h2 id="迈入新篇章"><a href="#迈入新篇章" class="headerlink" title="迈入新篇章"></a>迈入新篇章</h2><p>是的，今年我完成了一件人生大事——我成家了！虽然按照中国男人普遍结婚年龄，我这个年纪结婚似乎稍早了些，但每个人的情况都是不同的。对于我而言，现在正是承担家庭责任的最佳时机。并且我和她已经走到了第七个年头（嗯，从初恋走到结婚，稳如老狗），其实我们的关系早已超越了恋人的层面，即便没有领证，我们就已经生活得如同一对老夫妻。</p><p>结婚是比较烧钱的，尽管广东这边的婚礼相对全国其他地区来说开销小一些，但仍然把我的积蓄花光。对于我这种社恐人来说，并不热衷于摆酒席，但迫于传统观念，也就不得不循规蹈矩，整体下来的感受就是：累，很累。</p><h2 id="思想的转换"><a href="#思想的转换" class="headerlink" title="思想的转换"></a>思想的转换</h2><p>今年我感觉自己变了不少。以前跟朋友聊天，一旦意见不合，我心里就不是滋味，有时候还得辩到底，好像非赢过他们不可。但现在回头看，那样其实挺没意思的，也挺幼稚。我为啥非得那样呢？其实就是想让别人觉得我对。但现实是，每个人都是在自己的小世界里长大的，看问题的角度自然不同。我之前在 V2EX 上看到不顺眼的观点，直接拉黑，现在想想，那其实挺狭隘的。人的看法是会变的，今天我不同意的人和观点，或许哪天就能给我带来新的启发。所以，现在我不再那么轻易拉黑别人了，毕竟，谁知道明天他们会不会说出让我眼前一亮的话呢？</p><p>就像以前，很多事情发生了我都会气得不行，但慢慢地，随着岁月添皱，我开始意识到事情没那么简单，也许并不像我当初想的那样。所以现在，遇到曾让我难以忍受的事，我学会了保持冷静，用一颗平和的心去看待。</p><p>但我也在想，这会不会是变相的犬儒？是不是我开始对事情不那么上心了，或者这只是逃避的一种方式？想了想，明白即使要冷静面对，也不能丢了追求正义的心。犬儒可能让人变得冷漠，但我还是希望，在看清世界的复杂后，依旧能带着热情去做一些改变。认识到世界不是非黑即白，不意味着我们就不追求更好。</p><p>还有对于写博客这件事情，虽然确实是我今年变懒了，但更大的原因，每当我想写一点什么，内心深处总会有一个声音告诉自己，也许你只是在胡说八道，索性就不写了。当然，这种想法并不好，我希望 2024 年能克服它。毕竟，我早就认为写博客主要是为了给将来的自己看，同时能够给别人一些帮助，所以我要继续坚持下去。</p><h2 id="工作上的感悟"><a href="#工作上的感悟" class="headerlink" title="工作上的感悟"></a>工作上的感悟</h2><p>前面提到，今年年初我曾经陷入一段时间的摆烂状态，但这种状态并没有持续太久。尽管今年的工作并不在我的计划之中，但也可以说是意外地收获了一些经验。让我先交代一下，在我初入职场时有幸加入到某公司的前端基建团队，致力于提升开发效率等方面的工作。这段经历对我后来的每一份工作都产生了深远的影响。然而，由于我一直没有真正参与产品线的开发，我的视野在很大程度上局限于提升效率这个领域，而没有形成更全面的产品思维。因为当时我的用户主要是开发同事，难免会受到开发角度的限制。虽然我在技术上能够优雅地解决问题，效率也很高，但所做出的东西往往对用户不够友好。这一问题在我自己开发的几个小项目中尤为明显。</p><p>因此，后来我选择了一份负责 2C 项目的岗位，真正地接触用户。在这个过程中，我学到了很多东西。例如，以前我并不具备像素眼，但随着被设计师盯着改样式的次数增加，我开始具备了这个能力。我也学会了站在用户的角度去思考功能的实现。然而，2C 项目往往版本迭代非常紧凑，我们不得不在优雅的代码实现和功能实现之间做出取舍。虽然在参与这个项目的过程中，我也努力解决了一些团队协作和开发效率上的问题，但要理解，很多时候同事们可能会固步自封，习惯了现状。在一个公司范围内推广新的方案，但如果没有领导的支持，是非常艰难的。</p><p>然而，今年我们所在的项目组被解散了。虽然我原本的计划没有完全实现，但我却重新承担了前端团队基建的工作。时隔数年，我再次投入到这个领域，让我在原本思考如何优雅实现的基础上，学会了更多关于如何设计的知识。因此，我认为这次经历是因祸得福。在从事产品线工作两年后，我发现我更喜欢做这类基础设施的工作。</p><p>最后，我想分享一个小插曲。在年底公司评优时，决策层在我和另一位候选人之间，选择了那位能为公司带来更多资金收益的同事。虽然我内心有些小失望，但我能理解这个决策。同时，我认为我仍然有机会继续从事我喜欢且擅长的工作，而且我的产出也得到了领导的认可，这对我来说是不亚于公司层面的认可。</p><h2 id="2024-年"><a href="#2024-年" class="headerlink" title="2024 年"></a>2024 年</h2><p>简而言之，今年是我变化很大的一年，但好的习惯却没有坚持下来，希望在来年能够重新拾起来。</p><p>最终，祝新年快乐！</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E6%80%BB%E7%BB%93/">总结</category>
      
      <category domain="https://4ark.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</category>
      
      
      <comments>https://4ark.me/post/2023-summary.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2022 年度总结</title>
      <link>https://4ark.me/post/2022-summary.html</link>
      <guid>https://4ark.me/post/2022-summary.html</guid>
      <pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇总结在去年 12 月份底拖到现在，后面做了一个不大不小的手术，过年期间连床都不想下，就一直拖到了现在，最近已经恢复得七七八八，于是趁 1</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇总结在去年 12 月份底拖到现在，后面做了一个不大不小的手术，过年期间连床都不想下，就一直拖到了现在，最近已经恢复得七七八八，于是趁 1 月份还未结束，抓紧时间把它赶出来。</p><p>2022 年已经结束，感觉这一年过得特别漫长。这是疫情席卷全球的第三年，而且仍然是大事频出的一年。如果让我总结 2022，我认为有几句话是值得永远铭记的。与《人民日报》所选出的 12 句中没有提及苦难的话不同，我认为以下几句话才是正确的集体记忆：</p><p>第一句是「这个世界不要俺了」，我自认为不是一个政治冷感的人，但是我几乎不参与网上讨论，只是每当有重大的社会事件发生时，都很难不去关注。</p><p>第二句话是「我们是最后一代」，与之对应的是「他的软肋是他儿子」，让我不禁想起黄子华曾在《秋前算账》说过这么一句话：如果大家都不生孩子，暴政必亡！但我们知道这是不可能的，人类是大自然的动物，繁衍是人类的天性，即使在最困难的时候，人类也没有放弃生育。很多人都把希望寄托在下一代，但我认为，如果自己都做不到的事情，凭什么觉得自己的孩子能做到呢？无论是否丁克，我们都应该表示尊重和理解。</p><p>第三句话是「请抑制灵魂对自由的渴望」，有句话说过：不自由毋宁死。但实际上，能做到这一点的人并不多。大多数人都愿意为了安全和方便而放弃一些自由，只要不触及生而为人的底线。大多数人也都默认了这一点，只是当这句话从他们口中说出来时，让人感到无比心寒。</p><p>回顾 2021 年的总结，我的愿望只有一个——“好好活着”。这看上去似乎是一个非常简单的愿望，但对于某些人来说，能够活着就是最大的奢望。疫情已经放开，希望 2023 年一切都会回到正轨，我相信念念不忘，必有回响。</p><h2 id="收获和成长"><a href="#收获和成长" class="headerlink" title="收获和成长"></a>收获和成长</h2><p><strong>技术层面：</strong></p><ol><li>通过阅读开源代码解决心中疑惑，「源码面前，了无秘密」。</li><li>通过阅读 ECMAScript 规范使 JavaScript 水平更上一层楼。</li><li>通过开发油猴插件提高日常繁琐任务的效率。</li></ol><p><strong>个人影响力：</strong></p><ol><li>成为自己日常使用的工具的 Contributor。</li><li>办了一份技术周刊，扩大了幸运表面积（Luck Surface Area）。</li></ol><p>在今年年初，突发奇想办了一个周刊，不过持续了 14 周就没有下文了，主要原因是那时候有点忙，因为维护一个周刊，要么需要阅读大量的文章，要么需要有深度的思考，并且一周一次，需要占据很多时间，因此一旦忙起来就很容易断更，一旦断更，就很难再恢复之前的热情，不过总体来说，我认为维护一个周刊对自身是很有帮助，因此今年会重新上路，但形式不再局限与之前那样，打算写一些较有深度的长文或系列文章。</p><h2 id="年度盘点"><a href="#年度盘点" class="headerlink" title="年度盘点"></a>年度盘点</h2><h3 id="最喜欢的书"><a href="#最喜欢的书" class="headerlink" title="最喜欢的书"></a>最喜欢的书</h3><p>今年看过的书依旧不多，其中比较喜欢的这几本：</p><ul><li><strong>《翦商》</strong>，一部夏商周启示录，喜欢阅读历史的看官可不要错过了。</li><li><strong>《精通正则表达式》</strong>，无论看多少文档都比不上这本书给你带来的对于正则的领悟。</li><li><strong>《编程语言的设计与实现》</strong>，Ruby 作者向你展示创建编程语言的乐趣。</li></ul><h3 id="最喜欢的音乐"><a href="#最喜欢的音乐" class="headerlink" title="最喜欢的音乐"></a>最喜欢的音乐</h3><p>今年一如既往喜欢听我逼哥的《梵高先生》，有一天我听到了<a href="https://www.youtube.com/watch?v=725WGspTJqI&ab_channel=infinite3321">义乌隔壁酒吧</a>的版本，直接猛男落泪！</p><ul><li><strong>《梵高先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/572mdcKFCEMVgtSELmoIuU?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《处处吻》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/7scQnPn4YQGV8ZgtDNcdu5?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《可惜我是水瓶座》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/1sWUT5hSawhEctQEQrVQdn?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><h2 id="2023？"><a href="#2023？" class="headerlink" title="2023？"></a>2023？</h2><p>今年希望在技术上有所精进，还需要拓展一下技术以外的视野，比如多从产品角度思考问题。</p><p>想要实现的东西：</p><ul><li>自动格式化 wxml 文件的 prettier plugin</li></ul><p>当然，好好活着是最重要的，希望今年一切都会好起来！</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E6%80%BB%E7%BB%93/">总结</category>
      
      <category domain="https://4ark.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</category>
      
      
      <comments>https://4ark.me/post/2022-summary.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我们如何从 Wxml2Canvas 迁移到 Painter</title>
      <link>https://4ark.me/post/how-to-migrate-wxml2canvas-to-painter.html</link>
      <guid>https://4ark.me/post/how-to-migrate-wxml2canvas-to-painter.html</guid>
      <pubDate>Mon, 26 Dec 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;路漫漫其修远兮&quot;&gt;&lt;a href=&quot;#路漫漫其修远兮&quot; class=&quot;headerlink&quot; title=&quot;路漫漫其修远兮&quot;&gt;&lt;/a&gt;路漫漫其修远兮&lt;/h2&gt;&lt;p&gt;糖纸苦 Wxml2Canvas 久矣！&lt;/p&gt;
&lt;p&gt;长期以来，糖纸项目使用 &lt;a href=&quot;ht</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="路漫漫其修远兮"><a href="#路漫漫其修远兮" class="headerlink" title="路漫漫其修远兮"></a>路漫漫其修远兮</h2><p>糖纸苦 Wxml2Canvas 久矣！</p><p>长期以来，糖纸项目使用 <a href="https://github.com/wg-front/wxml2canvas">Wxml2Canvas</a> 库来生成分享海报。这个库的功能就是将 Wxml 转换成 Canvas，并最终生成一张图片。但是，这个库非常不稳定，经常会出现各种奇怪的 BUG，只能说勉强能用。如果你想了解 Wxml2Canvas 给我们带来的痛苦，可以阅读这篇文章：<a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a>。</p><p>因此，我们一直希望能找到一个更好的替代方案。在社区搜索后，我们发现 <a href="https://github.com/Kujiale-Mobile/Painter">Painter</a> 非常不错。然而，它与 Wxml2Canvas 的使用方式有很大的差异，我们的项目中有二十多个地方使用了 Wxml2Canvas，所以迁移起来并不容易。但 2022 即将结束，我们希望能在最后时刻做点事情来让自己找回一丝慰藉，所以才有了这篇文章。</p><p>让我们来看看这两个库的使用方式有什么不同：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212270056681.png?imageMogr2/format/webp" alt="image-20221227005600071" style="zoom: 50%;" /><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212270056939.png?imageMogr2/format/webp" alt="image-20221227005620310" style="zoom:50%;" /><p>Wxml2Canvas 使用方式相对直观，使用 Wxml 和 Wxss 实现，而 Painter 则使用 JSON 配置。如果要将项目迁移到 Painter，就需要手写大量的 JSON 配置，这需要相当多的工作量。</p><h2 id="吾将上下而求索"><a href="#吾将上下而求索" class="headerlink" title="吾将上下而求索"></a>吾将上下而求索</h2><p>俗话说得好：<strong>只要思想不滑坡，办法总比困难多！</strong></p><p>那么，有没有一种方法可以让我们迁移到 Painter，同时又不用重写 JSON 配置呢？</p><p>让我们从不同的角度思考一下：Wxml2Canvas 可以直接将 Wxml 画到 Canvas 上，那么是否也可以将其转换成 JSON 配置呢？这样，我们就可以复用现有的 Wxml 代码，减少迁移的成本。</p><p>大致流程如下：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212272228830.png?imageMogr2/format/webp" alt="image-20221227222820467" style="zoom:50%;" /><p>总之，我们需要一个转换器来将 Wxml 转换为符合 Painter 使用的 JSON 配置，我愿称之为 Wxml2Json。</p><p>说干就干，我们可以直接照搬 Wxml2Canvas 的做法。首先获取最外层容器的尺寸，用来定义分享海报的宽高。然后，通过 wx.createSelectorQuery().selectAll() 获取所有需要绘制的节点和样式信息。接着，根据不同的节点类型设置对应的属性，最终输出一份 JSON 配置供 Painter 使用。</p><p>其核心方法是 <code>getWxml</code>，大致实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getWxml</span>(<span class="params">&#123;container, className&#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getNodes = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    query</span><br><span class="line">      .selectAll(className)</span><br><span class="line">      .fields(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">dataset</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">size</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">rect</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">computedStyle</span>: COMPOUTED_ELEMENT_STYLE,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="built_in">this</span>.formatNodes(res))</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      .exec()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getContainer = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    query</span><br><span class="line">      .select(container)</span><br><span class="line">      .fields(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">dataset</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">size</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">rect</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      .exec()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([getContainer, getNodes])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>formatNodes</code> 方法的职责就是根据需要绘制的节点类型进行格式转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">formatNodes</span>(<span class="params">nodes</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">    .map(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;dataset = &#123;&#125;&#125; = node</span><br><span class="line"></span><br><span class="line">      node = &#123;...node, ...dataset&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> n = _.pick(node, [<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;url&#x27;</span>])</span><br><span class="line"></span><br><span class="line">      n.css = <span class="built_in">this</span>.getCssByType(node)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function"><span class="params">s</span> =&gt;</span> s &amp;&amp; s.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个转换器，我们的迁移工作只需要将 <code>new Wxml2Canvas</code> 替换成 <code>new Wxml2Json</code> ，然后将数据传入 Painter 中即可。因此，一天内完成所有 Wxml2Canvas 迁移到 Painter 的工作将不再是个梦。</p><h2 id="山重水复疑无路"><a href="#山重水复疑无路" class="headerlink" title="山重水复疑无路"></a>山重水复疑无路</h2><p>缝合结束，不出意外的话马上要出意外了，虽然大部分机型都表示情绪稳定，但成功路上注定不会一马平川。</p><p>果不其然，让全网「沸腾」的鸿蒙首当其冲，如下图所示：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212280057359.png?imageMogr2/format/webp" alt="image-20221228005732730" style="zoom: 20%; text-align: left; margin:0;" /></p><p>然后，测试小姐姐的 iPhone 12 也毫不甘落下风，上来就憋了个大招：微信闪退。</p><p>以上这两个页面都有一个共同点，就是生成的分享海报尺寸非常大，比如说这个：1170 × 17259。</p><p>我去线上看了一下，发现同一个页面上  Wxml2Canvas  却是稳定的，那这个 Painter 为什么这么拉胯？</p><p>开始找茬，分析两者的实现，终于发现了一些端倪：首先是  <code>wx.canvasToTempFilePath</code> 的参数不同：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212282240876.png?imageMogr2/format/webp" alt="image-20221228223957183" style="zoom:50%;" /><p>翻看 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasToTempFilePath.html">wx.canvasToTempFilePath</a> 文档，其中 <code>x</code>、<code>y</code> 默认值都是 0，问题不大。</p><p>主要问题在于 <code>width</code> 和 <code>height</code>，我们先来看看 <code>wx.canvasToTempFilePath</code> 这几个参数的作用：</p><ul><li>width，画布的宽度</li><li>height，画布的高度</li><li>destWidth，输出图片的宽度，默认值是 width × dpr</li><li>destHeight，输出图片的高度，默认值是 height × dpr</li></ul><p>然后再梳理一下这两个库中的参数值是多少：</p><ul><li>Wxml2Canvas<ul><li>width：与外层容器的宽度、 canvas 宽度一致</li><li>height：与外层容器的高度、 canvas 高度一致</li><li>destWidth，width × dpr</li><li>destHeight，height × dpr</li></ul></li><li>Painter<ul><li>width：外层容器的宽度 * dpr、 canvas 宽度一致</li><li>height：外层容器的宽度 * dpr、 canvas 高度一致</li><li>destWidth，与 canvas 宽度一致</li><li>destHeight， 与 canvas 高度一致</li></ul></li></ul><p>答案呼之欲出了，我来解释一下：</p><ol><li>Painter 会将所有需要绘制的节点尺寸乘以设备的 dpr。假设我们要生成一张 375 x 800 的海报，其中包含一张 100 x 100 的图片，在当前设备的 dpr 为 3 的情况下，Painter 会创建一张 1125 x 2400 的画布，在画布上绘制一张 300 x 300 的图片。最终在保存图片时，输出的图片尺寸与画布大小完全一致。</li><li>Wxml2Canvas 在绘制时是创建一张 375 x 800 的画布，并在画布上绘制一张 100 x 100 的图片，但是在最终保存图片时，输出的图片尺寸是画布大小乘以 dpr。</li></ol><p>看上去 Painter 的做法似乎并无不妥，因为画布大小和最终成品是 1:1 的；反观 Wxml2Canvas 却是 1:3，难道这样导出的图片不会影响清晰度吗？我们直接来做个实验，分别用 Painter 和 Wxml2Canvas 生成同一张分享海报，对比两张图片的不同，结果发现导出的图片无论尺寸还是文件大小都是一模一样的，如图所示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212291816047.png?imageMogr2/format/webp" alt="image-20221229181609765"></p><h2 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h2><p>既然如此，我们就可以直接将 Wxml2Canvas 的方案移植到 Painter，最终发现这样能 work：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212291328173.png?imageMogr2/format/webp" alt="image-20221229132803803" style="zoom:50%;" /><p>总而言之，尽管两者最终生成的成品尺寸是一样的，但是 Painter 设置的画布尺寸比 Wxml2Canvas 大了三倍，这样会使用更多的内存，而且微信官方文档也提到：设置过大的宽高会导致 Crash 的问题。</p><p>经过这一番操作，鸿蒙和 iPhone 12 也终于服帖了。然而，又有新的问题出现了。当某个页面生成并保存图片后，在滑动该页面时会明显感觉卡顿，对比一下 fps（帧率）的变化，确实离谱。<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032334581.png?imageMogr2/format/webp" alt="image-20230103233431180" style="zoom:100%;" /></p><p>这种卡顿是肉眼可见的，猜测可能是因为内存泄露造成。在真机上调试分析了一下内存占用情况，未进行生成海报时，CPU 占用率为 2%，内存占用为 872 MB：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032351510.png?imageMogr2/format/webp" alt="image-20230103235024011"></p><p>当生成海报时，CPU 占用率快速飙升到 22%，内存占用 895 MB：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032355858.png?imageMogr2/format/webp" alt="image-20230103235506588"></p><p>随后发现内存占用并没有下降，直到我们离开了当前页面时，占用率才有所下降。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202301032358207.png?imageMogr2/format/webp" alt="image-20230103235744395"></p><p>既然如此，可以在生成海报之后立即对分享卡片的内存进行回收，最简单的方式就是使用 <code>wx:if</code> 控制。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;share-card </span><br><span class="line"><span class="addition">+ wx:if=&quot;&#123;&#123;showShareCard&#125;&#125;&quot;</span></span><br><span class="line">  id=&#x27;share-card&#x27;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>最后来晒晒战绩，迁移后生成时间缩短近 50%：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202212300914569.png?imageMogr2/format/webp" style="zoom:50%;" /><p>综上所述，Wxml2Canvas 在稳定性和可维护性方面都有所欠缺，但也有值得 Painter 借鉴的地方。例如，Wxml2Canvas 的使用方式更直观，不需要设置过大的画布尺寸，从而避免了 Crash 的风险。因此，将两者缝合起来，以最小的成本提高糖纸生成分享海报的效率和稳定性，何乐而不为？</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://4ark.me/post/how-to-migrate-wxml2canvas-to-painter.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于二舅的一些感悟</title>
      <link>https://4ark.me/post/live-sentiment.html</link>
      <guid>https://4ark.me/post/live-sentiment.html</guid>
      <pubDate>Fri, 29 Jul 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;最近二舅的视频炒得沸沸扬扬，看完视频后的我和大部分人的反应一样，觉得非常感动。&lt;/p&gt;
&lt;p&gt;但随后我又不禁陷入沉思，如果换成是我，我会怎么做？&lt;/p&gt;
&lt;p&gt;思索片刻，无非两条路，第一：结束自己的生命，但如果这么做，除了你的家人，还有谁为你感到伤心呢？&lt;/p&gt;
&lt;p&gt;君不</description>
        
      
      
      
      <content:encoded><![CDATA[<p>最近二舅的视频炒得沸沸扬扬，看完视频后的我和大部分人的反应一样，觉得非常感动。</p><p>但随后我又不禁陷入沉思，如果换成是我，我会怎么做？</p><p>思索片刻，无非两条路，第一：结束自己的生命，但如果这么做，除了你的家人，还有谁为你感到伤心呢？</p><p>君不见，这段时间在微信群流传不少跳楼的视频，大家看完后有什么反应？惊叹一声，继续埋头做自己的事。</p><p>有谁会去深究他们背后的不幸呢，也许这个人就是另一个二舅，只是他选择走上这一条。</p><p>但我们没有反应，这是为什么呢？我们会认为，面对苦难，我们更应该像二舅这样积极乐观，而不是选择放弃。</p><p>是的，但这么多不幸的人，除了少部分选择结束自己的生命，其他人，哪个不是和二舅一样？</p><p>他们选择活下去，也只能是以积极乐观的态度面对生活，否则早就走上那条路了，所以麻烦搞清楚，这是一种无可奈何，试问换成你经受着一切，让你侄子拍个视频，让广大网友来敬佩你、在弹幕里疯狂刷「二舅」，你愿意吗？</p><p>二舅的不幸，是个人的不幸，更是时代的不幸，纵观他的人生，就是一部新中国史。</p><p>如同《活着》里面的福贵，他活着，也仅仅是活着，我们不会去赞扬他的乐观态度，我们更应该感到悲哀，为里面的福贵悲哀，也为这个时代悲哀，但记住永远不要相信这些苦难都是值得的，苦难就是苦难，苦难不会带来成功，苦难不值得追求，磨练意志只是因为苦难无法躲开。</p><p>王小波说：“人是一种会骗自己的动物，我们吃了很多无益的苦，虚掷了不少年华，所以有人就想说，这种经历是崇高的。”</p><p>二舅这个视频的意义是什么？难道让大家看看作者的二舅是如何坚强，就能治好我们所谓的精神内耗？</p><p>视频中暴露了一些真正应该被解决的问题，大家有重视吗？为什么二舅的残疾证一直办不下来，是我们相关部门为了磨炼二舅经受苦难的能力吗？二舅是否有低保？一个 68 岁的老人拉着另一个 88 岁的老人干活很正常吗？在我们社会中，还有多少个这样的二舅？</p><p>一个普通老百姓通过视频诉说自己的苦难，熬一碗鸡汤给自己喝，那也是因为二舅只能认命了呀，有什么办法？</p><p>可是官方凑热闹的时候是否应该反省一下，二舅的苦难，有多少是因为您造成的？您是不是想说：你们老百姓没办法，我们也觉得没办法呀，大家忍忍就过去了是吧？</p><p>反驳一下作者的话，人生比「把一手烂牌打成好牌」更重要的是，先搞清楚到底是谁在发牌，否则人家一直给你发烂牌，你即便打两辈子都打不完，反观人家周公子天生好牌，想怎么打就怎么打，这公平吗？</p><p>话说回来，上一次 B 站的视频炒得沸沸扬扬还是《后浪》，还记得当时豪情万丈、生长在这里实在是太幸福啦，我们有选择的权利！也才两年时间，画风就变成了像二舅这样平平淡淡凄凄惨惨切切才是真，这是同一批人吗？</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E7%94%9F%E6%B4%BB/">生活</category>
      
      
      <comments>https://4ark.me/post/live-sentiment.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从一次 yarn 命令死循环说起</title>
      <link>https://4ark.me/post/yarn-cwd-issue.html</link>
      <guid>https://4ark.me/post/yarn-cwd-issue.html</guid>
      <pubDate>Sat, 23 Jul 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近有个想法，希望在一个 yarn workspace 项目中实现任意一个子包中安装依赖时，都执行一些类似于初始化、同步配置的动作。&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有个想法，希望在一个 yarn workspace 项目中实现任意一个子包中安装依赖时，都执行一些类似于初始化、同步配置的动作。</p><p>然而在操作过程中遇到了一个关于 <code>yarn --cwd</code> 有趣的问题，特地记录下来，希望能对后来者有所帮助。</p><h2 id="遇到什么问题呢"><a href="#遇到什么问题呢" class="headerlink" title="遇到什么问题呢"></a>遇到什么问题呢</h2><p>先交代一下我们项目的基本情况，它是一个通过 yarn workspace 管理的 monorepo 项目，使用的是 yarn v1.22.11 版本，目录结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monorepo</span><br><span class="line">├── package.json</span><br><span class="line">├── app-a</span><br><span class="line">│   └── package.json</span><br><span class="line">├── app-b</span><br><span class="line">│   └── package.json</span><br><span class="line">└── config</span><br><span class="line">    └── package.json</span><br></pre></td></tr></table></figure><p>其中 <code>app-a</code> 和 <code>app-b</code> 都使用了 <code>config</code> 这个共享包：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;@monorepo/config&quot;</span>: <span class="string">&quot;../config&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在根目录的 <code>package.json</code> 中的 <code>preinstall</code> 钩子做一些初始化操作：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;./bin/init.sh&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们在根目录执行 <code>yarn</code> 或者 <code>yarn add &lt;pkg-name&gt;</code>，都会触发 <code>preinstall</code> 这个钩子，但在 <code>app-a</code> 中执行 <code>yarn</code>是不会触发根目录的 <code>preinstall</code> 钩子的。</p><p>因此，我们需要分别在每个子包上都加上这行，也即在每个子包安装依赖时都执行一下根目录的 <code>preinstall</code> 命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，奇怪的事情就发生了，当我在 <code>app-a</code> 中执行 <code>yarn</code> 的时候，它停留在安装 <code>@monorepo/config</code> 的阶段，同时我的电脑明显变得卡顿，于是打开 <code>htop</code> 一看，好家伙，满屏都是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4ark   40987  26.3  0.5 409250368  78624   ??  R  8:36下午   0:00.09 /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/yarn --cwd ../ preinstall</span><br></pre></td></tr></table></figure><p>CPU 占用率直接达到 100%，吓得我赶紧 kill 掉这些进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep preinstall | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>惊吓过后，来分析一下原因，很显然这段命令陷入了死循环，导致越来越多进程，于是尝试在每个子包中都手动执行一遍 <code>yarn --cwd ../ preinstall</code> 后，发现一切正常，那问题出在哪呢？</p><p>于是我再执行了一遍 <code>yarn</code>，并且用以下命令将进程信息复制出来，以便分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | pbcopy</span><br></pre></td></tr></table></figure><p>随后验证我刚刚的猜测，的确是这个命令在不断触发自己，导致死循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UID   PID  PPID   C STIME   TTY     TIME CMD</span><br><span class="line">501 50399 50379   0  8:50下午 ??   0:00.10 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50400 50399   0  8:50下午 ??   0:00.11 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50401 50400   0  8:50下午 ??   0:00.11 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br><span class="line">501 50402 50401   0  8:50下午 ??   0:00.12 /usr/local/bin/node /usr/local/bin/yarn --cwd ../ preinstall</span><br></pre></td></tr></table></figure><p>由于三个分包执行的命令都一样，不清楚是不是由于某个分包引起，于是修改一下命令以便区分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;echo app-a &amp;&amp; yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后发现问题是出现在 <code>config</code> 这个子包，于是我把这个子包的 <code>preinstall</code> 命令去掉，果然没有这个问题了，非常奇怪。</p><p>难道是 <code>--cwd ../</code> 这个路径有问题？验证一下，把命令改成这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;pwd &amp;&amp; yarn --cwd ../ preinstall&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 <code>pwd</code> 输出是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/4ark/projects/monorepo/app-a/node_modules/@monorepo/config</span><br></pre></td></tr></table></figure><p>从这里的输出我们发现了两个问题，第一个问题是：</p><ul><li>yarn workspace 共享包的 <code>preinstall</code> 被执行的时候，其实已经被拷贝到 <code>app-a</code> 的 <code>node_modules</code> 中，而不是在当前目录，因此 <code>--cwd ../</code> 并不指向项目根目录。</li></ul><p>这一点比较好理解，毕竟 <code>config</code> 作为一个依赖包，确实应该被拷贝到应用的 <code>node_modules</code> 。</p><p>而第二个问题就不太理解了，为什么明明设置了 <code>--cwd ../</code>，却依然在当前目录执行呢？按照预期 cwd 的指向应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/4ark/projects/monorepo/app-a/node_modules/@monorepo</span><br></pre></td></tr></table></figure><p>难道是我对 cwd 参数的理解有偏差？看一下 yarn 的文档中对 cwd 描述：</p><blockquote><p>Specifies a current working directory, instead of the default <code>./</code>. Use this flag to perform an operation in a working directory that is not the current one.</p><p>This can make scripts nicer by avoiding the need to <code>cd</code> into a folder and then <code>cd</code> back out.</p></blockquote><p>从文档的描述来看，cwd 的作用不就是代替 <code>cd</code> 吗，但现在的结果看来 <code>yarn --cwd ../ preinstall</code> 并不等价于 <code>cd ../ &amp;&amp; yarn preinstall</code> 。</p><p>这就不得不让人疑惑 cwd 的定位方式了，在网上搜寻一番没找到相关的讨论，那只能自己动手丰衣足食，直接从 yarn 源码中寻找答案。</p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p>前面我们说到，我们使用的是 yarn v1.22.11，在 yarn 的 GitHub 仓库中发现 v1 版本的最新版本停留在 v1.23.0-0，那我们就从这个版本的源码来进行分析，首先克隆代码到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/yarnpkg/yarn</span><br></pre></td></tr></table></figure><p>然后安装依赖并运行起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn &amp;&amp; yarn watch</span><br></pre></td></tr></table></figure><p>这时候它就会自动监听代码修改然后重新编译，我们查看 <code>package.json</code> 发现 yarn 的 bin 主要是调用 <code> ./bin/yarn.js</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;yarn&quot;</span>: <span class="string">&quot;./bin/yarn.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;yarnpkg&quot;</span>: <span class="string">&quot;./bin/yarn.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>也就是我们直接执行 <code>bin/yarn.js</code> 的效果就如同执行 <code>yarn</code>，试一下查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; /Users/4ark/projects/yarn/bin/yarn -v</span><br><span class="line">1.23.0-0</span><br></pre></td></tr></table></figure><p>PS：当然你也可以在项目目录下使用 <code>npm link</code> 把它挂载到本地中。</p><p>接下就是一番调试，终于定位到可以回答我们疑问的代码，<a href="https://github.dev/yarnpkg/yarn/blob/6db39cf0ff684ce4e7de29669046afb8103fce3d/src/cli/index.js#L37-L51">在这里</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findProjectRoot</span>(<span class="params">base: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> dir = base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(path.join(dir, constants.NODE_PACKAGE_JSON))) &#123;</span><br><span class="line">      <span class="keyword">return</span> dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev = dir;</span><br><span class="line">    dir = path.dirname(dir);</span><br><span class="line">  &#125; <span class="keyword">while</span> (dir !== prev);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cwd = command.shouldRunInCurrentCwd ? commander.cwd : findProjectRoot(commander.cwd);</span><br></pre></td></tr></table></figure><p>可以看到 cwd 的定位方式是从当前目录寻找是否存在 <code>package.json</code>，若存在，则返回此目录，否则将目录经过 <code>path.dirname</code> 处理一遍，继续寻找，直到寻找到最外层。</p><p>那么这里最关键的是 <code>path.dirname</code> 的返回值，我们先看一下文档对于它的描述：</p><blockquote><p>The <code>path.dirname()</code> method returns the directory name of a <code>path</code>, similar to the Unix <code>dirname</code> command. Trailing directory separators are ignored,</p></blockquote><p>就是返回一个路径中的目录部分，作用与 unix 下的 dirname 命令一致，通常是这么使用的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; dirname /4ark/app/index.js</span><br><span class="line">/4ark/app</span><br><span class="line"></span><br><span class="line">&gt; dirname /4ark/app/packages/index.js</span><br><span class="line">/4ark/app/packages</span><br></pre></td></tr></table></figure><p>是不是会肤浅地认为它的作用就是返回一个路径的上一级目录？如果传入的是一个绝对路径，确实可以这么肤浅地认为，然而当传入的是一个相对路径时，情况就不一样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; dirname ../app/index.js</span><br><span class="line">../app</span><br><span class="line"></span><br><span class="line">&gt; dirname ../../</span><br><span class="line">../</span><br><span class="line"></span><br><span class="line">&gt; dirname ../</span><br><span class="line">问: 会返回什么呢？</span><br></pre></td></tr></table></figure><p>答案是：<code>.</code>，也就是当前目录。</p><p>那这里就能回答我们之前的问题，为什么在 <code>node_module/@monorepo/config</code> 中使用 <code>yarn --cwd ../ preinstall</code> 却在当前目录执行，因为它的上一级 <code>node_modules/@monorepo</code> 不存在 <code>package.json</code>，所以经过 <code>dirname ../</code> 处理后 cwd 的指向就是当前目录。</p><p>如果对 node.js 中 <code>path.dirname</code> 的实现方式感兴趣，可以看这里 <a href="https://github.com/jinder/path/blob/master/path.js#L538-L554">path.js#L538-L554</a>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>摸清楚原因后，那解决这个问题也不是难事，只要我们把相对路径改成绝对路径，是不是就能解决这个问题了？</p><p>思考一下，其实 <code>yarn --cwd ../ preinstall</code>，把 <code>../</code> 改成绝对路径行不行呢？比如在本文的场景，<code>../</code> 其实就是项目的根目录，那我们完全可以通过别的方式获取到项目的根目录，比如 在 git 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse --show-toplevel</span><br></pre></td></tr></table></figure><p>所以，我们把命令改成这样，问题就迎刃而解了：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- yarn --cwd ../ preinstall</span></span><br><span class="line"><span class="addition">+ yarn --cwd $(git rev-parse --show-toplevel) preinstall</span></span><br></pre></td></tr></table></figure><p>那就不得不提一下，其实在 yarn v2 中新增了一个 <code>--top-level</code>  属性，它的作用刚好就是为了解决这个问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实我们再回过头来想，在本文的例子中，根本不需要在 <code>config</code> 目录中添加 <code>preinstall</code> 这个钩子，因为它作为共享包，每次修改都必然要在其它使用这个包的地方，重新安装一次，所以只要确保这些地方会执行 <code>preinstall</code> 就可以了，那也就意味着不会出现本文遇到的问题。</p><p>不过，多踩坑也不是坏事，只要搞清楚背后的原因，问题也就不是问题。</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://4ark.me/post/yarn-cwd-issue.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第14期：暂停更新说明、自动化测试的未来趋势</title>
      <link>https://4ark.me/post/weekly-14.html</link>
      <guid>https://4ark.me/post/weekly-14.html</guid>
      <pubDate>Tue, 14 Jun 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;暂停更新&quot;&gt;&lt;a href=&quot;#暂停更新&quot; class=&quot;headerlink&quot; title=&quot;暂停更新&quot;&gt;&lt;/a&gt;暂停更新&lt;/h2&gt;&lt;p&gt;因为最近在做一个 Side Project，所以本周刊已经有一段时间没更新了，毕竟一个人的时间精力是非常有限的，无法同时把两</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="暂停更新"><a href="#暂停更新" class="headerlink" title="暂停更新"></a>暂停更新</h2><p>因为最近在做一个 Side Project，所以本周刊已经有一段时间没更新了，毕竟一个人的时间精力是非常有限的，无法同时把两件事情做好，思前想后，决定先暂时停止周刊，等后面时间充裕起来，再恢复周刊，请见谅。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="为什么会有「她」和「祂」"><a href="#为什么会有「她」和「祂」" class="headerlink" title="为什么会有「她」和「祂」"></a>为什么会有「她」和「祂」</h3><p>在 V2EX 看到一个帖子<a href="https://v2ex.com/t/857418">《汉字不分性别的“他”》</a>，不禁疑惑为何要将「他」分为「它、他、她、牠、祂」呢？</p><p>首先为什么会出现「她」呢，其实「她」的开始是从清朝的刘半农才开始使用的，在以前「她」一直是「姐」的异体字，而在 1934 年的女性杂志《妇女共鸣》中，就曾在一篇<a href="http://www.cuhk.edu.hk/ics/21c/media/articles/c136-201207034.pdf">启事</a>指出：「本刊同仁，以人字旁代男子、女字旁代女子，牛字旁代物件，含有侮辱女子非人之意」，所以拒绝用「她」字。但尽管当时饱受批评，如今「她」还是成为流行的女性专用代词。</p><p>而「祂」的出现则是西方宗教在华传教时，用作对上帝、耶稣等的第三人称代名词，不过在我们生活中已经很少能够见到了。</p><p>延伸阅读：<a href="https://www.arianalife.com/tc/topics-tc/lgbt-tc/x%E4%B9%9Fand-ta-the-gradual-rise-of-gender-neutral-pronouns-in-chinese-tc/">《「他」、「X也」，还是「Ta」：非二元性別代词有哪些？》</a></p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><p>分享两篇非常不错的文章，分别提供 Bash 和 HTML 很多有用的技巧，这里就不全文摘抄了，有兴趣可以点击进原文查看。</p><h3 id="5-个现代-Bash-语法"><a href="#5-个现代-Bash-语法" class="headerlink" title="5 个现代 Bash 语法"></a><a href="https://levelup.gitconnected.com/5-bash-syntax-for-going-beyond-traditional-shell-scripting-6904d3e71af6">5 个现代 Bash 语法</a></h3><h4 id="处理输入比-Python-和-Node-js-更加简单"><a href="#处理输入比-Python-和-Node-js-更加简单" class="headerlink" title="处理输入比 Python 和 Node.js 更加简单"></a>处理输入比 Python 和 Node.js 更加简单</h4><p>在 Bash 中，你可以通过以下代码来获取用户输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name: &quot;</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">&gt; ./test.sh</span><br><span class="line">Enter your name: 4Ark</span><br><span class="line">Hello, 4Ark</span><br></pre></td></tr></table></figure><h3 id="10-个罕为人知但非常有用的-HTML-提示。"><a href="#10-个罕为人知但非常有用的-HTML-提示。" class="headerlink" title="10 个罕为人知但非常有用的 HTML 提示。"></a><a href="https://dev.to/babib/7-shocking-html-tips-you-probably-dont-know-about-ggd">10 个罕为人知但非常有用的 HTML 提示。</a></h3><h4 id="打开摄像机"><a href="#打开摄像机" class="headerlink" title="打开摄像机"></a>打开摄像机</h4><p>我们可以通过 input 的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/capture">capture</a> 属性来打开摄像机，它具有两个属性值：</p><ol><li>user：前摄像头</li><li>environment：后摄像头</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;user&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="自动化测试的未来趋势"><a href="#自动化测试的未来趋势" class="headerlink" title="自动化测试的未来趋势"></a><a href="https://insights.thoughtworks.cn/automated-testing-trends/">自动化测试的未来趋势</a></h3><p>这篇文章主要讲述自动化测试的发展以及未来趋势，从最早期的录制回放技术开始，逐步发展成DOM对象识别与分层自动化，而如今火热的 AI 技术会给自动化测试带来哪些突破呢？</p><p>其实在业界中已经有基于 AI 技术的自动化测试技术：</p><ol><li>自愈（Self-Healing）技术</li><li>机器学习（Machine Learning）技术</li></ol><p><strong>自愈技术</strong>一般指的是：一种自我修复的管理机制。<br>举个例子，假设我们通过 <a href="https://www.cypress.io/">Cypress</a> 等框架进行 E2E 测试时，都是通过 CSS 选择器等方式获取元素，从而做进一步的测试，而当我们的内部实现发生变化时（这里指的就是元素发生变化），测试用例会失败，我们需要手动修改测试用例。<br>而自愈技术可以通过比较页面前后的差异，来自动修复测试用例中的 CSS 选择器，并在结束时更新测试用例到代码中。<br>自愈技术在业界较好的实践是 <a href="https://healenium.io/">Healenium</a>。</p><p>然而传统的基于元素定位器等方式，面临着一些问题：</p><ul><li>仍然需要人工获取定位方式；</li><li>如果是通过 Canvas 绘制出来的对象，如何识别元素 (如Flutter Web)。</li></ul><p>于是就有了<strong>机器学习</strong>来解决这个问题，它可以通过图像识别和处理等技术来生成测试用例，比如直接根据某个按钮的截图来定位这个按钮，现在在业界较好的实践是 <a href="https://airtest.netease.com/">Airtest</a>。</p><p>自动化测试未来趋势不仅仅是这两种，还有如智能化探索性测试，智能遍历测试以及智能验证等。关于智能遍历所用到的技术，大家可以参考DQN的介绍。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.babelabc.com/">巴别英语 - 英语听力口语在线学习</a>：刷TED演讲和美剧佳作练听力, 带单句步进重复、灵活中英字幕设置等专为英语学习设计的功能, 让学英语变得容易、有趣、高效。</li></ul><ul><li><a href="https://monkeylearn.com/word-cloud">Free Word Cloud Generator</a>：构建你的词云，按相关性和频率对结果进行排序，探索更高级的文本分析工具。</li></ul><ul><li><a href="http://www.jsnice.org/">JS NICE</a>：一个 JavaScript 反混淆的在线工具。</li></ul><ul><li><a href="https://slashy.app/">Slashy</a>：一个可以创建 Notion 自定义命令的增强工具，非常不错。</li></ul><ul><li><a href="https://type-scale.com/">Type Scale</a>：一个可视化的字体大小调节工具，可以预览 CSS 字体在不同 rem 上表现。</li></ul><ul><li><a href="https://evanhahn.github.io/ffmpeg-buddy/">ffmpeg-buddy</a>：一个 ffmpeg 参数生成工具。</li></ul><ul><li><a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">NGINX 配置</a>：一个 nginx 配置生成工具。</li></ul><ul><li><a href="https://www.compose.ai/">Compose AI</a>：一个帮助写作的 AI 工具，目前仅适用于英语，缺点就是太贵。</li></ul><ul><li><a href="https://getcssscan.com/">CSS Scan</a>：一个可直接在网页内获取任意元素 CSS 样式的工具。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-14.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第13期：一些图像 AI 模型、冒名顶替综合症</title>
      <link>https://4ark.me/post/weekly-13.html</link>
      <guid>https://4ark.me/post/weekly-13.html</guid>
      <pubDate>Tue, 31 May 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;本周轮子&quot;&gt;&lt;a href=&quot;#本周轮子&quot; class=&quot;headerlink&quot; title=&quot;本周轮子&quot;&gt;&lt;/a&gt;本周轮子&lt;/h2&gt;&lt;p&gt;本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项目都会接入这</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="本周轮子"><a href="#本周轮子" class="headerlink" title="本周轮子"></a>本周轮子</h2><p>本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项目都会接入这个工具，它的用途主要是统一管理项目中的 Git Hooks 脚本，不熟悉该工具的同学也不要紧，下面我们先来简单介绍一下 husky，它到底解决了什么问题，我们为什么需要使用 husky。</p><p>本周轮子：<a href="https://4ark.me/post/weekly-npm-packages-02.html">《每周轮子之 husky：统一规范团队 Git Hooks》</a></p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="AI-画画"><a href="#AI-画画" class="headerlink" title="AI 画画"></a>AI 画画</h3><p>上周和菜头在公众号分享了一篇文章<a href="https://mp.weixin.qq.com/s/abcMo8pxi9Gnu40m8DIFhg">《新玩具，新瘾头》</a>，里面介绍了一个谷歌的 AI 图像生成程序 <a href="https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/Disco_Diffusion.ipynb">Disco Diffusion</a>，它可以根据描述场景的关键词渲染出对应的图像，真的非常惊艳，有兴趣可以玩一下。</p><p>从文中借一张图来展示下效果：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312334384.png" alt="图片"></p><h3 id="文本生成图片"><a href="#文本生成图片" class="headerlink" title="文本生成图片"></a>文本生成图片</h3><p>这是谷歌的一个 AI 模型 <a href="https://imagen.research.google/">Imagen</a>，可以根据输入文字生成写实的图片，下面这个弹吉他的猫就是它生成的：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312247639.jpeg" alt="img"/><h3 id="Edge-的-AI-图像增强功能"><a href="#Edge-的-AI-图像增强功能" class="headerlink" title="Edge 的 AI 图像增强功能"></a><a href="https://blogs.bing.com/search-quality-insights/may-2022/Turing-Image-Super-Resolution">Edge 的 AI 图像增强功能</a></h3><p>微软图灵团队发布了一个 AI 模型  Super-Resolution (T-ISR)，它可以提高图片的质量，它将应用在 Bing 地图以及 Edge 浏览器中，目前已经在 <a href="https://www.microsoftedgeinsider.com/en-us/download/canary">Edge Canary</a> 中发布，将会在未来几个月推广给用户使用。</p><p>附上对比效果：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205312333952.png" alt="image-20220531233321460"></p><h3 id="冒名顶替综合症"><a href="#冒名顶替综合症" class="headerlink" title="冒名顶替综合症"></a>冒名顶替综合症</h3><blockquote><p>冒名顶替综合症是一种心理现象，即一个人怀疑自己的技能、才能或成就，并有一种持续的内在恐惧，害怕被揭穿自己是个骗子。</p></blockquote><p>老实讲，从我开始写博客一直到今天，期间也写过一些较有深度的技术文章，往往这个时候都能感觉到自己知识的匮乏，而当我将这些文章发布到技术论坛时，一方面我自然希望可以帮助到更多人，另一方面也希望可以通过这些文章结识到更多志同道合的朋友，可是每当有人称赞我的文章写得不错的时候，我在开心之余，也隐约担心自己是否承受得起，其实这些文章是我花费了数天晚上才勉强肝出来的，并不轻松，我深知自己并没有他们口中说的那么厉害，甚至很多时候我会忘记自己在文章中写过的知识，但是好处是我可以非常快地重新拾起来，所以为了让自己可以持续地输出对别人有帮助的文章，我需要花费更多的时间在写作这件事情上，其实收益最大的是自己。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="没有-Docker-Desktop-的情况下运行-Docker"><a href="#没有-Docker-Desktop-的情况下运行-Docker" class="headerlink" title="没有 Docker Desktop 的情况下运行 Docker"></a><a href="https://www.swyx.io/running-docker-without-docker-desktop/">没有 Docker Desktop 的情况下运行 Docker</a></h3><p>Docker 几乎是每一位开发者都必备的工具，然而 Docker Desktop for Mac 也被无数人吐槽过，现在我们终于可以摆脱 Docker Desktop，使用 <a href="https://github.com/abiosoft/colima/">Colima</a> 即可在你的电脑上运行 Docker。</p><p>不过笔者按照文档上的步骤，遇到了这个报错：</p><blockquote><p>FATA[0000] error starting vm: error at ‘starting’: exit status 1</p></blockquote><p>如果你也遇到同样的问题，可以试试这个操作步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; brew unlink colima <span class="comment"># 已经安装的话，先卸载</span></span><br><span class="line"></span><br><span class="line">&gt; brew install --HEAD colima</span><br><span class="line"></span><br><span class="line">&gt; colima start --runtime docker</span><br><span class="line"></span><br><span class="line">&gt; docker ps <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="主要版本号不是神圣的"><a href="#主要版本号不是神圣的" class="headerlink" title="主要版本号不是神圣的"></a><a href="https://tom.preston-werner.com/2022/05/23/major-version-numbers-are-not-sacred.html">主要版本号不是神圣的</a></h3><p>本文的作者是 <a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a> 的提出者，相信大家对这个规范都不陌生，它规定了版本格式应该为：主版本号.次版本号.修订号。</p><p>版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>但作者在提出这个规范十年后的今天，发现了一个问题：大家把主版本号的升级看得太重要。</p><p>文章主要传递一个观点：<strong>主版本号的升级不应该作为一种营销的噱头，只要有 breaking change（重大改变） 时就应该升级，没有例外。</strong></p><p>下面聊些不太成熟的观点，在项目的实践中，特别是开源前端组件库，经常会面临一个选择困境：我们不得不对某个 API 做出 breaking change，然而这个  API 仅在少数场景下被使用到，如果严格遵循语义化版本，那我们将要升级主版本号，但是对于用户而言，会认为是整个组件库得到了升级，所以我认为这一点上还是需要根据实际情况做考虑。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://acapela.com/">Acapela</a>：一个收件箱搞定所有工作通知。</li></ul><ul><li><a href="https://uiverse.io/switches">uiverse.io</a>：一些开源的 UI 元素，可以直接复制代码。</li></ul><ul><li><a href="https://henryheffernan.com/">Henry Heffernan - Portfolio 2022</a>：一个惊艳的个人网站。</li></ul><ul><li><a href="https://sideproject.guide/">Side Project 指南</a>：一本关于程序员开发 Side Project 指南的小册。</li></ul><ul><li><a href="https://bionic-reading.com/">Bionic Reading</a>：这是一种英文阅读方式，它认为将每个单词的首字母变成大写后会使阅读效率提高，Reeder 也使用了这个服务。</li></ul><ul><li><a href="https://ooooooooooooooooooooooo.ooo/">ooooooooooooooooooooooo.ooo | URL Lengthner</a>：输入任意 URL，将它转换为全是 oooo。</li></ul><ul><li><a href="https://psychology-tools.com/">心理学工具</a>：一个经过学术验证的心理评估工具，如果这段时间感到焦虑、压力大的话可以简单做下测试。</li></ul><ul><li><a href="https://browser.engineering/index.html">Web Browser Engineering</a>：一本教你使用 1000 行的 Python 代码构建一个基本但完整的Web浏览器的书。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-13.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每周轮子之 husky：统一规范团队 Git Hooks</title>
      <link>https://4ark.me/post/weekly-npm-packages-02.html</link>
      <guid>https://4ark.me/post/weekly-npm-packages-02.html</guid>
      <pubDate>Mon, 30 May 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;本文是每周轮子计划的第二篇，本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>本文是每周轮子计划的第二篇，本周我们来实现一个被广泛使用的工具，那就是鼎鼎大名的 husky，几乎所有现代前端项目、以及 Node.js 项目都会接入这个工具，它的用途主要是统一管理项目中的 Git Hooks 脚本，不熟悉该工具的同学也不要紧，下面我们先来简单介绍一下 husky，它到底解决了什么问题，我们为什么需要使用 husky。</p><p>大部分公司都会采用 Git 来对项目进行代码的版本控制，其好处相信大家都知道，这里就不再赘述，通常为了保证项目的代码质量、以及更好地进行团队之间的协作，我们都会在提交代码时做一些额外的工作，包括：检查 commit message 的规范性、统一代码风格、进行单元测试等等。</p><p>而这些工作自然不能完全依靠项目成员的自觉性，毕竟人都会犯错，所以这些工作都得交给自动化工具来处理。</p><p>因此，大部分版本控制系统都会提供一个叫做钩子（Hooks）的东西，Git 自然也不例外，Hooks 可以让我们在特定的重要动作发生时触发自定义脚本，通常分为客户端和服务端，而我们接触的大部分 Hooks 都是客户端的，也就是在我们本机上执行的。</p><p>下面我们简单介绍一下如何在 Git 中使用 Hooks，我们只需要在项目的 <code>.git/hooks</code> 目录中创建一个<strong>与某个 hook 同名的可执行脚本</strong>即可，比如我们想要阻止一切提交，并将 commit message 打印到终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .git/hooks/commit-msg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">INPUT_FILE=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">START_LINE=$(head -n1 <span class="variable">$INPUT_FILE</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前提交信息为：<span class="variable">$START_LINE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;阻止此次提交！！！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>这里先别纠结这段脚本代码是如何做到的，只需清楚我们可以利用 Git Hooks 做到这一点，实际上我们可以在这里做任何操作，比如检查 commit message 的规范性。</p><p>讲完如何使用 Git Hooks，那我们就得讲讲这种方式存在哪些不足。</p><p>在 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">Git 文档</a>中对客户端钩子有这么一段话：</p><blockquote><p>需要注意的是，克隆某个版本库时，它的客户端钩子并不随同复制。 如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。 </p></blockquote><p>简单来说就是，我们上面添加的这个 <code>commit-msg</code> Hook，只能在我们自己的机器上，不能被加入到版本控制中推送到远端，也就意味着我们无法同步这些 Hooks 脚本。</p><p>而 husky 主要就是为了解决这个问题，除此之外还提供了更加简便的方式来使用 Git Hooks，而无须采用上面那种方式。</p><p>先来介绍一下大家所熟知的 husky 用法，首先要安装这个工具，可以使用全局安装，但一般更推荐在项目本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky -D</span><br></pre></td></tr></table></figure><p>然后我们在 <code>package.json</code> 中添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;pre-push&quot;</span>: <span class="string">&quot;yarn test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这种方式是 husky v4 版本之前的配置方式，相信大部分同学都对这种方式很熟悉了，而在最新版本 husky（v7 之后） 已经不支持这样使用，而是采用命令行配置的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">npx husky add .husky/pre-push <span class="string">&quot;yarn test&quot;</span></span><br></pre></td></tr></table></figure><p>它的配置方式之所以会有如此翻天覆地的变化是有原因的，不过说来话长，我们下面会讲到，这里先按下不表。</p><p>本文就带领大家从 0 到 1 造一个 husky，我们先从第一种使用方式开始，然后一步步来看为什么 husky 在新版本会选择改变它的配置方式。</p><p>让我们开始吧！</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="v4-以前的版本"><a href="#v4-以前的版本" class="headerlink" title="v4 以前的版本"></a>v4 以前的版本</h3><p>我们先来以最 low 的方式实现它，第一步是对 <code>package.json</code> 进行配置，以便测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;echo hello husky!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后读取 <code>package.json</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// husky.js</span></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">husky</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pkg?.husky?.hooks) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pkg.husky.hooks !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = pkg.husky.hooks</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(hooks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">husky()</span><br></pre></td></tr></table></figure><p>现在我们现在已经能拿到 hooks 相关的配置，然后我们把相关的脚本内容写入到对应的 hooks 可执行文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [name, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(hooks)) &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="string">`#!/bin/sh\n<span class="subst">$&#123;value&#125;</span>\n`</span></span><br><span class="line"></span><br><span class="line">  fs.writeFileSync(<span class="string">`./.git/hooks/<span class="subst">$&#123;name&#125;</span>`</span>, script, &#123; <span class="attr">mode</span>: <span class="string">&#x27;751&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node husky.js</span><br></pre></td></tr></table></figure><p>然后我们就可以看到 <code>.git/hooks</code> 下面多了一个 <code>pre-commit</code> 可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat pre-commit</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> hello husky!</span><br></pre></td></tr></table></figure><p> 这时候进行 commit 也可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">hello husky!</span><br></pre></td></tr></table></figure><p>这时候我们已经完成了 husky 大部分的功能，但是这里还存在这么一个问题：<strong>如果现在我去修改 <code>package.json</code>  中的 husky 配置，hooks 文件如何同步更新？</strong></p><p>举个例子，如果现在把 <code>package.json</code> 改成这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line"><span class="deletion">-     &quot;pre-commit&quot;: &quot;echo hello husky!&quot;</span></span><br><span class="line"><span class="addition">+     &quot;pre-commit&quot;: &quot;echo hello husky2!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行 commit，它输出的仍然是 hello husky!，实际上如果我们不是手动执行写入 hooks 文件这个操作，甚至连第一步都做不到，可是回想上面 husky 的使用方式，我们只需要安装 husky 后进行配置即可，并不需要手动执行什么命令。</p><p>那 Huksy 是如何做到这一点的呢？动动你聪明的小脑瓜，有没有解决方案呢？</p><p>我们先来分析一下为什么无法做到自动同步更新 hooks，归根到底就是因为无法检测修改 <code>package.json</code> 后自动执行写入 hooks 操作，那我们不妨换一种思路：<strong>不用在修改 <code>package.json</code> 时执行写入操作，而是在执行 hooks 时去执行 <code>package.json</code> 中对应的 <code>hooks</code>。</strong></p><p>可能有点拗口，换句话说就是我们在一开始就把所有的 hooks 预注册了，然后在每一个 hooks 脚本中做同一件事：寻找 <code>package.json</code> 中对应的 hooks 并执行。</p><p>可能会觉得有点奇技淫巧 ，但也不失为一种曲线救国的方式，而事实上在 husky v4 之前还真的是这么做的。</p><p>那我们如何在一开始就注册所有 hooks 呢？</p><p>翻了一下 npm 的文档，发现有一个 <code>install</code> 钩子，它会在 <code>npm install</code> 后执行。</p><p>首先我们的项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── husky-test</span><br><span class="line">│   ├── husky</span><br><span class="line">│   │   ├── husky.js</span><br><span class="line">│   │   └── package.json</span><br><span class="line">│   └── package.json</span><br></pre></td></tr></table></figure><p>在 <code>husky/package.json</code> 添加以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;husky&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;install&quot;</span>: <span class="string">&quot;node husky&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>husky-test</code> 安装这个 npm 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;husky-test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;husky&quot;</span>: <span class="string">&quot;./husky&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候执行 <code>npm install</code> 会运行 <code>husky/husky.js</code> ，我们就可以在这个文件中预注册所有的 hooks，不过在此之前我们先梳理一下整体实现逻辑：</p><ol><li>我们要在 <code>husky.js</code> 中预注册所有的 hooks，可以在这个<a href="https://git-scm.com/docs/githooks">文档</a>中参考所有的 hooks。</li><li>我们要在所有的 hooks 中写入脚本内容，使其可以在被执行时寻找 <code>package.json</code> 中对应的 hook，并将其执行结果返回。<ol><li>因为 hooks 的 exit code 非 0 时要中断本次操作。</li></ol></li></ol><p>因此，经过梳理后，我们的目录结构调整如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── husky                   // husky 包</span><br><span class="line">│   ├── package.json     </span><br><span class="line">│   ├── husky.js            // install 入口</span><br><span class="line">│   ├── installer           // 初始化，预注册 hooks</span><br><span class="line">│   │   └── index.js     </span><br><span class="line">│   ├── runner              // 寻找对应的 hook 并执行</span><br><span class="line">│   │   └── index.js     </span><br><span class="line">│   └── sh                  // 所有 hooks 统一调用脚本</span><br><span class="line">│       └── husky.sh     </span><br><span class="line">└── package.json            // 测试</span><br></pre></td></tr></table></figure><p>我们在 <code>husky.js</code> 中调用 install 进行初始化操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> install = <span class="built_in">require</span>(<span class="string">&#x27;./installer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">install()</span><br></pre></td></tr></table></figure><p>然后在 <code>installer/index.js</code> 中预注册 hooks：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// installer/index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hookList = [</span><br><span class="line">  <span class="string">&#x27;applypatch-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-applypatch&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-applypatch&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-merge-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prepare-commit-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;commit-msg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-commit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-rebase&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-checkout&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-merge&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-update&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;push-to-checkout&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pre-auto-gc&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;post-rewrite&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sendemail-validate&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git</span>(<span class="params">args, cwd = process.cwd()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cp.spawnSync(<span class="string">&#x27;git&#x27;</span>, args, &#123; <span class="attr">stdio</span>: <span class="string">&#x27;pipe&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>, cwd &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> git([<span class="string">&#x27;rev-parse&#x27;</span>, <span class="string">&#x27;--show-toplevel&#x27;</span>]).stdout.trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGitHooksDir</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = getGitRoot()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path.join(root, <span class="string">&#x27;.git/hooks&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookScript</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`#!/bin/sh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">. &quot;$(dirname &quot;$0&quot;)/husky.sh&quot;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHook</span>(<span class="params">filename, script</span>) </span>&#123;</span><br><span class="line">  fs.writeFileSync(filename, script, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  fs.chmodSync(filename, <span class="number">0o0755</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHook</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hookScript = getHookScript()</span><br><span class="line"></span><br><span class="line">  writeHook(filename, hookScript)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHooks</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  getHooks(gitHooksDir).forEach(createHook)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHooks</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hookList.map(<span class="function">(<span class="params">hookName</span>) =&gt;</span> path.join(gitHooksDir, hookName))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMainScript</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainScript = fs.readFileSync(</span><br><span class="line">    path.join(__dirname, <span class="string">&#x27;../../sh/husky.sh&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mainScript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMainScript</span>(<span class="params">gitHooksDir</span>) </span>&#123;</span><br><span class="line">  fs.writeFileSync(path.join(gitHooksDir, <span class="string">&#x27;husky.sh&#x27;</span>), getMainScript(), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gitHooksDir = getGitHooksDir()</span><br><span class="line"></span><br><span class="line">  createHooks(gitHooksDir)</span><br><span class="line">  createMainScript(gitHooksDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这一步的结果是在安装 husky 时，会自动创建 hooks、并将 <code>husky.sh</code> 复制到 <code>.git/hooks</code> 中，所有 hooks 都会调用 <code>husky,sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/husky.sh&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>husky.sh</code> 中主要是做一件事，调用 <code>runner/index</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh/husky.sh</span></span><br><span class="line">gitParams=<span class="string">&quot;$*&quot;</span></span><br><span class="line">hookName=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">npm husky-run <span class="variable">$hookName</span> <span class="string">&quot;<span class="variable">$gitParams</span>&quot;</span></span><br></pre></td></tr></table></figure><p><code>husky-run</code> 是我们自定义的一个命令，需要在 <code>package.json</code> 中先注册：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// husky/package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;husky&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;husky-run&quot;: &quot;./runner/index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;install&quot;: &quot;node husky&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实际上就是调用 <code>runner/index</code>，我们要在这个文件中寻找对应的 hook 并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line">const &#123; spawnSync &#125; = require(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line">const &#123; cosmiconfigSync &#125; = require(<span class="string">&#x27;cosmiconfig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getConf(dir) &#123;</span><br><span class="line">  const explorer = cosmiconfigSync(<span class="string">&#x27;husky&#x27;</span>)</span><br><span class="line">  const &#123; config = &#123;&#125; &#125; = explorer.search(dir) || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const defaults = &#123;</span><br><span class="line">    skipCI: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> &#123; ...defaults, ...config &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getCommand(cwd, hookName) &#123;</span><br><span class="line">  const config = getConf(cwd)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> config &amp;&amp; config.hooks &amp;&amp; config.hooks[hookName]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> runner(</span><br><span class="line">  [, , hookName = <span class="string">&#x27;&#x27;</span>, husky_GIT_PARAMS],</span><br><span class="line">  &#123; cwd = process.cwd() &#125; = &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">  const <span class="built_in">command</span> = getCommand(cwd, hookName)</span><br><span class="line"></span><br><span class="line">  const env = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (husky_GIT_PARAMS) &#123;</span><br><span class="line">    env.husky_GIT_PARAMS = husky_GIT_PARAMS</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">command</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> runCommand(cwd, hookName, <span class="built_in">command</span>, env)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> runCommand(cwd, hookName, cmd, env) &#123;</span><br><span class="line">  const &#123; status &#125; = spawnSync(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;-c&#x27;</span>, cmd], &#123;</span><br><span class="line">    cwd,</span><br><span class="line">    env: &#123; ...process.env, ...env &#125;,</span><br><span class="line">    stdio: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status !== 0) &#123;</span><br><span class="line">    const noVerifyMessage = [</span><br><span class="line">      <span class="string">&#x27;commit-msg&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-commit&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-rebase&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pre-push&#x27;</span></span><br><span class="line">    ].includes(hookName)</span><br><span class="line">      ? <span class="string">&#x27;(add --no-verify to bypass)&#x27;</span></span><br><span class="line">      : <span class="string">&#x27;(cannot be bypassed with --no-verify due to Git specs)&#x27;</span></span><br><span class="line"></span><br><span class="line">    console.log(`husky &gt; <span class="variable">$&#123;hookName&#125;</span> hook failed <span class="variable">$&#123;noVerifyMessage&#125;</span>`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status === 127) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> status || 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const status = await runner(process.argv)</span><br><span class="line">    process.exit(status)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;husky &gt; unexpected error&#x27;</span>, err)</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>我们来测试一下，在 <code>package.json</code> 添加如下配置：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;husky-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;husky&quot;: &quot;./husky&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="addition">+  &quot;husky&quot;: &#123;</span></span><br><span class="line"><span class="addition">+    &quot;hooks&quot;: &#123;</span></span><br><span class="line"><span class="addition">+      &quot;pre-commit&quot;: &quot;echo 123 &amp;&amp; exit 1&quot;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行一次 commit，得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">husky &gt; pre-commit hook failed (add --no-verify to bypass)</span><br></pre></td></tr></table></figure><p>OK，到这里我们除了一些代码上的健壮性问题以外，已经把大部分 husky v4 版本的核心功能都给实现了。</p><p>不过我们已经能够对 husky 的实现方式给摸透，各位同学认为这样的实现方式好不好呢？</p><p>其实 husky 的这种通过预注册所有 hooks 的方式一直被人诟病，详见 <a href="https://github.com/typicode/husky/issues/260">#260</a> 。</p><p>其实 husky 的维护者也知道这种方式属实不妥，不过由于当时 Git 的 hooks 机制，只能一直顶着骂名维护下去。</p><p>终于，在 Git v2.9 的版本升级中，正式支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，于是 husky 二话不说地进行了重构，用了一种全新的实现方式来做这件事，也就是我们今天看到的 husky v5 以后的版本（截止目前最新的 v8 版本）。</p><p>同时 husky 因为配置方式的缘故，使其仅局限于 node.js 项目，为了提高 husky 的使用范围，最新版本决定采用 CLI 配置的方式，参见：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</p><p>因此，最新版本的 husky 实现代码与前面版本截然不同，下面我们继续从 0 到 1 开始实现 husky。</p><h3 id="v4-以后的版本"><a href="#v4-以后的版本" class="headerlink" title="v4 以后的版本"></a>v4 以后的版本</h3><p>我们再把最新版本的 husky 使用方式介绍一遍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">npm set-script prepare <span class="string">&quot;husky install&quot;</span></span><br><span class="line">npm run prepare</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 hook</span></span><br><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;npm test&quot;</span></span><br><span class="line">git add .husky/pre-commit</span><br></pre></td></tr></table></figure><p>可以发现最新版本的 husky 无需利用 npm 的 install 钩子，毕竟已经不再局限于 node.js 项目，所以初始化操作需要另寻僻径，在 husky 文档中给出的解决方案是利用 npm 的 prepare 钩子，其可以执行 npm publish 和 不带参数的 npm install 时执行。</p><p>同时 husky 一共支持以下命令：</p><ol><li>husky install：安装，主要是配置 Git 的 core.hooksPath</li><li>husky uninstall：卸载，主要是恢复对 Git 的 core.hooksPath 的修改</li><li>husky set：新增 hook</li><li>husky add：给已有的 hook 追加命令</li></ol><p>因此，它的实现方式并不难，这里我直接张贴核心源码过来，首先是 CLI 的入口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get CLI arguments</span></span><br><span class="line"><span class="keyword">const</span> [, , cmd, ...args] = process.argv</span><br><span class="line"><span class="keyword">const</span> ln = args.length</span><br><span class="line"><span class="keyword">const</span> [x, y] = args</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set or add command in hook</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="function">(<span class="params">fn: (a1: <span class="built_in">string</span>, a2: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> (): <span class="function"><span class="params">void</span> =&gt;</span></span><br><span class="line">  <span class="comment">// Show usage if no arguments are provided or more than 2</span></span><br><span class="line">  !ln || ln &gt; <span class="number">2</span> ? help(<span class="number">2</span>) : fn(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLI commands</span></span><br><span class="line"><span class="keyword">const</span> cmds: &#123; [key: <span class="built_in">string</span>]: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">install</span>: (): <span class="function"><span class="params">void</span> =&gt;</span> (ln &gt; <span class="number">1</span> ? help(<span class="number">2</span>) : h.install(x)),</span><br><span class="line">  <span class="attr">uninstall</span>: h.uninstall,</span><br><span class="line">  <span class="attr">set</span>: hook(h.set),</span><br><span class="line">  <span class="attr">add</span>: hook(h.add),</span><br><span class="line">  [<span class="string">&#x27;-v&#x27;</span>]: <span class="function">() =&gt;</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">require</span>(p.join(__dirname, <span class="string">&#x27;../package.json&#x27;</span>)).version),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run CLI</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Run command or show usage for unknown command</span></span><br><span class="line">  cmds[cmd] ? cmds[cmd]() : help(<span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? <span class="string">`husky - <span class="subst">$&#123;e.message&#125;</span>`</span> : e)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="install-安装初始化"><a href="#install-安装初始化" class="headerlink" title="install 安装初始化"></a>install 安装初始化</h4><p>安装初始化主要做以下事情：</p><ol><li>拷贝 <code>husky.sh</code> 到项目中，其主要工作是添加 debug 开关以及支持 <code>.huskyrc</code> 配置文件，最后将其添加到 <code>.gitignore</code>。</li><li>将 Git 的 core.hooksPath 修改为项目目录的 <code>.husky</code>，后续添加的 hooks 都将存放在此目录。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">dir = <span class="string">&#x27;.husky&#x27;</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.HUSKY === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    l(<span class="string">&#x27;HUSKY env variable is set to 0, skipping install&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that we&#x27;re inside a git repository</span></span><br><span class="line">  <span class="comment">// If git command is not found, status is null and we should return.</span></span><br><span class="line">  <span class="comment">// That&#x27;s why status value needs to be checked explicitly.</span></span><br><span class="line">  <span class="keyword">if</span> (git([<span class="string">&#x27;rev-parse&#x27;</span>]).status !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Custom dir help</span></span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://typicode.github.io/husky/#/?id=custom-directory&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that we&#x27;re not trying to install outside of cwd</span></span><br><span class="line">  <span class="keyword">if</span> (!p.resolve(process.cwd(), dir).startsWith(process.cwd())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`.. not allowed (see <span class="subst">$&#123;url&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that cwd is git top level</span></span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(<span class="string">&#x27;.git&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`.git can&#x27;t be found (see <span class="subst">$&#123;url&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Create .husky/_</span></span><br><span class="line">    fs.mkdirSync(p.join(dir, <span class="string">&#x27;_&#x27;</span>), &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create .husky/_/.gitignore</span></span><br><span class="line">    fs.writeFileSync(p.join(dir, <span class="string">&#x27;_/.gitignore&#x27;</span>), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy husky.sh to .husky/_/husky.sh</span></span><br><span class="line">    fs.copyFileSync(p.join(__dirname, <span class="string">&#x27;../husky.sh&#x27;</span>), p.join(dir, <span class="string">&#x27;_/husky.sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure repo</span></span><br><span class="line">    <span class="keyword">const</span> &#123; error &#125; = git([<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;core.hooksPath&#x27;</span>, dir])</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    l(<span class="string">&#x27;Git hooks failed to install&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  l(<span class="string">&#x27;Git hooks installed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uninstall-卸载"><a href="#uninstall-卸载" class="headerlink" title="uninstall 卸载"></a>uninstall 卸载</h4><p>卸载的工作就更简单了，只需要恢复对 Git 的 core.hooksPath 的配置即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">uninstall</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  git([<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;--unset&#x27;</span>, <span class="string">&#x27;core.hooksPath&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-添加-hook"><a href="#set-添加-hook" class="headerlink" title="set 添加 hook"></a>set 添加 hook</h4><p>添加 hook 只需要创建对应的 hook 脚本文件，并写入内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">file: <span class="built_in">string</span>, cmd: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dir = p.dirname(file)</span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(dir)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`can&#x27;t create hook, <span class="subst">$&#123;dir&#125;</span> directory doesn&#x27;t exist (try running husky install)`</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    file,</span><br><span class="line">    <span class="string">`#!/usr/bin/env sh</span></span><br><span class="line"><span class="string">. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;cmd&#125;</span></span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    &#123; <span class="attr">mode</span>: <span class="number">0o0755</span> &#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  l(<span class="string">`created <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-追加-hook-命令"><a href="#add-追加-hook-命令" class="headerlink" title="add 追加 hook 命令"></a>add 追加 hook 命令</h4><p>add 命令是对已有的 hook 文件追加脚本文件，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">file: <span class="built_in">string</span>, cmd: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(file)) &#123;</span><br><span class="line">    fs.appendFileSync(file, <span class="string">`<span class="subst">$&#123;cmd&#125;</span>\n`</span>)</span><br><span class="line">    l(<span class="string">`updated <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    set(file, cmd)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文带领大家从 0 到 1 实现了 v4 以及最新版本的 husky，相信大家看完后对 husky 的实现方式也有了一定的了解，在以后的工作中使用它将会更加地得心应手，但如果你所在的项目中不是使用 Git，而是其它版本控制工具，也可以尝试基于 husky 改造，比如本人就曾尝试将 husky 改造使其<a href="https://github.com/gd4Ark/husky/pull/1">支持 Mercurial</a>。</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E6%AF%8F%E5%91%A8%E8%BD%AE%E5%AD%90/">每周轮子</category>
      
      
      <comments>https://4ark.me/post/weekly-npm-packages-02.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第12期：每周轮子计划、程序员应该如何写博客</title>
      <link>https://4ark.me/post/weekly-12.html</link>
      <guid>https://4ark.me/post/weekly-12.html</guid>
      <pubDate>Mon, 16 May 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;本周轮子&quot;&gt;&lt;a href=&quot;#本周轮子&quot; class=&quot;headerlink&quot; title=&quot;本周轮子&quot;&gt;&lt;/a&gt;本周轮子&lt;/h2&gt;&lt;p&gt;以前看过一个小册子 &lt;a href=&quot;https://github.yanhaixiang.com/make-wheels/</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="本周轮子"><a href="#本周轮子" class="headerlink" title="本周轮子"></a>本周轮子</h2><p>以前看过一个小册子 <a href="https://github.yanhaixiang.com/make-wheels/">《一天学习一个 npm 轮子，十天后变成轮子哥 》</a>，觉得这种「首先实现一个最 Low 的解决方案，然后慢慢优化，进而推导出最终的源码」的学习思路非常不错，所以我也决定从现在开始，每周都学习造一个 npm 轮子。</p><p>当然前期只要专注于那些日常使用、相对简单的 npm 包，毕竟能力有限，太复杂的包就很难可以讲透。</p><p>这是本周的轮子：<a href="/post/weekly-npm-packages-01.html">《每周轮子之 only-allow：统一规范团队包管理器》</a>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="程序员应该怎么写博客？"><a href="#程序员应该怎么写博客？" class="headerlink" title="程序员应该怎么写博客？"></a><a href="https://www.v2ex.com/t/851549">程序员应该怎么写博客？</a></h3><p>这是在 V2EX 上看到的一个帖子，OP 是之前周刊有提到过的 <a href="https://hutusi.com/">胡涂说</a> 的博主，在这个帖子中，我收获不少有用的建议，也意外地发现到几个不错的博客。我也想借此机会聊一聊关于这个话题的一些想法，也算是当作我个人写作的总结与反思。</p><p>回顾本站的第一篇文章<a href="/post/d69467be.html">《锐捷无线AP学习笔记 - 入门篇》</a>，写于 2018 年，到现在也就第 4 个年头，相比有些人动不动建站十几年，自然算得上年轻，但我认为我在写博客这件事上有过不少的挣扎与坚持，总结起来一共经历了以下几个阶段，但其实以下阶段并不是层层递进式的，它们有可能会同时进行：</p><ol><li><strong>记录学习笔记</strong>，这个阶段的产出主要是一些较为基础的学习笔记，原创度也较低，属于网上一搜一大把那种，对他人的帮助接近于无，还记得当时把一篇文章分享到技术社区上，被某些暴躁的老哥说我误人子弟，更有甚者直接开怼让我干脆把整本书都抄过来，当时有点气馁，但也承认自己的确是很菜，也曾自我怀疑过是否应该继续往中文社区「倒垃圾」，但最后还是坚持下来了。据我了解很多程序员刚开始写博客都是写这类学习笔记，也有很多人仅仅停留在这个阶段，甚至放弃，实在是太可惜了。</li><li><strong>资源分享类</strong>，写技术文章很难写，有深度的技术文更是难上加上，所以曾有一段时间我特别喜欢写「资源分享」类的文章，譬如<a href="/posts/share-site.html">《分享一些好用的网站》</a>、<a href="/post/549a6198.html">《分享一些好用的 Chrome 扩展》</a>，这类文章写起来压根不费多少时间和经历，你只需要把平时经常使用的网站、工具分享一一罗列出来，，就能在社区上收获不少的点赞收藏，这也是为什么 GitHub 上简体中文项目的 Markdown 项目如此之多的原因，但是我后来意识到，写这类文章对我个人能力的提升并没有多大帮助，如果你知道一些非常有用的工具，你确实应该将它分享出去给更多人，这是非常有价值的，但我的建议是千万不要满足于只写这类文章。</li><li><strong>较有深度的技术文章</strong>，随着工作时间的增长，在技术上有了一些的积累，我开始尝试写一些较有深度的技术文章，包括一些经典面试题讲解、源码阅读、某个知识点深入剖析、一些工具类库的踩坑记录等，写这类文章是最痛苦的，因为你会发现在写的过程突然在某个地方你自己也无法讲清楚，说明你并没有理解透彻，于是只能逼迫自己一边查阅文档、一边根据自己的理解用自己的话把它讲透，这过程中的收获自然也是非常大，对其他人的帮助也不小。</li><li><strong>与技术无关的</strong>，人都是有感情的动物，除了技术以来，总需要聊点其他的东西，有可能是生活上的一些感悟，也有可能是你针对某个事情的看法，这类文章，它既有可能会引起读者的共鸣，也有可能会因为与读者的看法不同而遭到反感，且很多时候，自己也不确定这些看法到底是不是正确的，所以会害怕被别人看到自己不成熟的一面，我也曾有过这方面的顾虑，不敢在博客上公开谈论太多与技术无关的事情，但后来发现是我多虑了，因为这类文章，往往最终的读者只有你自己，因为读者看你的文章，他也只会关心对他有帮助的地方，而且即便你当时所记录下来的自己可能是不成熟的，这也是你成长的印记，比如我常常会在迷茫的时候翻看起之前刚踏入职场时写下的<a href="/posts/why-i-became-a-programmer.html">《我为什么会成为一名程序员》</a>，告诉自己不要忘了为什么会走上技术这条路，所以不要害怕写技术以外的东西，这些稚嫩的文字很有可能会在多年以后一直激励着你。</li></ol><p>可能还有些同学会认为自己文笔不好、词穷，写不了这么多文字，其实也是多虑了，我坦白我的文笔其实很差，不能像别人那样出口成章、行云流水，但其实你只要把意思表达清楚、并且注入你的感情即可，总之多写、坚持写。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="QOTD-协议"><a href="#QOTD-协议" class="headerlink" title="QOTD 协议"></a><a href="https://en.wikipedia.org/wiki/QOTD">QOTD 协议</a></h3><p>QOTD 的全程是 <strong>Quote of the Day</strong>，翻译过来就是「每日报价」，在 <a href="https://datatracker.ietf.org/doc/html/rfc865">RFC 865</a> 中定义，监听的端口是 17，这是一个非常少用到的协议，目前仅剩的公共 QOTD 服务器只有几个：</p><table><thead><tr><th>服务器地址</th><th>TCP 端口</th><th>UDP 端口</th></tr></thead><tbody><tr><td>djxmmx.net</td><td>17</td><td>17</td></tr><tr><td>alpha.mike-r.com</td><td>17</td><td>17</td></tr><tr><td>cygnus-x.net</td><td>17</td><td>17</td></tr></tbody></table><p>可以用它做什么呢？</p><p>比如<a href="https://github.com/daya0576/daya0576">这里</a>就有一个在 GitHub Action 上利用该协议定时获取 djxmmx.net 服务器上的名人名言，将它更新到 Github Profile 中。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="Bash-Pitfalls-编程易犯的错误"><a href="#Bash-Pitfalls-编程易犯的错误" class="headerlink" title="Bash Pitfalls: 编程易犯的错误"></a><a href="https://kodango.com/bash-pitfalls-part-1">Bash Pitfalls: 编程易犯的错误</a></h3><p>本文是<a href="http://mywiki.wooledge.org/BashPitfalls">《Bash Pitfalls》</a>的中文翻译版，介绍了40多条日常 Bash 编程中，老手和新手都容易忽略的错误编程习惯。作者会在每条给出错误的范例上，详细分析与解释错误的原因，同时给出正确的改写建议。</p><h3 id="Docker-镜像构建的一些技巧"><a href="#Docker-镜像构建的一些技巧" class="headerlink" title="Docker 镜像构建的一些技巧"></a><a href="https://www.kawabangga.com/posts/4676">Docker 镜像构建的一些技巧</a></h3><p>本文分享几个 Docker 镜像构建的一些技巧，可以帮助你提高 Docker 镜像构建的效率，对于老手来说已经是非常基本的事情了，但是对于新手还是很有帮助的。</p><p>原文一共举例了 4 个技巧，在此我只详细讲解第一个技巧，其余的麻烦移步<a href="https://www.kawabangga.com/posts/4676">原文</a>查看。</p><ol><li>删除缓存</li></ol><p>使用 apt、pip 等包管理器下载包时一般都会产生缓存，以便后续下载时使用，但是在 Docker Image 中，我们不需要这些缓存，所以一般都会在下载后，手动清除缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN dnf install -y --setopt=tsflags=nodocs \</span><br><span class="line">    httpd vim &amp;&amp; \</span><br><span class="line">    systemctl enable httpd &amp;&amp; \</span><br><span class="line">    dnf clean all</span><br></pre></td></tr></table></figure><p>要切记千万不要像这样分开写，因为 Dockerfile 里面的每一个 <code>RUN</code> 都会创建一层新的 layer，这样其实是创建了 3 层 layer，前 2 层带来了缓存，第三层删除了缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM fedora</span><br><span class="line">RUN dnf install -y mariadb</span><br><span class="line">RUN dnf install -y wordpress</span><br><span class="line">RUN dnf clean all</span><br></pre></td></tr></table></figure><p>但其实 Docker 在 <a href="https://www.docker.com/blog/whats-new-in-docker-1-13/">v1.13</a> 中引入了 <em>–squash</em> 参数，可以在完成构建后将所有的 layers <strong>压缩成一个 layer</strong>，也就是说，最终构建出来的 Docker image 只有一层，所以，如上在多个 <code>RUN</code> 中写 clean 命令，其实也可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash</span><br></pre></td></tr></table></figure><ol start="2"><li>改动不频繁的内容往前放</li><li>构建和运行 Image 分离</li><li>检查构建产物</li></ol><h3 id="JavaScript-函数式组合：有什么大不了的？"><a href="#JavaScript-函数式组合：有什么大不了的？" class="headerlink" title="JavaScript 函数式组合：有什么大不了的？"></a><a href="https://jrsinclair.com/articles/2022/javascript-function-composition-whats-the-big-deal/">JavaScript 函数式组合：有什么大不了的？</a></h3><p>这是我看到过所有写 JavaScript 函数式组合里面最通俗易懂的一篇文章，作者从头开始一步步地实现 compose、pipe、flow 等方法，并且让对函数式组合了解不多的同学知道，函数式组合的好处在哪？</p><p>举个例子，假如我们使用 Array 的方法是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = commentStrs</span><br><span class="line">    .filter(noNazi)</span><br><span class="line">    .slice(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .map(emphasize)</span><br><span class="line">    .map(itemize)</span><br><span class="line">    .join(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p>而改用函数式组合的方式，则是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(<span class="number">10</span>),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样写的好处在哪呢？</p><p>首先，我们可以增加任何 Array 原型上没有的自定义方法：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(10),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(&#x27;\n&#x27;),</span><br><span class="line"><span class="addition">+   chaoticListify,</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外，我们可以自由地实现像 map 这些方法，比如用生成器的方式改成它，而无需改变调用它们的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="keyword">function</span>*(<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> iterable) <span class="keyword">yield</span> f(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> join = <span class="function"><span class="params">s</span> =&gt;</span> <span class="function"><span class="params">iterable</span> =&gt;</span> [...iterable].join(s);</span><br></pre></td></tr></table></figure><p>综上所述，使用函数式组合的方式编写代码可以让我们写出更加简洁、优雅的代码，更重要的是它给我们提供了另一种思考的方式。</p><h3 id="中国黑客关系图"><a href="#中国黑客关系图" class="headerlink" title="中国黑客关系图"></a><a href="https://mp.weixin.qq.com/s/gowGNyJ_MaP6meQDQlSSZw">中国黑客关系图</a></h3><p>本文是新书《沸腾信安志》的一篇预热文章，主要讲述了中国上个世纪末到本世纪初的传奇黑客们的故事，想要了解有哪些著名的黑客，以及他们今何在的同学可以看看。</p><blockquote><p>网络安全行业和武侠江湖是很像的，有门派组织，有江湖名号，有武林大会，有绝计和宝物，而且都是大侠少而恶盗多，甚至连朝廷的管制方式都很相似。</p><p>这种氛围里，竟然出了这样一群奇人。</p><p>他们在最艰苦的岁月里，只要把道德底线稍微降低一点，就可以衣食无忧，然而他们没有；</p><p>他们掌握着最高超的技术，却拿着流量行业一半甚至更低的薪水，只要稍微做点灰产，就能摆脱困境，然而他们没有；</p><p>他们忍受着社会的质疑，承担着行业流氓带来的负面，却仍然坚持着自己热爱的技术创新。</p><p>直到现在，他们终于等到了自己的时代。</p></blockquote><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/zonemeen/musicn">zonemeen/musicn</a>：🎵 一个下载高质量音乐的命令行工具</li></ul><ul><li><a href="https://www.similarweb.com/zh/">Similarweb</a>：查看并分析任何网站流量，站长必备工具</li></ul><ul><li><a href="https://codeit.codes/">Codeit</a>：手机连接 Git 查看代码的神器 APP</li></ul><ul><li><a href="https://www.queue.so/">Queue</a>：使用 Notion 发布 Twitter 的工具</li></ul><ul><li><a href="https://coverview.vercel.app/">Coverview</a>：生成文章题图的工具</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-12.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每周轮子之 only-allow：统一规范团队包管理器</title>
      <link>https://4ark.me/post/weekly-npm-packages-01.html</link>
      <guid>https://4ark.me/post/weekly-npm-packages-01.html</guid>
      <pubDate>Mon, 16 May 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;首先我们来提一个团队开发中很常见的需求：一般来说每个团队都会统一规定项目内只使用同一个包管理器，譬如 npm、yarn、pnpm 等，如果成</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先我们来提一个团队开发中很常见的需求：一般来说每个团队都会统一规定项目内只使用同一个包管理器，譬如 npm、yarn、pnpm 等，如果成员使用了不同的包管理器，则可能会因为 <em>lock file</em> 失效而导致项目无法正常运行，虽然这种情况一般都可以通过项目的上手文档来形容共识，但有没有更好的解决方案，比如在项目安装依赖时检测如果使用了不同的包管理器就抛出错误信息？</p><p>当然是可以的，pnpm 就有一个包叫做 <a href="https://www.npmjs.com/package/only-allow">only-allow</a> ，连 <a href="https://github.com/vitejs/vite/blob/c7fc1d4a532eae7b519bd70c6eba701e23b0635a/package.json#L16">vite</a> 都在使用它，所以本周我们就从 0 到 1 实现这个工具，以此对它的工作原理一探究竟。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>说干就干，我们先在 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#life-cycle-operation-order">npm 文档</a> 搜寻一番，发现有一个钩子叫做 <code>preinstall</code>：</p><blockquote><p>可以在运行 npm instal 之前执行某个命令，当 exit code 非 0 时终止运行</p></blockquote><p>所以第一步是在 <code>package.json</code> 中添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的问题就是：我们如何知道用户使用了哪一个包管理器？</p><p>我们知道 <code>process.env</code> 会包含当前脚本的运行环境，首先我们将它打印看看</p><p>分别使用 <code>yarn</code> 和 <code>npm install</code> 后，发现了以下几个相关字段的区别：</p><p>使用 <code>yarn</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_registry: &#x27;https:<span class="comment">//registry.yarnpkg.com&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/usr/local/lib/node_modules/yarn/bin/yarn.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;yarn/<span class="number">1.22</span><span class="number">.11</span> npm/? node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>npm</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_metrics_registry: &#x27;https:<span class="comment">//registry.npmjs.org/&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;npm/<span class="number">8.5</span><span class="number">.5</span> node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64 workspaces/<span class="literal">false</span>&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是三者的解释：</p><ol><li>npm_config_metrics_registry：npm 源，就是当我们安装 npm 包会从这个服务器上获取，可以通过 <code>npm config set registry</code> 或者     等工具进行配置。</li><li>npm_execpath：当前 npm 包管理器的执行目录，这个路径会根据你安装的方式而不同。</li><li>npm_config_user_agent：由包管理器设置的 UA，每个包管理器都不一样，比如 npm  <a href="https://github.com/npm/cli/blob/8a49e3ab6499c6196c5d7a0f6dad3b345944b992/lib/utils/config/definitions.js#L2190">lib/utils/config/definitions.js#L2190</a>，因此我们可以使用这个信息来判断客户端。</li></ol><p>因此我们可以通过 <code>process.env.npm_config_user_agent</code> 获取当前用户使用的包管理器，那么接下来的工作很简单了。</p><p>我们先写一个最 Low 的解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wantedPM = <span class="string">&#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = process.env.npm_config_user_agent.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的核心功能就已经实现了，还不赶紧发到 GitHub 开源一波坐等 stars？</p><p>别急，我们来思考下这段代码存在哪些不足：</p><ol><li>应该由用户指定可以使用哪一个包管理器。</li><li>这段代码的健壮性如何？</li></ol><p>那我们再修改一波，首先是接收用户传递参数，指定使用的包管理器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js yarn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改为通过接收参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ const argv = process.argv.slice(2)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const wantedPM = argv[0]</span></span><br><span class="line"><span class="deletion">- const wantedPM = &#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line">const usedPM = process.env.npm_config_user_agent.split(&#x27;/&#x27;)[0]</span><br><span class="line"></span><br><span class="line">if (usedPM !== wantedPM) &#123;</span><br><span class="line">  console.error(`You are using $&#123;usedPM&#125; but wanted $&#123;wantedPM&#125;`)</span><br><span class="line"></span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有第二个问题，这段代码的健壮性如何？譬如以下情况：</p><ol><li>用户不传或乱传参数怎么办？</li><li>如果以后有新需求：除了要限制包管理器，还要限制到具体某个版本怎么办？</li></ol><p>所以，我们再调整一波代码，检测传入的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们将获取 UA 的代码抽离出来，并使其可以获取版本，以便后续扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = getPackageManagerByUserAgent(</span><br><span class="line">  process.env.npm_config_user_agent</span><br><span class="line">).name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很好，现在我们已经将这个 npm 包的功能给实现了：<a href="https://www.npmjs.com/package/only-allow">only-allow</a>，可以看下它的源码：<a href="https://github.com/pnpm/only-allow/blob/master/bin.js">bin.js</a>。</p><p><strong>不过发现了一个问题：</strong>上面提到过 <code>preinstall</code>  钩子会在安装依赖时触发，但是经验证，npm 和 yarn 调用 <code>preinstall</code> 的时机不一样，npm 仅会在 <code>npm install</code> 时运行，而 <code>npm install &lt;pkg-name&gt;</code> 则不会，但 yarn 则会在 <code>yarn</code> 和 <code>yarn add &lt;pkg-name&gt;</code> 时都运行，所以如果想用这种方式限制 npm 使用者，可能无法达到预期，该问题在 2021 年<a href="https://github.com/npm/rfcs/issues/325">就有人提出</a>，但目前仍未有解决方案出现。</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/%E6%AF%8F%E5%91%A8%E8%BD%AE%E5%AD%90/">每周轮子</category>
      
      
      <comments>https://4ark.me/post/weekly-npm-packages-01.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第11期：扩大你的运气表面积（Luck Surface Area）</title>
      <link>https://4ark.me/post/weekly-11.html</link>
      <guid>https://4ark.me/post/weekly-11.html</guid>
      <pubDate>Thu, 05 May 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;扩大你的运气表面积&quot;&gt;&lt;a href=&quot;#扩大你的运气表面积&quot; class=&quot;headerlink&quot; title=&quot;扩大你的运气表面积&quot;&gt;&lt;/a&gt;扩大你的运气表面积&lt;/h2&gt;&lt;p&gt;想说两件事，第一件事，在上周的某天下午，我收到了一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="扩大你的运气表面积"><a href="#扩大你的运气表面积" class="headerlink" title="扩大你的运气表面积"></a>扩大你的运气表面积</h2><p>想说两件事，第一件事，在上周的某天下午，我收到了一封邮件：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204282317575.png" alt="image-20220428231741858"></p><p>这是 V2EX 上的一位老哥发来的邮件，他也在写周刊<a href="http://weekly.codelc.com/">《野生架构师》</a>，估计不少人都听过，毕竟最近在 V2EX 上比较活跃，收到这封来信让我非常开心，毕竟自己的周刊内容得到了他人的认可。</p><p>同时也让我知道了一个新的概念：运气表面积（Luck Surface Area）。</p><p>这个概念该如何理解，根据<a href="https://www.codusoperandi.com/posts/increasing-your-luck-surface-area">《How to Increase Your Luck Surface Area》</a>的描述：</p><blockquote><p>在你的生活中发生意外的数量，就是你的运气表面积，它与你所热爱的事情、以及被有效沟通的人数是成正比的，换句话说，你的运气是你自己创造的。</p></blockquote><p>它的公式是：<strong>运气表面积 = 你采取的行动 [X] x 你沟通的人数 [X]</strong> 。</p><p>运气表面积的工作原理是这样的，当你投入精力去做某件事情，你分享出去，你就会产生价值，但很多时候，这个价值会被所影响的人放大，它有可能会以某种你未曾预料的方式回报你，比如招聘你、投资你，但无论以何种方式发生，它都是偶然的。</p><p>说回上面那封邮件，我之所以写周刊在<a href="https://4ark.me/post/weekly-idea.html">《我为什么要写周刊》</a> 中有提到，我希望我能够对我每周所阅读的文章做一份总结，以此巩固我自身的理解，并希望不时输出自己观点的同时也能够帮助到其他人。</p><p>正因为我写周刊，被这位老哥看到了，发来这么一封邮件，让我感受到了被认可的快乐，因此更加坚定了我继续写周刊的信心，这就是我的运气表面积在扩大，但这一切都是非常偶然的，我在做这件事情的时候，我没有预料到这一点，所以正是因为我做这件事情为我自己创造了运气。</p><p>另外一件让我感到运气表面积在扩大的事，在一直订阅的<a href="https://hutusi.com/">胡涂说</a>的周刊<a href="https://hutusi.com/articles/weekly-13">《No.13: 周刊的周刊》</a>发现了他推荐我的周刊，而他的原话是：</p><blockquote><p>看到很多博主在写周刊，我想还是把这一传统给拾起来。</p></blockquote><p>这让我想到了一件非常奇妙的事情，前段时间 V2EX 上有讨论 <a href="https://v2ex.com/t/842511">为什么忽然间大家都开始做周刊了</a>，但我坦承我不是在跟风，或许别人也是如此，那么有没有可能是因为某一个人持续地在做这件事，影响了很多人，然后大家又互相影响，无形中扩大了大家的运气表面积，如果真是这样，那我认为是阮一峰影响了我，而我也可能在影响其他人。</p><p>最后从<a href="https://dimzou.feat.com/zh-CN/draft/580665/585314">这里</a>摘录一下以下三者的不同：</p><ol><li><strong>幸运</strong>是发生在你身上的事情，生在好人家是福，被雷劈是祸。</li><li><strong>机会</strong>需要您采取行动。您需要抓住机会，例如购买彩票，或约某人出去约会，以从偶然事件中受益。</li><li><strong>运气</strong>是成功或失败<em>显然</em>是偶然造成的。看起来这是一个机会，因为我们很少看到在成功或失败之前发生的一切。运气是通过发现和创造机会来实现的。这是你行为的直接后果。</li></ol><p>所以，记住一件事情，<strong>你可以创造你的运气，只要你去做更多的事情影响别人</strong>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="POSSE-和-Mastodon"><a href="#POSSE-和-Mastodon" class="headerlink" title="POSSE 和 Mastodon"></a>POSSE 和 Mastodon</h3><p>POSSE 的全称是 Publish (on your) Own Site, Syndicate Elsewhere，意为「在你自己的网站上发布，在其他地方联合」。</p><p>这是 2010 年首次在<a href="https://steveivy.gitlab.io/tantek-celik-diso-20-brass-tacks.html">《Tantek Celik Diso 20 Brass Tacks》</a> 提出的一种联合模型方案：</p><blockquote><p>在你自己的网站上发布，拥有自己的 URL 和永久链接，并通过其他社交媒体、社区中公布该链接。</p></blockquote><p>可以通过这段短片<a href="https://www.youtube.com/watch?v=X3SrZuH00GQ&t=835s">《Own your content on Social Media using the IndieWeb》</a>快速了解 POSSE。</p><p>采用该模型的好处是：如果我的 Twitter 帐户被删除（被官方或我自己删除），我不会丢失任何重要内容。</p><p>其实已经不少人采用这个方案，譬如就不少博主都会将文章链接发到 Twitter、Telegram 频道上，一方面是起到推广的作用，另一方面正是因为 POSSE。</p><p>你也可以通过这个链接<a href="https://indieweb.org/POSSE">《POSSE - IndieWeb》</a> 了解更多信息。</p><p>之所以越来越多人采用这个方案，都是因为对官方的不信任，所以希望把数据掌握在自己的手中，所以这里简单介绍一下 Mastodon：</p><blockquote><p>Mastodon 是互联网上最大的去中心化的社交网络，它由一个非营利组织基于开放网络标准建立。</p></blockquote><p>简单来说就是一个自托管的类 Twitter、微博的网站，你可以构建并部署自己的 Mastodon 实例，也可以加入他人的实例，顺便一提之前川普搞的社交媒体的 <a href="https://en.wikipedia.org/wiki/Truth_Social">Truth Social</a> 也是基于 Mastodon 的。</p><p>但 Mastodon 也有它的不足之处，譬如：</p><ol><li>稳定性，毕竟只有少部分人在维护实例。</li><li>还没有一个好的策略去防止虚假信息，仇恨言论，骚扰等。</li></ol><p>但也有不少人开始尝试从 Twitter 转向 Mastodon，比如 <a href="https://2ality.com/index.html">2ality</a> 的博主 <a href="https://fosstodon.org/@rauschma">Axel Rauschmayer</a>，有兴趣的同学可以从 <a href="https://fosstodon.org/explore">Explore Fosstodon</a>  开始探索。</p><h3 id="造谣的成本有多低？"><a href="#造谣的成本有多低？" class="headerlink" title="造谣的成本有多低？"></a>造谣的成本有多低？</h3><p>在如今的网络，造谣的成本非常低，比如我们就可以通过 <a href="https://fakedetail.com/">Fake Details</a> 这个网站去伪造各式各样的假信息，可以伪造下面这些社交媒体的假截图：</p><ul><li>Twitter 推文</li><li>Tiktok</li><li>Youtube</li><li>等等…</li></ul><p>甚至只需要在某个完全不相关的视频上面截个图，就可以张冠李戴地套在另外一件时事上面，而我们该如何去辨别这些假信息呢？</p><p>在<a href="https://4ark.me/post/weekly-04.html">《周刊第4期：独立思考》</a> 曾推荐过几个比较可靠的事实核查网站，这里再贴一下：</p><ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul><p>除了看以上这些网站给出的结论，我们还可以通过这些网站提供的<a href="https://tfc-taiwan.org.tw/topic/4112">核查工具箱</a>，自己去学习如何做事实核查。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chrome-用户体验报告比较工具"><a href="#Chrome-用户体验报告比较工具" class="headerlink" title="Chrome 用户体验报告比较工具"></a><a href="https://crux.zaps.dev/">Chrome 用户体验报告比较工具</a></h3><p>你只需要在 Chrome UX Report Compare Tool 这个网站上输入一个或多个 URL，它将会列出它们的各项性能指标，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205052214723.png" alt="image-20220505221453130"></p><p>然而当我输入本 Blog 的域名时，它提示我：Chrome 用户体验报告中没有足够的数据，这是访问人数不够多的缘故。</p><p>如果想要了解背后的技术细节，可以看这篇文章<a href="https://web.dev/chrome-ux-report-api/">《使用 Chrome 用户体验报告 API》</a>。</p><h3 id="使用-Javascript-的可选操作符可能会破坏你的代码"><a href="#使用-Javascript-的可选操作符可能会破坏你的代码" class="headerlink" title="使用 Javascript 的可选操作符可能会破坏你的代码"></a><a href="https://p42.ai/blog/2022-05-04/javascript-refactoring-gotchas-5-ways-converting-to-optional-chaining-can-break-your-code">使用 Javascript 的可选操作符可能会破坏你的代码</a></h3><p>熟悉 JS 的同学都知道我们可以通过 <code>obj?.x</code> 这个语法来更安全地访问对象属性等，但是如果盲目地使用这个语法，可能会导致一些意想不到的事情发生，比如以下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value &amp;&amp; value.length&#125;</span>, <span class="subst">$&#123;value?.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="literal">undefined</span>);       <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">null</span>);            <span class="comment">// null, undefined</span></span><br><span class="line">test(<span class="literal">true</span>);            <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">false</span>);           <span class="comment">// false, undefined</span></span><br><span class="line">test(<span class="number">1</span>);               <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="number">0</span>);               <span class="comment">// 0, undefined</span></span><br><span class="line">test(&#123;&#125;);              <span class="comment">// undefined, undefined</span></span><br><span class="line">test([]);              <span class="comment">// 0, 0</span></span><br><span class="line">test(&#123; <span class="attr">length</span>: <span class="string">&quot;a&quot;</span> &#125;); <span class="comment">// a, a</span></span><br><span class="line">test(<span class="string">&#x27;&#x27;</span>);              <span class="comment">// , 0</span></span><br><span class="line">test(<span class="literal">NaN</span>);             <span class="comment">// NaN, undefined</span></span><br></pre></td></tr></table></figure><p>通过这个例子我们发现，仅当值为 undefined 的时候，Optional Chaining 才有可能按照预期运行，所以我们编写代码的时候一定要多加注意，什么时候应该用 &amp;&amp; 做短路判断，什么时候使用 Optional Chaining 语法。</p><h3 id="在-git-仓库中使用-find-exec-sed-是很危险的"><a href="#在-git-仓库中使用-find-exec-sed-是很危险的" class="headerlink" title="在 git 仓库中使用 find . -exec sed 是很危险的"></a><a href="https://cmdcolin.github.io/posts/2022-05-04-findseddangerous">在 git 仓库中使用 find . -exec sed 是很危险的</a></h3><p>如果你想在 git 存储库中全局替换某个字符，那么你很有可能会遇到这个问题：<a href="https://stackoverflow.com/questions/6758963/find-and-replace-with-sed-in-directory-and-sub-directories">Find and replace with sed in directory and sub directories</a>，这是因为 find 命令没有忽略 .git 目录，运行该命令可能会导致 .git 目录损坏，所以更好的方式是使用 git ls-files：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files | xargs sed -i -e <span class="string">&#x27;s/apple/orange/g&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="凯文-·-凯利-70-岁生日写的-103-条人生忠告"><a href="#凯文-·-凯利-70-岁生日写的-103-条人生忠告" class="headerlink" title="凯文 · 凯利 70 岁生日写的 103 条人生忠告"></a><a href="https://justinyan.me/post/4911">凯文 · 凯利 70 岁生日写的 103 条人生忠告</a></h3><p>2022年4月28日，凯文·凯利（Kevin Kelly）在他的网站上发布了 70 岁生日的文章：<a href="https://kk.org/thetechnium/103-bits-of-advice-i-wish-i-had-known/">103 Bits of Advice I Wish I Had Known</a>，意为：103 条我希望早点知道的人生忠告。</p><p>此为中译版，非常推荐阅读，在这里摘录我个人认为有启发的几句：</p><ol><li>99%的时间里，真正关键的时刻就是此刻。</li><li>除了你以外，没有人会真的记得你拥有什么东西。</li><li>“但是”之前的话都是废话。</li><li>当你原谅其他人的时候，他们不一定会知道这件事，但你自己却会被治愈。原谅不是我们给予他人的东西；而是我们给自己的礼物。</li><li>教育的一半作用是学习哪些东西可以被忽略。</li><li>不要相信你认为你相信的一切。</li><li>为了丰厚的回报，请对你完全不感兴趣的事物保持好奇。</li><li>重复别人是一个很好的开始。重复你自己则是一个令人失望的终点。</li><li>如果你对于一个主题的意见可以根据你另一个主题的意见预测得出，那你可能陷入了某种意识形态的掌控。如果你认真审视你自己的意识，你的结论其实是无法预测的。</li></ol><h3 id="质疑和信任"><a href="#质疑和信任" class="headerlink" title="质疑和信任"></a><a href="https://adactio.com/journal/19021">质疑和信任</a></h3><p>这是 Jeremy 两篇文章，主要讨论了本文作者发现的一个奇怪现象，Web 开发者普遍存在这样一种心态：他们会在项目中优先选择安装 npm 依赖，然后隐式地引入了更多的依赖，也就相当于完全地信任这些 npm 包以及它们的作者。</p><p>但作者认为更应该直接使用浏览器的原生特性，比如 HTML 元素、CSS 功能和 JavaScript API，虽然它们并不总是完美的，并且在开发过程中需要额外花费很多心思，但原生的特性更值得被信赖。</p><p>而关于这个话题的讨论将由此展开，有些人认为之所以普遍存在这样一种心态，是因为浏览器兼容性的缘故，譬如在 MDN 的 <a href="https://insights.developer.mozilla.org/reports/mdn-web-developer-needs-assessment-2019.html#needs-assessment-segmented-view-of-the-needs-ranking">Overall Needs Ranking</a> 中排名前 5 的需求有 4 个属于兼容性问题，以前的 jQuery 和 Bootstrap 就是在这样的需求下产生，而现在这种情况已经逐步得到改善，越来越多人开始倾向于使用浏览器原生特性，而不是借助第三方库，总得来说，Web 开发者对浏览器的信任正在恢复。</p><p>最后提出了一个设计原则：如果可用，请默认使用浏览器原生功能，而不是第三方库。</p><h3 id="使用-Rust-开发单页应用程序"><a href="#使用-Rust-开发单页应用程序" class="headerlink" title="使用 Rust 开发单页应用程序"></a><a href="https://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/">使用 Rust 开发单页应用程序</a></h3><p>这是一篇使用 Rust 和  <a href="https://yew.rs/">Yew</a>  从 0 到 1 开发单页应用的文章，对于想要学习 Rust 和 Wasm 的同学可以看看。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://exercism.org/">Exercism</a>：一个学习编程语言的网站，非常有用。</li></ul><ul><li><a href="https://kill-the-newsletter.com/">Kill the Newsletter</a>：可将通过邮件订阅的 newsletters 转换为 RSS 源。</li></ul><ul><li><a href="https://wantwords.net/">汉语反向词典</a>：输入描述或词语，找到更多相似词语，帮助词穷的人更好地写作。</li></ul><ul><li><a href="https://ludwig.guru/">Ludwig</a>：和上面的差不多，不过是针对英文的。</li></ul><ul><li><a href="https://www.youtube.com/watch?v=0eKVizvYSUQ">How Google Search Works</a>：一段介绍 Google 搜索如何工作的五分钟短片。</li></ul><ul><li><a href="https://notefolio.net/">notefolio</a>：一个韩国的 UI 设计网站。</li></ul><ul><li><a href="https://natto.dev/">natto</a>：一个在线画 2D canvas 的工具。</li></ul><ul><li><a href="https://jimmysong.io/eng-practices/">谷歌工程实践</a>：顾名思义，Google 的通用工程实践，几乎涵盖所有语言和项目，内含 Code Review 以及代码编写指南。</li></ul><ul><li><a href="https://workers.cloudflare.com/">Cloudflare Workers</a>：Cloudflare 的云函数产品。</li></ul><ul><li><a href="https://github.com/StepfenShawn/Cantonese">Cantonese</a>：一个高中生写的粤语编程语言。</li></ul><ul><li><a href="https://github.com/mattpocock/ts-error-translator">TypeScript Error Translator</a>：将 TypeScript 错误翻译成英语，提供 VSCode 扩展。</li></ul><ul><li><a href="https://github.com/adriancooney/puppeteer-heap-snapshot">puppeteer-heap-snapshot</a>：一个用来获取和查询 Chome DevTools 堆快照的 CLI 工具。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-11.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第10期：你如何在网上找到可靠的信息？</title>
      <link>https://4ark.me/post/weekly-10.html</link>
      <guid>https://4ark.me/post/weekly-10.html</guid>
      <pubDate>Tue, 26 Apr 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;本周见闻&quot;&gt;&lt;a href=&quot;#本周见闻&quot; class=&quot;headerlink&quot; title=&quot;本周见闻&quot;&gt;&lt;/a&gt;本周见闻&lt;/h2&gt;&lt;h3 id=&quot;Git-2-36-亮点&quot;&gt;&lt;a href=&quot;#Git-2-36-亮点&quot; class=&quot;headerlink&quot; ti</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Git-2-36-亮点"><a href="#Git-2-36-亮点" class="headerlink" title="Git 2.36 亮点"></a><a href="https://github.blog/2022-04-18-highlights-from-git-2-36/">Git 2.36 亮点</a></h3><p>4 月 18 日，Git 正式发布 <a href="https://lore.kernel.org/git/xmqqh76qz791.fsf@gitster.g/T/#u">2.36 版本</a>，其中包含 96 个贡献者的改动，其中有 26 个新特性，在此罗列一些我比较感兴趣的新特性：</p><ol><li>git log –remerge-diff，更好地显示合并提交的差异，在此之前，如果我们查看一个具有合并冲突的提交差异时，输入的结果往往很难理解，而现在使用 <code>--remerge-diff</code> 则可以用 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-mergeconflictStyle">mergeconflictStyle</a> 的样式显示差异。</li><li>更严格的存储库权限检查，在 2.35 版本时，出现了<a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">两个安全漏洞</a>，此漏洞会影响在多用户计算机上工作的用户，这可能会导致某个用户在其他用户的存储库上执行任意命令，在 Git <a href="https://lore.kernel.org/git/xmqqv8veb5i6.fsf@gitster.g/">2.35.2</a> 版本中发布了安全补丁，总得来说就是 Git 更改了默认行为，防止这种情况的发生，我们也可以通过最新的 <a href="https://git-scm.com/docs/git-config/#Documentation/git-config.txt-safedirectory">safe.directory</a> 配置来有意义地绕过这个行为。</li><li>我们都知道 git bisect 这个命令可以用于二分查找，快速定位引入 BUG 的提交，同时它也可以通过指定一个可执行脚本来自动化这个过程，<code>git bisect run test.sh</code>，但在此之前，Git 并没有检查指定的文件是否为可执行脚本，导致 bisect 运行出错，该问题现在得到修复。</li><li>还有很多，感兴趣自行了解。</li></ol><h3 id="问HN：你如何在网上找到可靠的信息？"><a href="#问HN：你如何在网上找到可靠的信息？" class="headerlink" title="问HN：你如何在网上找到可靠的信息？"></a><a href="https://news.ycombinator.com/item?id=31107699">问HN：你如何在网上找到可靠的信息？</a></h3><p>在 hacker news 上看到的一个帖子，在信息爆炸的时代，我们如何在网上找到可靠的信息？总结出了一些自认为有用的观点：</p><ol><li>在信息源寻找「信息」，而不是「观点」，我们根据这些「信息」，得到我们自己的「观点」，同时以开放的心态去验证自己的「观点」，留意那些与你不同观点的人。</li><li>永远不要相信单一的信息来源，譬如不要只看国内的媒体：）</li><li>摆脱信息茧房，学习使用 RSS 订阅你感兴趣的内容，但是如何寻找有用的信息源也是一大难题。</li><li>尝试使用英文搜索你的问题，如果 Google 不好用，可以试试 <a href="https://teclis.com/">Teclis</a>。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="JavaScript-根据背景色显示对应的文字颜色"><a href="#JavaScript-根据背景色显示对应的文字颜色" class="headerlink" title="JavaScript 根据背景色显示对应的文字颜色"></a>JavaScript 根据背景色显示对应的文字颜色</h3><p>在 2022 的今天，dark 模式已经成为任何一个关注用户体验的应用不可或缺的功能，其中有一个很常见的需求就是根据背景颜色决定对应的文字颜色，这里就简单讲述一下我的实现思考。</p><p>首先我们需要知道任何颜色都有对应的灰度值的，得到颜色对应的灰度以后，就能知道该颜色是属于偏亮还是偏暗。</p><p>而获取灰度值的公式为：(0.299 * <em>r</em> + 0.587 * <em>g</em> + 0.114 * <em>b</em>) / 255</p><p>下面我们简单测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 rgb 获取灰度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGrayLevelFromRgb</span>(<span class="params">[r, g, b]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b) / <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>])) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0.299</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>])) <span class="comment">// 0.07058823529411765</span></span><br></pre></td></tr></table></figure><p>而我们只需要设定一个阈值，大于这个阈值的就属于 light，否则为 dark 即可。</p><p>这里我设定的阈值是 0.85，这个阈值具体是多少根据实际情况而定。</p><h3 id="在-Vim-中保存只读文件"><a href="#在-Vim-中保存只读文件" class="headerlink" title="在 Vim 中保存只读文件"></a>在 Vim 中保存只读文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w ! sudo tee % &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="Mac-在-dock-隐藏特定应用"><a href="#Mac-在-dock-隐藏特定应用" class="headerlink" title="Mac 在 dock 隐藏特定应用"></a>Mac 在 dock 隐藏特定应用</h3><p>有时候我们想要在 Mac 的 dock 中隐藏特定应用，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsappinfo setinfo -app XXX ApplicationType=UIElement</span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="怎么花两年时间面试一个人"><a href="#怎么花两年时间面试一个人" class="headerlink" title="怎么花两年时间面试一个人"></a><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎么花两年时间面试一个人</a></h3><p>这是一篇 11 年前的文章（2011），但在今天看来仍然非常有用，本文比较长，但我还是建议你阅读。</p><p>这里简单摘要一些本文内容，本文开宗明义地提出一个问题：<strong>招聘难，难于上青天</strong>。</p><p>这是因为：</p><ol><li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定前找到他们。</li><li>比较差的会投很多次简历，找不到工作的时间越多，投的简历越多，给整个 pool 带来很多噪音，top10% 的简历也许根本不算全部人的 top10%。</li></ol><p>公司招到靠谱的人非常重要，所以，<strong>招聘也许是一个公司决策当中最最重要的一个环节</strong>。</p><p>本文作者就根据他的一些经验，给出了一些关于如何做招聘的建议。</p><p>最后作者给出如何花两年时间面试一个人的方法，那就是看面试者平时的积累，推荐的方式是：书 + GitHub，这样足以相当两年左右的面试。</p><h3 id="你应该阅读学术计算机科学论文"><a href="#你应该阅读学术计算机科学论文" class="headerlink" title="你应该阅读学术计算机科学论文"></a><a href="https://stackoverflow.blog/2022/04/07/you-should-be-reading-academic-computer-science-papers/">你应该阅读学术计算机科学论文</a></h3><p>作为一名在职程序员，你需要不断地学习，你可以通过查看教程、文档、StackOverflow，以及你可以找到的任何帮助你更好地编写代码并保持最新技能的内容。但是，你试过深入研究计算机科学论文来提高你的编程能力吗？</p><p>虽然以上提到的教程可以帮助你立即编写代码，但阅读学术论文能够帮助你了解编程的来龙去脉，从空指针到对象，这些编程中大部分日常使用的功能都可以追溯到上世纪 60 年代，未来的创新一样建立在今天的研究之上。</p><p>所以，不妨试一下直接通过阅读论文去了解这些编程的知识，如果认为阅读论文还是太难，可以试一下观看这些演讲：<a href="https://www.youtube.com/c/PapersWeLove/videos">PapersWeLove - YouTube</a>。</p><h3 id="WebAssembly-使用JavaScript-垃圾回收器"><a href="#WebAssembly-使用JavaScript-垃圾回收器" class="headerlink" title="WebAssembly 使用JavaScript 垃圾回收器"></a><a href="https://jott.live/markdown/js_gc_in_wasm">WebAssembly 使用JavaScript 垃圾回收器</a></h3><p>我们知道，JavaScript 自带有垃圾回收机制，而 WebAssembly 却没有这个机制，因为它在比较底层的环境中运行，我们只能靠自己分配内存。</p><p>目前有一个关于 WebAssembly 的<a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md">提案</a>，涉及实现一个垃圾回收机制，但可惜还处于 Stage 2，仍没有浏览器实现该功能。</p><p>而本文作者发现了一个取巧的方式可以实现这个需求，那就是使用 WeakRefs，总的来说就是通过 WeakRefs 特性，自行实现一个永久循环的函数，去做垃圾回收的事情。</p><p>感兴趣可以阅读相关<a href="https://github.com/bwasti/web_assembly_experiments/tree/main/memory_management">实现代码</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://it-tools.tech/">IT Tools</a>：一个开发者工具，包含日常使用的功能，如 Base64 转换、QR Code 生成，URL 解析等，使用体验极佳。</li></ul><ul><li><a href="https://www.joshwcomeau.com/operator-lookup/">Operator Lookup</a>：输入一个 JavaScript 的操作符（e.g. +、=&gt;），将会解释该操作符的作用，对初学者非常有用。</li></ul><ul><li><a href="https://gitexplorer.com/">Git Explorer</a>：通过的问答选择的方式寻找你想要的 Git 命令，从此使用 Git 命令不再求人。</li></ul><ul><li><a href="https://sourabhbajaj.com/mac-setup">macOS Setup Guide</a>：本指南介绍了在新 Mac 上设置开发环境的基础知识。旨在供所有人用作设置环境或安装语言/库的指南。</li></ul><ul><li><a href="https://tiny-helpers.dev/">Tiny Helpers</a>：Web 开发者的工具集合。</li></ul><ul><li><a href="https://iep.utm.edu/">Internet Encyclopedia of Philosophy</a>：互联网哲学百科全书，有很多关于形而上的哲学论文。</li></ul><ul><li><a href="https://stage.so/">Stage</a>：一个设计工具。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-10.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第9期：Web 发展中的 100 个重大事件</title>
      <link>https://4ark.me/post/weekly-09.html</link>
      <guid>https://4ark.me/post/weekly-09.html</guid>
      <pubDate>Sun, 17 Apr 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;本周见闻&quot;&gt;&lt;a href=&quot;#本周见闻&quot; class=&quot;headerlink&quot; title=&quot;本周见闻&quot;&gt;&lt;/a&gt;本周见闻&lt;/h2&gt;&lt;h3 id=&quot;Web-发展中的-100-个重大事件&quot;&gt;&lt;a href=&quot;#Web-发展中的-100-个重大事件&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Web-发展中的-100-个重大事件"><a href="#Web-发展中的-100-个重大事件" class="headerlink" title="Web 发展中的 100 个重大事件"></a><a href="https://developer.chrome.com/100/">Web 发展中的 100 个重大事件</a></h3><p>自 2008 年 Chrome 浏览器正式发布以来，到现在 Chrome 已经发展到第 100 个版本了，为此还开发了一个网站，该网站展示了从 2008 年 Chrome 浏览器发布以来的 100 个对于 Web 发展的重大里程碑事件，譬如 GitHub 一周年、Node.js 发布、Flexbox 提案等，有兴趣可以看看。</p><h3 id="我们如何失去-54K-的-GitHub-stars"><a href="#我们如何失去-54K-的-GitHub-stars" class="headerlink" title="我们如何失去 54K 的 GitHub stars"></a><a href="https://httpie.io/blog/stardust">我们如何失去 54K 的 GitHub stars</a></h3><p>相信大家都知道 <a href="https://github.com/httpie/httpie">httpie</a> 这个命令行工具，近日，由于维护者误操作将仓库设置为私有仓库，导致 54K 的 stars 被清零，经与 GitHub 官方沟通后，被告知无法恢复，截止今日（2022-04-17）已经重新涨回 12.7K。</p><p>httpie 在吐槽之余，还顺便教了一下 GitHub 做产品：</p><ol><li>UI/UX 设计，在设置为私有仓库时，告知用户会损失哪些数据。</li><li>数据库的软删除设计。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chromium-的-DNS-缓存时间"><a href="#Chromium-的-DNS-缓存时间" class="headerlink" title="Chromium 的 DNS 缓存时间"></a><a href="https://textslashplain.com/2022/03/31/chromiums-dns-cache/">Chromium 的 DNS 缓存时间</a></h3><p>Chromium 的 DNS 缓存时间大概在一分钟左右：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default TTL for successful resolutions with ProcTask.</span></span><br><span class="line"><span class="keyword">const</span> unsigned kCacheEntryTTLSeconds = <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>DNS 的解析过程比较复杂，有兴趣可以看这个：<a href="https://source.chromium.org/chromium/chromium/src/+/main:net/dns/README.md;drc=761feeebc0214d55f2cff89f5904f5521ab02610">Chrome Host Resolution</a>，或者简单看下这两张图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png" alt="img"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png" alt="img"></p><p>上图源自本站一篇旧文：<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p><p>如果想要查看浏览器 DNS 配置的详细信息，可以按照以下流程：</p><ol><li>打开：chrome://net-export，开始记录，打开任意一个网站发起请求，导出 JSON 文件。</li><li>在 <a href="https://netlog-viewer.appspot.com/#import">NetLog Viewer</a> 导入查看，DNS 栏目。</li></ol><h3 id="ECMAScript-提案-通过复制改变数组"><a href="#ECMAScript-提案-通过复制改变数组" class="headerlink" title="ECMAScript 提案 - 通过复制改变数组"></a><a href="https://2ality.com/2022/04/change-array-by-copy.html">ECMAScript 提案 - 通过复制改变数组</a></h3><p>这篇博客文章描述了 Robin Ricard 和 Ashley Claymore 提出的 ECMAScript 提案 <a href="https://github.com/tc39/proposal-change-array-by-copy">“Change Array by copy”</a>。它为 Array 和 TypedArray 提出了四种新方法：</p><ul><li><code>.toReversed()</code></li><li><code>.toSorted()</code></li><li><code>.toSpliced()</code></li><li><code>.with()</code></li></ul><p>大多数 Array 方法是无副作用的 – 它们不会更改调用它们的数组，例如：<code>filter</code>、<code>map</code> 等。</p><p>但也有副作用的方法，例如：<code>reverse</code>、<code>sort</code>、<code>splice</code>。</p><p>因此新加入的三个方法为上述三种方法提供了无副作用版本，除此之外还引入了一个新方法：<code>with。</code></p><p>它是下面这段代码的无副作用版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[index] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line">arr.with(index, value) <span class="comment">// 返回一个新的 array</span></span><br></pre></td></tr></table></figure><h3 id="CSS-父选择器-has"><a href="#CSS-父选择器-has" class="headerlink" title="CSS 父选择器 - :has()"></a><a href="https://ishadeed.com/article/css-has-parent-selector/">CSS 父选择器 - :has()</a></h3><p>在以前， 我们无法根据父元素是否包含某个子元素时决定父元素的样式。</p><p>譬如，我们希望在 <code>.card</code> 有子元素 <code>img</code> 时设置特定样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;a.jpg&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>card text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>:has()</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:has</span>(<span class="selector-tag">img</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>:has()</code> 不止可以用于检查父元素是否包含某个子元素，还可以检查后面的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 检查 <span class="selector-tag">h2</span> 后面跟着 <span class="selector-tag">p</span></span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:has</span>(+ <span class="selector-tag">p</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>但遗憾的是，截止目前（2022-04-18）只有 Safari 15.4和 Chrome Canary 支持该特性，详见 <a href="https://caniuse.com/css-has">caniuse</a>。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="React-18-允许组件渲染-Undefined"><a href="#React-18-允许组件渲染-Undefined" class="headerlink" title="React 18 允许组件渲染 Undefined"></a><a href="https://blog.saeloun.com/2022/04/14/react-18-allows-components-to-render-undfined.html">React 18 允许组件渲染 Undefined</a></h3><p>在 React 18 之前，如果我们这样渲染了一个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Circle <span class="keyword">from</span> <span class="string">&#x27;./Circle&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Square <span class="keyword">from</span> <span class="string">&#x27;./Square&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">&#123;type&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Circle</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;square&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Shape;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) : <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> <span class="attr">type</span>=<span class="string">&quot;rectangle&quot;</span>/&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Shape 组件返回 Undefined，我们将得到以下报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Shape(...): Nothing was returned from render. This usually means a <span class="built_in">return</span> statement is missing. Or, to render nothing, <span class="built_in">return</span> null.</span><br></pre></td></tr></table></figure><p>为了修复报错，我们必须显式返回 <code>null</code>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import Circle from &#x27;./Circle&#x27;;</span><br><span class="line">import Square from &#x27;./Square&#x27;;</span><br><span class="line"></span><br><span class="line">function Shape(&#123;type&#125;) &#123;</span><br><span class="line">  if(type <span class="comment">=== &#x27;circle&#x27;) &#123;</span></span><br><span class="line">    return &lt;Circle /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type <span class="comment">=== &#x27;square&#x27;) &#123;</span></span><br><span class="line">    return &lt;Square /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ return null;</span></span><br><span class="line">&#125;</span><br><span class="line">export default Shape;</span><br></pre></td></tr></table></figure><p>但随着 React 18 的发布，即便组件未返回任何内容，也不会引发运行时错误。</p><p>基于以下三点原因，使 React 18 作出此改动：</p><ol><li><p>与其抛出错误，不如使用 Lint 工具</p><ul><li>渲染 Undefined 报错这个机制是在 2017 年加入的，当时类型系统和 Lint 工具还没开始流行，但现在我们完全可以使用 ESLint 等工具帮我们处理这些类型的错误。</li></ul></li><li><p>很难创建正确的类型，考虑以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx </span></span><br><span class="line"><span class="keyword">const</span> Shape = (&#123; children &#125;: ComponentType): <span class="function"><span class="params">ComponentType</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>): <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须在 <code>ComponentType</code> 类型将 Undefined 排除在外，但更好的解决方法就是允许渲染 Undefined。</p></li><li><p>保持一致的行为</p><ul><li>因为最近 Suspense 的 fallbacks <a href="https://github.com/reactwg/react-18/discussions/72">允许渲染 Undefined</a>，所以保持一致。</li></ul></li></ol><h3 id="JavaScript-中-RegExp-与-String-replace-的神奇特性"><a href="#JavaScript-中-RegExp-与-String-replace-的神奇特性" class="headerlink" title="JavaScript 中 RegExp 与 String.replace 的神奇特性"></a><a href="https://blog.huli.tw/2022/04/14/javascript-string-regexp-magic/">JavaScript 中 RegExp 与 String.replace 的神奇特性</a></h3><p>下面这段代码的执行结果是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;example.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// ???</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str2)) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>相信很多人都会认为两个都是 true，但答案是 true 和 false，即便你写成这样，第二个输出结果也是 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这是因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#%E5%BD%93%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E6%A0%87%E5%BF%97%E7%9A%84%E6%AD%A3%E5%88%99%E4%BD%BF%E7%94%A8test">RegExp 是有副作用的</a>，以下为 MDN 原话：</p><blockquote><p>如果正则表达式设置了全局标志，<code>test() </code>的执行会改变正则表达式  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>lastIndex</code></a> 属性。连续地执行<code>test()</code>方法，后续的执行将会从 lastIndex 处开始匹配字符串，(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec()</code></a> 同样改变正则本身的 <code>lastIndex 属性值</code>).</p></blockquote><p>以下代码证明了这点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/foo/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is at 0</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is now at 3</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>再来看另外一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;4ark&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="regexp">/\w+/</span>.test(str)</span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们还能拿得到 str 之前的值吗？</span></span><br></pre></td></tr></table></figure><p>答案是可以的，因为 RegExp 上有一个神奇的属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/input#%E8%AF%AD%E6%B3%95">RegExp.input</a>。</p><p>除此之外，还有这些：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch">RegExp.lastMatch</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastParen">RegExp.lastParen</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/leftContext">RegExp.leftContext</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/rightContext">RegExp.rightContext</a></li></ol><p>但是需要注意，这些特性是非标准的，请尽量不要在生产环境中使用它！</p><p>另外原文还有关于 String.replace 的神奇特性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">使用字符串作为参数</a>，简单来说就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123&#123;n&#125;456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 123A456</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123123A456，原本 &#123;n&#125; 的地方变成 123A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$`A&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456A456，原本 &#123;n&#125; 的地方变成 456A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$&#x27;A&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="在用户离开页面时可靠地发送-HTTP-请求"><a href="#在用户离开页面时可靠地发送-HTTP-请求" class="headerlink" title="在用户离开页面时可靠地发送 HTTP 请求"></a><a href="https://css-tricks.com/send-an-http-request-on-page-exit/">在用户离开页面时可靠地发送 HTTP 请求</a></h3><p>我们希望在用户离开当前页面时发送一个 HTTP 请求，这是一个非常常见的需求，譬如页面埋点等。</p><p>但根据 <a href="https://developer.chrome.com/blog/page-lifecycle-api/">Chrome 页面的生命周期</a>显示，在页面终止运行时，无法保证进程内的请求会成功，因此，在离开页面时发送请求可能并不可靠，如果我们依赖这个行为，则会出现潜在的重大问题。</p><p>通过下图可看出在页面离开时，请求会被取消掉：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204181217957.gif" alt="在“网络”选项卡中查看 HTTP 请求失败"></p><p>为什么请求会被取消呢？下面是 Chrome 对于页面终止生命周期（Terminated）的描述：</p><blockquote><p>A page is in the <em>terminated</em> state once it has started being unloaded and cleared from memory by the browser. No <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task">new tasks</a> can start in this state, and in-progress tasks may be killed if they run too long.</p><p><strong>Possible previous states:</strong><br><a href="https://developer.chrome.com/blog/page-lifecycle-api/#state-hidden">hidden</a> <em>(via the <a href="https://developer.chrome.com/blog/page-lifecycle-api/#event-pagehide"><code>pagehide</code></a> event)</em></p><p><strong>Possible next states:</strong><br>NONE</p></blockquote><p>简单来说就是一个页面被卸载并从内存清除时，它就处于终止状态，在这种状态下，没有新的任务可以启动，正在运行的任务如果运行时间过长，则有可能会被 killed 掉。</p><p>那我们应该如何解决这个问题呢？有下面几种方案：</p><ol><li>阻塞页面跳转，直到请求被响应：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for response to come back...</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;/log&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attr">some</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...and THEN navigate away.</span></span><br><span class="line">   <span class="built_in">window</span>.location = e.target.href;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但这样也有很明显的缺点，1）损害用户体验；2）没有包含所有页面离开行为，例如关闭浏览器 tab。</p><ol start="2"><li>使用 Fetch 的 <a href="https://fetch.spec.whatwg.org/#request-keepalive-flag">keepalive</a> 选项，使请求继续保留，即便页面已终止。</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/some-other-page&quot; id=&quot;link&quot;&gt;Go to Page&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.getElementById(&#x27;link&#x27;).addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;</span><br><span class="line">    fetch(&quot;/log&quot;, &#123;</span><br><span class="line">      method: &quot;POST&quot;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">      &#125;, </span><br><span class="line">      body: JSON.stringify(&#123;</span><br><span class="line">        some: &quot;data&quot;</span><br><span class="line">      &#125;), </span><br><span class="line"><span class="addition">+     keepalive: true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <a href="https://w3c.github.io/beacon/#sendbeacon-method">Navigator.sendBeacon()</a> 方法</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/some-other-page&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">some</span>: <span class="string">&quot;data&quot;</span> &#125;)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span> &#125;);</span></span><br><span class="line"><span class="javascript">    navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, blob));</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 a 标签的 <a href="https://css-tricks.com/the-ping-attribute-on-anchor-links/">ping 属性</a></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:3000/other&quot;</span> <span class="attr">ping</span>=<span class="string">&quot;http://localhost:3000/log&quot;</span>&gt;</span></span><br><span class="line">  Go to Other Page</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击该链接后，它会自动发出一个 POST 请求，并将 href 属性放在请求头中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers: &#123;</span><br><span class="line">  &#x27;ping-from&#x27;: &#x27;http:<span class="comment">//localhost:3000/&#x27;,</span></span><br><span class="line">  &#x27;ping-to&#x27;: &#x27;http:<span class="comment">//localhost:3000/other&#x27;</span></span><br><span class="line">  &#x27;content-type&#x27;: &#x27;text/ping&#x27;</span><br><span class="line">  <span class="comment">// ...other headers</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但有如下限制：</p><ol><li>只能在 a 标签上使用</li><li>浏览器支持很好，但 Firefox 除外 :(</li><li>无法自定义发送的数据…</li></ol><p>如果选择使用哪个方法呢？文中还给出了一个很好的提示：</p><ul><li>以下情况，推荐使用 fetch + keepalive<ul><li>需要自定义 header 和请求内容</li><li>希望发出 GET，而不只是 POST</li><li>需要支持较旧的浏览器，并且已有 fetch 的 polyfill。</li></ul></li><li>以下情况，推荐使用 <code>sendBeacon()</code><ul><li>只是简单的请求，不需要太多的自定义内容</li><li>喜欢更干净、更优雅的 API。</li><li>您希望保证您的请求不会与应用程序中发送的其它高优先级的请求竞争。</li></ul></li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/Troland/how-javascript-works">Troland/how-javascript-works</a>：本文是翻译介绍 JavaScript 的工作原理的，该系列原文还在更新中，原文见<a href="https://blog.sessionstack.com/tagged/tutorial">这里</a>。此为<a href="https://xcoder.in/">死月</a>翻译的中文版。</li></ul><ul><li><a href="https://webaim.org/projects/million/">The WebAIM Million</a> ：2022年关于前 100 万个主页的可访问性报告。</li></ul><ul><li><a href="https://turborepo.org/">Turborepo</a>：Turborepo 是一个针对 JavaScript 和 TypeScript 代码库的高性能构建系统。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-09.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第8期：阅读 ECMAScript 规范</title>
      <link>https://4ark.me/post/weekly-08.html</link>
      <guid>https://4ark.me/post/weekly-08.html</guid>
      <pubDate>Mon, 11 Apr 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;阅读-ECMAScript-规范&quot;&gt;&lt;a href=&quot;#阅读-ECMAScript-规范&quot; class=&quot;headerlink&quot; title=&quot;阅读 ECMAScript 规范&quot;&gt;&lt;/a&gt;阅读 ECMAScript 规范&lt;/h2&gt;&lt;p&gt;有必要先向部分初学者解释一下</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="阅读-ECMAScript-规范"><a href="#阅读-ECMAScript-规范" class="headerlink" title="阅读 ECMAScript 规范"></a>阅读 ECMAScript 规范</h2><p>有必要先向部分初学者解释一下 JavaScript 和 ECMAScript 的区别，最开始 ECMA 仅是 European Computer Manufacturers Association （欧洲计算机制造商协会）的首字母缩写，不过随着计算机的国际化，组织的标准牵涉到很多其他国家，因此这个组织已经改名为 Ecma 国际，所以现在的 Ecma 本身就是一个名字，不再是首字母缩写。</p><p>ECMAScript 与 JavaScript 其实就是同一个东西，只是因为 JavaScript 这个名称已经被 Sun 公司注册了商标，并且不开放给 Ecma 协会使用，所以 JavaScript 的标准只能叫做 ECMAScript，而 JavaScript 可以看做是 ECMAScript 规范的一种实现。</p><p>我们为什么要学习阅读 ECMAScript 规范呢？如果你只是一名 JavaScript 的初学者，你确实没有太大的必要去阅读 ECMAScript 规范，只需要通过阅读 MDN 文档就能学习如何编写 JavaScript，但随着 JavaScript 水平的提升，我们会越来越不满足于使用，我们会想要知道更多内部的细节，然而并不是所有的 JavaScript 细节都会在 MDN 文档上说明。</p><p>下面我就举个在工作中真实遇到的场景，以此阐述我们为什么需要阅读 ECMAScript 规范。</p><p>考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">300</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">200</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="number">50.5</span>: <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得这段代码的输出顺序是什么呢？答案是：<code>100,200,300,50.5</code>。</p><p>这是为什么呢？</p><p>从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a> 的 MDN 文档中，无法得到我们想要的答案，这时候就只能通过阅读 ECMAScript 规范：</p><p> <img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080105185.png" alt="image-20220408010524823"></p><p>通过以上信息我们得知，JavaScript 在遍历一个对象的时候，它将按照如下规则执行：</p><ol><li>创建一个空的列表用于存放 keys</li><li>将所有<strong>合法的数组索引</strong>按升序的顺序存入</li><li>将所有<strong>字符串类型索引</strong>按属性创建时间以升序的顺序存入</li><li>将所有 <strong><code>Symbol</code> 类型索引</strong>按属性创建时间以升序的顺序存入</li><li>返回 keys</li></ol><p>PS：当然 for…in 是不会返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> 类型的属性的，需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>。</p><p>以上源自我遇到的一个真实案例，详见<a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a>。</p><p>相信大家都已经非常清楚学习阅读 ECMAScript 规范的重要性，可 ECMAScript 规范也不是这么容易阅读的，所以这里提供了一些文章，帮助你快速学习阅读 ECMAScript 规范：</p><ul><li><a href="https://timothygu.me/es-howto/#example-string-prototype-substring">How to Read the ECMAScript Specification</a></li><li><a href="https://v8.dev/blog/tags/understanding-ecmascript">Understanding the ECMAScript spec</a></li><li><a href="https://blog.huli.tw/2022/01/30/how-to-validate-javascript-knowledge/">你知道的 JavaScript 知識都有可能是錯的</a></li></ul><p>总之，与本文一样带着问题去阅读，往往能够事半功倍。</p><h2 id="《编程语言的设计与实现》——-松本行弘"><a href="#《编程语言的设计与实现》——-松本行弘" class="headerlink" title="《编程语言的设计与实现》—— 松本行弘"></a>《编程语言的设计与实现》—— 松本行弘</h2><p>此书是 Ruby 语言的创造者 —— 松本行宏在《日经Linux》杂志上的连载整合而成，主要介绍了新语言 Streem 的设计与实现过程。作者从设计 Streem 这门新语言的动机开始讲起，由浅入深，详细介绍了新语言开发中的各个环节，以及语言设计上的纠结与取舍，其中也不乏对其他编程语言的调查与思考，向读者展示了创建编程语言的乐趣。</p><p>笔者现在刚看完第二章，不过也可以谈谈我的阅读感悟：作为一名野生前端，我对编译原理可谓是一窍不通，顶多也就写个 Babel 小玩具的水平，像《编译原理》这种专业书，我是连前十页都啃不下去，好在日系书籍有一个很大的特点就是：<strong>浅显易懂</strong>，此书也不例外，在前两章就带领读者如何通过 lex 进行词法解析，然后通过 yacc 进行语法解析，这过程还会将编译原理中的一些知识带出来，譬如 BNF（巴科斯范式）、窥孔优化等。</p><p>除了编译原理以外，我们还可以通过本书学习如何站在语言设计者的角度去思考语言的特性，为什么要这么设计，从而使我们的视野更加开阔，所以建议每一位开发者都阅读本书（对我这种野生程序员尤为重要）。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="CSS-属性使用次数排行榜"><a href="#CSS-属性使用次数排行榜" class="headerlink" title="CSS 属性使用次数排行榜"></a><a href="https://chromestatus.com/metrics/css/popularity">CSS 属性使用次数排行榜</a></h3><p>Chrome 使用<a href="https://source.chromium.org/chromium/chromium/src/+/main:tools/metrics/histograms/enums.xml">匿名使用统计数据</a>计算每个在 Chrome 浏览器加载的页面中 CSS 属性出现的次数，数据的实时性大概在 24 小时之内。</p><p>以下截取部分排名靠前的 CSS 属性：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080001598.png" alt="image-20220408000057438"></p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="为什么-HTTP-301-后会把-POST-转为-GET？"><a href="#为什么-HTTP-301-后会把-POST-转为-GET？" class="headerlink" title="为什么 HTTP 301 后会把 POST 转为 GET？"></a><a href="https://zh.wikipedia.org/wiki/HTTP_301">为什么 HTTP 301 后会把 POST 转为 GET？</a></h3><p>根据 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2">RFC 7231, section 6.4.2: 301 永久重定向</a> 指出：</p><blockquote><p>Note: For historical reasons, a user agent MAY change the request<br> method from POST to GET for the subsequent request.  If this<br> behavior is undesired, the 307 (Temporary Redirect) status code<br> can be used instead.</p></blockquote><p>简而言之就是因为历史原因，当某些 HTTP/1.0 客户端收到该状态码时，可能会将 POST 方法改为 GET 方法，继续向新地址发出请求，这是错误的实现——故而后续标准引入了 <a href="https://zh.wikipedia.org/wiki/HTTP_307">HTTP 307</a>。</p><p>所以最好只在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a> 方法时使用 301，其他情况使用 307 或者 308 来替代 301。</p><h3 id="JavaScript-的数字安全范围"><a href="#JavaScript-的数字安全范围" class="headerlink" title="JavaScript 的数字安全范围"></a><a href="https://blog.huli.tw/2022/03/14/javascript-number/">JavaScript 的数字安全范围</a></h3><p>你会如何解释这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们知道 JavaScript 的数字是用 64 bit 來存，而且遵循的规格是 IEEE 754-2019，既然用 64 bit 来存，那可以表示的数字自然是有限的。</p><p>我们可以用 <code>Number.MAX_SAFE_INTEGER</code> 表示 JavaScript 最大正整数的安全范围，也就是 <code>2^53 - 1</code> = <code>9007199254740991</code>。</p><p>这里所说的安全指的是：<strong>能够准确区分两个不相同的值</strong>，例如 <code>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2</code> 这在 JavaScript 上是成立的，但它在数学上是错误的，我们可以使用 <code>Number.isSafeInteger()</code> 来判断一个数字是否是一个「安全整数」。</p><p>需要注意的是，最大的安全范围不代表 JavaScript 只能存储 <code>Number.MAX_SAFE_INTEGER</code> 这么大的数字，其实我们最大可以存储 <code>Number.MAX_VALUE</code> 也就是 1.7976931348623157e+308 ，只是它不在安全范围之内罢了。</p><p>总之，对于一些比较大的数字（譬如 uuid 这类），优先考虑是否使用 String 类型，如果一定要数字类型，可以了解下 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>。</p><h3 id="为什么「Enter键」要被翻译为「回车键」？"><a href="#为什么「Enter键」要被翻译为「回车键」？" class="headerlink" title="为什么「Enter键」要被翻译为「回车键」？"></a><a href="https://haohailong.net/2012/why-enter-key-is-huiche-in-chinese">为什么「Enter键」要被翻译为「回车键」？</a></h3><p>其实「回车」并不是 “Enter” 的翻译，而是 “return” 的翻译。这个 return 其实指的是 “↵+Enter” 中箭头的意思，换言之，Enter 并不是“↵”的一个解释，严格讲 “Enter” 和“↵”是这个键的两种不同的名称，也即两个不同的用途。</p><p>之所以会被翻译成「回车」，是因为现代电脑键盘是从过去的打字机上继承过来的，在过去的机械打字机上有个部件叫「字车」，每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而 “Return” 键最早就是这个作用，因此被翻译为「回车」。</p><p>有兴趣可以看看这个视频：</p><iframe src="//player.bilibili.com/player.html?aid=591562931&bvid=BV1uq4y1k7EM&cid=440002269&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="DeepL-Api-设计中的欺骗战术"><a href="#DeepL-Api-设计中的欺骗战术" class="headerlink" title="DeepL Api 设计中的欺骗战术"></a><a href="https://zu1k.com/posts/thinking/deception-tactics-in-deepl-api-design/">DeepL Api 设计中的欺骗战术</a></h3><p>本文作者通过逆向 DeepL 的 Windows 客户端（C#），破解了 DeepL 如何实现接口防滥用。</p><p>直接说结论，其实 DeepL 并没有使用一些常规的方法（譬如 token、签名等）去实现接口防滥用，而是通过两个非常取巧的方法去把开发者绕晕：</p><ol><li>timestamp 参数并不是一个真实的时间戳，而是通过时间戳和源文本的长度进行伪造的，公式是：<code>ts - ts % i_count + i_count</code>，由于与真实的时间戳仅有毫秒部分的差别，一般人无法直接看出端倪。</li><li>id 参数就是一个随机数，只不过后续的请求会在此基础上 + 1，并且这个 id 会决定文本中一个小小的、微不足道的空格。但由于我们通过拿到结果后都会先对 JSON 进行一下格式化，所以很容易忽略这种细节。</li></ol><p>如果不是逆向源代码，相信一般人很难发现这两点细节，不得不感叹 DeepL 工程师的脑洞。</p><h3 id="Cloudflare-如何将网站加载时间缩短-30"><a href="#Cloudflare-如何将网站加载时间缩短-30" class="headerlink" title="Cloudflare 如何将网站加载时间缩短 30%"></a><a href="https://blog.cloudflare.com/early-hints/">Cloudflare 如何将网站加载时间缩短 30%</a></h3><p>本文介绍 Cloudflare 在 2021 年发布的一个新特性：Early Hints，准确来说它是一个 <a href="https://httpwg.org/specs/rfc8297.html">Web 标准</a>，它定义了一个新的状态码 103。</p><p>其最核心的功能是：在服务器响应 200 时，先向客户端响应 103，其响应内容包含这个网页所需呈现内容的资源提示，客户端可利用此提示加载页面速度，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204111949351.png" alt="img"></p><p>在上面提到的 <a href="https://httpwg.org/specs/rfc8297.html">RFC</a> 中可看到 HTTP 103 的响应大概长这样（其中可能会有多个 103 响应）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client request:</span><br><span class="line"></span><br><span class="line">  GET / HTTP/1.1</span><br><span class="line">  Host: example.com</span><br><span class="line"></span><br><span class="line">Server response:</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 103 Early Hints</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 200 OK</span><br><span class="line">  Date: Fri, 26 May 2017 10:02:11 GMT</span><br><span class="line">  Content-Length: 1234</span><br><span class="line">  Content-Type: text/html; charset=utf-8</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  &lt;!doctype html&gt;</span><br><span class="line">  [... rest of the response body is omitted from the example ...]</span><br></pre></td></tr></table></figure><p>我们可以在 Chrome 94 及更新版本使用该特性，关于更多内容可见：<a href="https://blog.cloudflare.com/early-hints/">early-hints</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://cn.history.js.org/index.html">JavaScript 二十年</a>：这本书纪录了从 1995 年到 2015 年这二十年的 JavaScript 历史，看完它会对 JavaScript 有不同的体会（还会知道很多冷知识），此为中译版，原版地址：<a href="http://wirfs-brock.com/allen/posts/866">JavaScript: The First 20 Years</a>。</li></ul><ul><li><a href="https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#readme">js-quirks</a>：关于 JavaScript 的一些怪癖语法说明，对于想要实现 JavaScript 解析器的同学很有帮助和启发。</li></ul><ul><li><a href="https://moonvy.com/">Moonvy 月维</a>：探索「设计生产力」之道，与你一起， 创造设计师与开发者的必备工具。</li></ul><ul><li><a href="https://quokkajs.com/">QUOKKA</a>：<em>Quokka</em> 是一个调试工具，可以为您正在编写的代码提供实时反馈（可惜大部分功能都要收费。</li></ul><ul><li><a href="https://www.iconfinder.com/p/free-ukraine-icons">Free Ukraine icons</a>：一些与乌克兰战争有关的免费 icon 图标。</li></ul><ul><li><a href="https://express.adobe.com/zh-Hans-CN/sp/">Adobe Creative Cloud Express</a>：Adobe 新推出的一个设计工具，可提供快速「去除背景」、「转换为 GIF」、「合并 PDF」以及更多高级操作。</li></ul><ul><li><a href="https://uxtools.co/challenges">UX Design Challenges | UX Tools</a>：一些 UX 的挑战，帮助你学习如何提高产品的用户体验。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-08.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第7期：使用新的周刊模板</title>
      <link>https://4ark.me/post/weekly-07.html</link>
      <guid>https://4ark.me/post/weekly-07.html</guid>
      <pubDate>Mon, 04 Apr 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;使用新的周刊模板&quot;&gt;&lt;a href=&quot;#使用新的周刊模板&quot; class=&quot;headerlink&quot; title=&quot;使用新的周刊模板&quot;&gt;&lt;/a&gt;使用新的周刊模板&lt;/h2&gt;&lt;p&gt;在本期开始采用新的周刊模板，新增了两个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本周见闻：一些有趣的</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="使用新的周刊模板"><a href="#使用新的周刊模板" class="headerlink" title="使用新的周刊模板"></a>使用新的周刊模板</h2><p>在本期开始采用新的周刊模板，新增了两个模块：</p><ul><li>本周见闻：一些有趣的事情、观点，与「分享文章」最大的区别在于它们通常是一些比较简短的信息。</li><li>tips：一些有用的技巧，可以帮助你提高工作效率。</li></ul><p>如此，周刊内容就显得更加丰富，可以分享更多元的信息了。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="React-v18-正式发布"><a href="#React-v18-正式发布" class="headerlink" title="React v18 正式发布"></a><a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18 正式发布</a></h3><ol><li><p><strong>自动批处理</strong></p><p>批处理是指 React 将多个状态更新合并到单个 re-render 中以获得更好的性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在之前: 只有 React 事件是批处理的。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 将渲染两次，每次状态更新一次（没有批处理的情况）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在之后: setTimeout、Promise、原生事件这类异步操作都将合并到一次 re-render 中。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 只会在最后重新渲染一次（这就是批处理！）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>了解更多：<a href="https://github.com/reactwg/react-18/discussions/21">https://github.com/reactwg/react-18/discussions/21</a></p></li><li><p><strong>Transitions</strong></p><p>这是 React 中的一个新概念，用于区分紧急和非紧急更新（过渡更新）。</p><ul><li><strong>紧急更新</strong>：反映了直接交互，如输入、单击、按下等。</li><li><strong>过渡更新</strong>：将 UI 从一个视图转换为另一个视图。</li></ul><p>通常，为了获得最佳用户体验，单个用户输入应同时导致紧急更新和非紧急更新。您可以在输入事件中使用 startTransition API 来通知 React 哪些更新是紧急的，哪些是过渡的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;startTransition&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急，显示输入的内容</span></span><br><span class="line">setInputValue(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部的任何状态更新标记为转换</span></span><br><span class="line">startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 过渡：显示结果</span></span><br><span class="line">  setSearchQuery(input);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>startTransition 中包含的更新操作都将作为过渡更新进行处理，如果出现更紧急的更新，则会打断之前的过渡更新，只渲染最新的。</p><p>了解更多：<a href="https://reactjs.org/docs/react-api.html#transitions">https://reactjs.org/docs/react-api.html#transitions</a></p></li></ol><ol start="4"><li><p><strong>Hooks</strong></p><ol><li><a href="https://reactjs.org/docs/hooks-reference.html#useid">useId</a>：用于在客户端和服务器上生成唯一 ID</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usetransition">useTransition</a>：标记为过渡性更新。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue">useDeferredValue</a>：允许您延迟重新渲染树的非紧急部分，类似于防抖。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore">useSyncExternalStore</a>：允许外部存储通过强制对存储的更新为同步来支持并发读取。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#useinsertioneffect">useInsertionEffect</a>：允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。</li></ol></li></ol><p>关于 React v18 更多新功能请查看：<a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18.0 – React Blog </a></p><h3 id="CSS-新提案-共享元素转场效果"><a href="#CSS-新提案-共享元素转场效果" class="headerlink" title="CSS 新提案 - 共享元素转场效果"></a><a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">CSS 新提案 - 共享元素转场效果</a></h3><p>CSS 的一个新提案，为切换页面提供平滑加载动画，无论是 SPA 还是 MPA 都适用，效果如下：</p><p><video src="https://user-images.githubusercontent.com/93594/141100217-ba1fa157-cd79-4a9d-b3b4-67484d3c7dbf.mp4" controls auto-play="true" ></video></p><p>关于更多可了解：<a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">shared-element-transitions/explainer.md</a></p><h3 id="尊重用户的默认字体大小"><a href="#尊重用户的默认字体大小" class="headerlink" title="尊重用户的默认字体大小"></a><a href="https://www.huy.rocks/everyday/03-27-2022-typography-respect-user-s-default-font-size">尊重用户的默认字体大小</a></h3><p>在处理文本和 CSS 时，我们通常都会默认设置一个固定的字体大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在大部分 WEB 网站都没有问题，但是对于内容网站（如新闻网站、论坛、博客等），这可能会导致可用性问题，因为每个人设置的默认字体大小有可能不一样，比如在 Chrome 就可以通过 chrome://settings/fonts 更改字体大小，所以更好的做法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在内部元素采用 <code>em</code> 和 <code>rem</code>。</p><h3 id="TypeScript-的-Web-API-类型声明是怎么来的？"><a href="#TypeScript-的-Web-API-类型声明是怎么来的？" class="headerlink" title="TypeScript 的 Web API 类型声明是怎么来的？"></a><a href="https://www.huy.rocks/everyday/03-29-2022-typescript-a-note-about-lib-dom-d-ts">TypeScript 的 Web API 类型声明是怎么来的？</a></h3><p>在 TypeScript 中，所有的 Web API 类型声明都在 <a href="https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts">lib.dom.d.ts</a> 中实现，一共多达 18877 行，它当然不是手动编写的，而是利用 <a href="https://github.com/w3c/webref">webref</a> 进行生成机器可读的 Web 标准，每 6 小时自动生成一次，然后利用 <a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/">TypeScript-DOM-lib-generator</a> 自动生成 lib.dom.d.ts。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="使用-Lighthouse-展示网站的-JavaScript-依赖关系"><a href="#使用-Lighthouse-展示网站的-JavaScript-依赖关系" class="headerlink" title="使用 Lighthouse 展示网站的 JavaScript 依赖关系"></a><a href="https://sia.codes/posts/lighthouse-treemap/">使用 Lighthouse 展示网站的 JavaScript 依赖关系</a></h3><p>熟悉 Webpack 的前端同学应该知道有一个插件叫做 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack-bundle-analyzer</a>，它用于展示每个 npm 包的体积。</p><p>现在我们也可以通过 Lighthouse Treemap 查看网站的 JavaScript 依赖关系和文件体积，效果如下：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041746785.jpg"></p><p>使用方法：在 Chrome 使用 Lighthouse 检查，然后在结果页中点击「View Treemap」即可。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="我讨厌的5个编码面试问题"><a href="#我讨厌的5个编码面试问题" class="headerlink" title="我讨厌的5个编码面试问题"></a><a href="https://thoughtspile.github.io/2022/03/21/bad-tech-interview/">我讨厌的5个编码面试问题</a></h3><p>本文列举几个作者最不喜欢的五类面试题目：</p><ol><li><p><strong>一些不重要的琐事</strong></p><p>这一类面试题通常是一些实际工作中很少遇到的场景，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> y = &#123;&#125;;</span><br><span class="line">x.__proto__ = y;</span><br><span class="line">y.__proto__ = x;</span><br><span class="line"><span class="built_in">console</span>.log(x.field);</span><br></pre></td></tr></table></figure><p>首先 <code>__proto__</code> 并不是一个标准的属性，实际工作中也应该避免使用它来修改原型链，能够正确回答它并不能真正显示候选人的 JavaScript 水平，只能体现他看过多少面试题。</p><p>这些题目通常关注于一些 JavaScript ES5 之前的糟粕，但现在已经是 2022 年了，我们没有必要再问这类问题。</p></li><li><p><strong>具体的细节</strong></p><p>这类问题通常过于关注细节，比如：</p><ul><li>迁移到 Webpack 6 会遇到什么问题？</li><li>如何检查浏览器对服务器发送事件的支持？</li></ul><p>这些问题，即便候选人真的在工作中解决过，除非事先准备好，否则也很难完整地回答出来，但我们都擅长通过搜索引擎解决这类问题。</p><p>这些题目极有可能是面试官最近解决过的一些棘手问题，他对此记忆犹新，但是根据这些问题来判断候选人的能力是不公平的，因为即便候选人回答不出来，也不代表他无法解决此类问题，这只是双方信息不对称所导致的。</p><p>所以面试官更应该着重关注于候选人最近解决过什么棘手问题，以此判断候选人解决问题的能力。</p></li><li><p><strong>混淆问题</strong></p><p>这些问题通常具有一个标准的答案，比如：</p><ol><li>Number 和 Object 之间有什么区别？</li></ol><p>这个题目的答案仅仅是：Number 是不可变的。</p><p>但候选人可能会认为这是一个开放式的题目，因此会从各方面对它们进行对比，这严重浪费时间。</p><p>同样的，这些问题也体现出候选人的面试经验，只有他被问过几次同样的题目，才熟练地知道它具有一个标准的答案。</p><p>所以面试官应该更直接地问：哪些 JavaScript 类型是不可变的。</p></li><li><p><strong>实现问题</strong></p><p>这类问题通常与浏览器实现细节相关，但它们不在规范里面：</p><ul><li><code>console.log(Object.keys(&#123; x: 0, y: 0 &#125;).join())</code> 问 x 和 y 哪个在前面？</li></ul><p>大多数人都知道正确的答案：根据添加顺序进行排序。</p><p>但此类特性依赖于 JS 引擎的实现，在 ECMAScript 规范中并没有明确定义。</p><p>所以面试官在问这类题目的时候，不应该持有标准化答案的心态，它更应该是一个开放式的题目。</p><p>PS：我曾写过一篇文章深入剖析 <code>Object.keys</code> 的规范：《<a href="https://4ark.me/post/how-object-keys-work.html">一行 Object.keys() 引发的血案</a>》。</p></li><li><p><strong>缺少上下文</strong></p><p>开放式问题是你在面试中可以问的最好的问题之一，因为它们具有挑战性，并能够真正体现候选人解决问题的能力，然而这些问题取决于面试官个人观点，否则容易引起反作用。</p><p>例如，这个函数有什么问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = fn(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题对于不同的人具有不同的观点，有些人觉得这段代码问题一大堆，比如：</p><ol><li>为什么使用 <code>var</code> 而不是 <code>let</code> ？</li><li>为什么不使用 <code>for...of</code> ?</li><li>它具有副作用，不应该直接修改 <code>arr</code></li><li>为什么不直接使用 <code>.map()</code> ?</li></ol><p>但也有人觉得它没有任何问题，既然它能够正常工作，我们为什么需要重构它？仅仅是为了让它看上去更好吗？我们的目标是什么？没有明确目标的重构就是浪费时间！</p><p>所以，双方都没有错，因为它完全取决于上下文。</p><p>所以，当你提出一个开放式问题时，要么放下你预期的答案，专注于解决问题的过程，要么引入缺失的要求来指导你想要的解决方案。</p><p>最后，作者给出了一个如何改进面试题目的建议：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041732556.png" alt="img"></p></li></ol><h3 id="不良面试官的七个习惯"><a href="#不良面试官的七个习惯" class="headerlink" title="不良面试官的七个习惯"></a><a href="https://blog.thoughtspile.tech/2022/03/28/interview-bad-habits/">不良面试官的七个习惯</a></h3><p>此文接着上一篇《我讨厌的5个编码面试问题》，列举几个面试官不好的习惯：</p><ol><li><p><strong>骄傲的自负</strong></p><p>有些面试官通常抱有一种「<strong>既然是我在面试你，那么我的能力自然比你强</strong>」的心态，他们往往摆出一副居高临下的样子，但你要清楚，你掌握所有面试问题的答案，这本就是一种信息不对称，所以你不应该抱有这种想法。</p></li><li><p><strong>专注于答案</strong></p><p>就像考试一样，面试官列出所有的面试题目，照本宣科地问问题，这类问题通常具有标准答案，但真正的工作中很少是考试一样解决问题的，并且这类问题都可以通过搜索引擎解决。</p><p>我们更应该倾向于开放式的题目，专注于候选人解决问题的过程，比如问「如何设计一个 Swiper」会比「具有哪些触摸事件」更合适。</p><p>此类问题其实还蕴含了一个顾虑：不信任候选人，认为他们缺乏这些基础知识。</p></li><li><p><strong>不给出任何提示</strong></p><p>试问当你身边的同事在某个问题卡住的时候，你会选择帮助他还是立即解雇他？所以我们应该引导候选人，而不是让他一个人苦苦挣扎。</p></li><li><p><strong>规划不善</strong></p><p>面试前没有提前规划好面试流程、或者是面试流程安排得太紧凑都会导致面试效果不佳。</p><p>假设你们明显有可能在某个问题上进行深入地探讨，千万不要仅仅因为你需要问更多初级的问题而打断候选人展示自己的机会。又或者你招聘的是高级开发人员，而候选者碰巧是一位非常不错的初级开发人员，你也不要轻易地错过。</p></li><li><p><strong>忽略简历</strong></p><p>不要浪费候选人的宝贵时间，假设候选人是一位顶尖大学毕业、甚至有一个技术博客和开源项目，这都可以体现出候选人的专业技能，而面试官仍要花费近 30 分钟去问一些基础问题，这会让候选人觉得是在浪费自己的时间。</p><p>诚然简历是可以造假，但仍不应该花费过多的时间去印证候选人是否具备这些基础知识，把时间花在更有价值的问题上。</p></li><li><p><strong>过渡延长</strong></p><p>不要让面试时间过长，除非你有自信保证候选人愿意花费这么多时间。</p></li><li><p><strong>避免群体面试的不良反应</strong></p><p>多个面试官时千万不要你一句我一句的，也不要显得某个面试官在场是完全没必要的，更好的做法是其中一位面试官负责主要的问题，其他面试官负责观察。</p></li></ol><h3 id="如何看待-ECMAScript-新提案-Type-Annotations"><a href="#如何看待-ECMAScript-新提案-Type-Annotations" class="headerlink" title="如何看待 ECMAScript 新提案 - Type Annotations"></a><a href="https://2ality.com/2022/03/type-annotations-first-look.html">如何看待 ECMAScript 新提案 - Type Annotations</a></h3><p>这个月有一个 ECMAScript 的新提案，可以在 JavaScript 中使用 TypeScript 部分类型声明，参见：<a href="https://github.com/tc39/proposal-type-annotations">tc39/proposal-type-annotations</a>。</p><p>此提案一经提出，在中英文社区都引起了不少的轰动，而《<a href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a>》的作者 Dr. Axel Rauschmayer 在这篇文章中提出了一些他的看法。</p><p>先展示一下这个提案的一些使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很标准的 TypeScript 语法，而 JavaScript 将这样处理这些类型声明：</p><ol><li>在运行时，JavaScript 引擎完全忽略它们 - 就好像它们是注释一样。</li><li>在开发时，类型检查器可以静态分析注释并警告开发人员有关潜在问题。</li></ol><p>下面是本文作者的一些看法：</p><ul><li>优点：<ul><li>为类型声明标准化是很好的，并且将使该领域的工具和实验更容易。</li><li>可以在不编译源代码的情况下使用 TypeScript 进行编程（例如）。在开发时只会进行类型检查。这将大大改善静态类型 JavaScript 的开发体验：<ul><li>执行时不需要中间文件。<ul><li>这在 Node 上特别有用 .js 您可以直接运行 TypeScript 文件。</li></ul></li><li>调试时，不需要源映射即可查看原始源代码。</li><li><code>.d.ts</code>文件通常也不需要。</li></ul></li></ul></li><li>缺点：<ul><li>像 TypeScript 这样的静态类型系统是完全可选的 JavaScript 之上的层，不会给 JavaScript 增加任何复杂性。</li><li>该提案为该语言添加了许多新的语法。即使引擎忽略它，它们仍然必须能够解析它。升级  JavaScript 工具需要时间和精力。</li><li>如果在将库部署到 npm 之前没有将 TypeScript（等）编译为 JavaScript，那么对于不喜欢 TypeScript 的人来说，浏览 TypeScript 开发人员编写的源代码将变得不那么愉快。<ul><li>为了帮助解决这个问题，从文件中删除所有类型批注可能成为文本编辑器支持的操作。</li></ul></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>我个人非常喜欢这个提案，也很希望这个提案能够最终进入到 ECMAScript 的标准中。但这背后仍会有无数的坑，比如 <code> add&lt;number&gt;(4,5)</code> 它也是合法的 JavaScript 代码，至于如何解决这类与现有代码冲突的问题，就让我们拭目以待吧。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.patterns.dev/">改进构建 Web 应用程序的方式</a>：一本关于设计模式和组件模式的免费书籍，用于使用原生 JavaScript 和 React 构建强大的 Web 应用程序。</li></ul><ul><li><p><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">Git 飞行规则(Flight Rules)</a>：这是一篇给宇航员（这里就是指使用 Git 的程序员们）的指南，用来指导问题出现后的应对之法。</p></li><li><p><a href="https://devhints.io/">里科的备忘单</a>：一些语言、框架、工具的 TL;DR，帮助你快速了解某一门技术。</p></li></ul><ul><li><a href="https://refactoringguru.cn/design-patterns">常用的设计模式有哪些？</a>：图文并茂地列出了几乎所有的设计模式，帮助你理解设计模式。</li></ul><ul><li><a href="https://developer-advocacy.com/">开发人员的宣传手册</a>：本手册引导你成为任何产品或公司的布道者。</li></ul><ul><li><a href="https://www.accessguide.io/">访问指南</a>：这是对可访问性的友好介绍！列出了很多有用的知识帮助你提高网站的可访问性。</li></ul><ul><li><a href="https://tldp.org/LDP/abs/html/index.html">高级 Bash 脚本编写指南</a>：帮助你学习 Bash 脚本，而且它没有任何版权，可用于课堂、知识分享会。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-07.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第6期：网络没有版本号</title>
      <link>https://4ark.me/post/weekly-06.html</link>
      <guid>https://4ark.me/post/weekly-06.html</guid>
      <pubDate>Mon, 28 Mar 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;分享文章&quot;&gt;&lt;a href=&quot;#分享文章&quot; class=&quot;headerlink&quot; title=&quot;分享文章&quot;&gt;&lt;/a&gt;分享文章&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="网络没有版本号"><a href="#网络没有版本号" class="headerlink" title="网络没有版本号"></a><a href="https://hiddedevries.nl/en/blog/2022-01-03-the-web-doesnt-have-version-numbers">网络没有版本号</a></h3><p>在过去一年时间里，我们经常听到 WEB3 ，以及相关的术语：如区块链、加密、NTF 等，让不少 WEB 开发者认为这项技术是未来的趋势，于是每个开发者都跃跃欲试，但本文作者认为我们应该对这个充满误导性的术语 「WEB3」持谨慎态度，因为网络并没有版本号，更没有某个权威的机构会定期更新网络的版本。</p><p>希望 WEB3 及其相关术语不会成为 WEB 开发者的简历上必备的流行词，对于大部分 WEB 开发者而言，该领域的专业知识是不必要的。</p><h3 id="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"><a href="#您在软件开发方面的经验水平将使您产生截然不同的观点和意见" class="headerlink" title="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"></a><a href="https://www.kevinhooke.com/2022/03/22/your-experience-level-in-software-development-will-lead-you-to-wildly-different-points-of-view-and-opinions/">您在软件开发方面的经验水平将使您产生截然不同的观点和意见</a></h3><p>假设你是一个初级开发者，你为了实现某个功能，而刚好有一个库/框架能够满足你的需求，所以你希望能够把这个库/框架加入到项目中，但比你更有经验的同事拒绝了这个建议，他认为没必要仅仅为了实现一个功能而添加一个库/框架。</p><p>你可能会认为这是一个短视的看法，他们不应该被困在什么都自己重新造轮子的旧观念上。</p><p>但也许他是这样思考问题的：</p><ol><li>添加一个库，意味着增加系统的复杂度、意味着更多的风险。</li><li>需要及时跟踪这个库的安全漏洞、并在 breaking change 时更新现有的代码。</li><li>这个库的安全性如何？是否会有意外的情况发生？</li><li>添加这个库的成本和风险？成本是否会比自己开发更低？</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>对于任何一个商业项目而言，不应该也不可能完全脱离开源社区的框架、类库，我们确实不可能所有事情都重新造轮子，开源类库的健壮性肯定比自己实现要强，但这也不意味着我们可以盲目地使用开源类库，即便要使用类库，也可能会面临多个不同选择，我们应该从生态社区、维护积极性、安全性等多方面进行考察和对比，最终选择出适合的方案。</p><h3 id="当你在构建产品时，你应该听取谁的意见？"><a href="#当你在构建产品时，你应该听取谁的意见？" class="headerlink" title="当你在构建产品时，你应该听取谁的意见？"></a><a href="https://justinjackson.ca/opinion">当你在构建产品时，你应该听取谁的意见？</a></h3><aside>💬 "在我使用苹果产品的这么多年里，我从来没有退过一个产品。直到现在。上个月我购买了带 Touch Bar 的新 MacBook Pro。真让人失望。这是第一个让我的工作效率下降的苹果设备。该公司已经与史蒂夫-乔布斯关于简单、优雅机器的愿景脱节。- 迈克尔-凯特</aside><p>人们根据自己的背景来重视不同的东西。就比如对于笔记本电脑，不同的群体需要不同的功能：</p><ul><li><strong>学生们</strong>想要一台价格实惠且重量轻的笔记本电脑（因为他们会把它带到课堂上）。</li><li><strong>程序员</strong>想要一台具有高分辨率屏幕，大量内存和全尺寸键盘的笔记本电脑。</li><li><strong>游戏玩家</strong>想要一个具有超强 CPU和 GPU 的电脑，他们也不介意笔记本电脑是否笨重。</li></ul><p>本文作者提出我们在构建产品时，最应该听从谁的意见，以及如何听从：</p><ul><li><strong>只接受为您的产品付费的人的产品反馈</strong>，很多人可能不同意这个观点，但是请看看 Feedbook 和谷歌，我们中的许多人都在每天使用它，但是 Facebook 和谷歌似乎不太关心我们的隐私，并在未经我们同意的情况下分享我们的信息。为什么？<strong>因为他们效忠的是广告商</strong>。</li></ul><h3 id="在浏览器-devtools-中打印图片"><a href="#在浏览器-devtools-中打印图片" class="headerlink" title="在浏览器 devtools 中打印图片"></a><a href="https://www.bram.us/2022/02/13/log-images-to-the-devtools-console-with-console-image/">在浏览器 devtools 中打印图片</a></h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203282335113.png" alt="Untitled"></p><p>我们使用以下代码在 devtools 中利用 <code>console.log</code> 输出图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBox</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">string</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&quot;font-size: 1px; padding: &quot;</span> + <span class="built_in">Math</span>.floor(height/<span class="number">2</span>) + <span class="string">&quot;px &quot;</span> + <span class="built_in">Math</span>.floor(width/<span class="number">2</span>) + <span class="string">&quot;px; line-height: &quot;</span> + height + <span class="string">&quot;px;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.image = <span class="function"><span class="keyword">function</span>(<span class="params">url, scale</span>) </span>&#123;</span><br><span class="line">    scale = scale || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dim = getBox(<span class="built_in">this</span>.width * scale, <span class="built_in">this</span>.height * scale);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c&quot;</span> + dim.string, dim.style + <span class="string">&quot;background: url(&quot;</span> + url + <span class="string">&quot;); background-size: &quot;</span> + (<span class="built_in">this</span>.width * scale) + <span class="string">&quot;px &quot;</span> + (<span class="built_in">this</span>.height * scale) + <span class="string">&quot;px; color: transparent;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接使用这个库：<a href="https://github.com/adriancooney/console.image">https://github.com/adriancooney/console.image</a></p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://myxml.in/cors-tester.html">CORS Tester</a>：跨域对于前后端来说都是一个不可逾越的知识点，在实际项目开发中也必然会遇到各种各样的跨域问题，可以使用这个网站在线体验跨域的请求。</p></li><li><p><a href="https://effective-shell.com/">Effective Shell</a>：一本学习 Shell 的在线书籍，适合任何一个想要入门 Shell 的同学。</p></li><li><p><a href="https://curlconverter.com/">Convert curl commands to code</a>：将 CURL 转换到各编程语言的实例中，当然我们平常都会使用 Postman、PAW 等工具进行转换，不过也总有需要在线转换的时候把？</p></li><li><p><a href="https://exploringjs.com/impatient-js/index.html">JavaScript for impatient programmers (ES2022 edition)</a>：在 JavaScript 世界中有很多非常经典的书籍，如 《JavaScript 权威指南》、《JavaScript 高级程序设计》、《你不知道的 JavaScript》 等，但我推荐这本更加现代化的书，包含了最新的 ES2022 新特性。</p></li><li><p><a href="https://charm.sh/">Charm</a>：在 CLI 构建你的图形界面，真的很漂亮！</p></li><li><p><a href="https://jless.io/">jless</a>：一个更好地显示 JSON 的 CLI 工具，推荐使用！</p></li><li><p><a href="https://devtoys.app/">DevToys</a>：堪称开发者的瑞士军刀，提供了比如文件转换（JSON &lt;&gt; YAML ）、编码解码、格式化（支持 JSON、SQL、XML）、哈希生成、UUID 生成、图片压缩多种功能。</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-06.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第5期：拖延症</title>
      <link>https://4ark.me/post/weekly-05.html</link>
      <guid>https://4ark.me/post/weekly-05.html</guid>
      <pubDate>Wed, 23 Mar 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;拖延症&quot;&gt;&lt;a href=&quot;#拖延症&quot; class=&quot;headerlink&quot; title=&quot;拖延症&quot;&gt;&lt;/a&gt;拖延症&lt;/h2&gt;&lt;p&gt;本期周刊延迟了两天，今晚抽空补上，内容会相对比较少。&lt;/p&gt;
&lt;p&gt;反思一下，一个原因是这周比较忙，但主要还是因为自己的拖延症，希望</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><p>本期周刊延迟了两天，今晚抽空补上，内容会相对比较少。</p><p>反思一下，一个原因是这周比较忙，但主要还是因为自己的拖延症，希望以后能够克服这个问题。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="Exhausting-Exhaustive-Testing"><a href="#Exhausting-Exhaustive-Testing" class="headerlink" title="Exhausting Exhaustive Testing"></a><a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">Exhausting Exhaustive Testing</a></h3><p><em>原文地址：<a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">《Exhausting Exhaustive Testing》 | openmymind</a></em></p><p>非常短的一篇文章，但作者的观点让我醒醐灌顶：编写有效的测试具有挑战性，每个测试用例都需要考虑最大化其价值。</p><p>举一个例子，比如我们有这么一个软删除用户的函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deleteUser(id) (bool, error) &#123;</span><br><span class="line">  tag, <span class="attr">err</span> := conn.Exec(<span class="string">`</span></span><br><span class="line"><span class="string">    update users</span></span><br><span class="line"><span class="string">    set status = &#x27;deleted&#x27;</span></span><br><span class="line"><span class="string">    where id = $1</span></span><br><span class="line"><span class="string">  `</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tag.RowsAffected() == <span class="number">1</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会如何测试这个函数？是不是这样：</p><ol><li>插入一个新的用户</li><li>调用这个函数</li><li>判断这个新用户是否被删除</li></ol><p>这样测试没有错，但是我们忽略了一点：如果这个函数把所有用户都删除了呢？是不是也能通过测试？</p><p>所以正确的测试方式是：插入两个用户，删除第一个用户，确保第二个用户没有被删除。</p><p>还有另外一个例子，假如我们要获取用户列表，SQL 是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name</span><br><span class="line"><span class="keyword">from</span> users</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> customer_id <span class="operator">=</span> $<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><p>通常我们可能是这样测试的：</p><ol><li>插入一个新用户，设置 customer_id</li><li>调用函数</li><li>判断是否返回这个新用户</li></ol><p>但作者认为至少需要插入四个新用户才能进行这个测试：</p><ol><li>四个用户，其中一个被删除的 A、一个 customer_id 不符合的 B，剩余两个才符合条件</li><li>确保没有返回 A 和 B</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>诚然我们都认同测试的重要性，但是如何编写测试是一门非常高深的学问，只是编写测试用例的时候只是流于表面的，那么其价值是非常低的，甚至是浪费时间的。</p><h3 id="百度腾讯阿里真的是高科技企业吗？"><a href="#百度腾讯阿里真的是高科技企业吗？" class="headerlink" title="百度腾讯阿里真的是高科技企业吗？"></a><a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">百度腾讯阿里真的是高科技企业吗？</a></h3><p><em>原文地址：<a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">《百度腾讯阿里真的是高科技企业吗？》 | 马工</a></em></p><p>那么，这些潜力人才去了BAT，在干什么呢？腾讯的公众号文章《搞了运维开发这么多年，原来 Ping 还能这么玩儿！》揭示了部分真相：一个北大本科毕业生在腾讯研究一个1981年的协议ICMP，而这个协议因为不安全已经被大多数美国同行比如AWS给默认禁掉了。说句不客气的话，ICMP协议就是IT行业的回字的四种写法，让北大毕业生去研究ICMP协议，就是把他们变成孔乙己。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://oktools.net/aes">AES加密/解密</a>：一个在线 AES 加密/解密的工具。</p></li><li><p><a href="https://plantuml-editor.kkeisuke.dev/">PlantUML Editor</a>：一个在线画 PlantUML 的工具。</p></li><li><p><a href="https://getoss.art/">OssArt</a>：一个非常有意思的开源项目，它可以帮你打印出最早从 2010 年开始的 GitHub Activity 贡献图，让你的成就感满满。</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-05.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hg hooks 实践历程</title>
      <link>https://4ark.me/post/hg-hooks.html</link>
      <guid>https://4ark.me/post/hg-hooks.html</guid>
      <pubDate>Thu, 17 Mar 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;故事的开始&quot;&gt;&lt;a href=&quot;#故事的开始&quot; class=&quot;headerlink&quot; title=&quot;故事的开始&quot;&gt;&lt;/a&gt;故事的开始&lt;/h2&gt;&lt;blockquote&gt;
&lt;aside&gt; 💬 提交代码前记得 lint&lt;/aside&gt;
&lt;aside&gt; 💬 又有人没跑</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><blockquote><aside> 💬 提交代码前记得 lint</aside><aside> 💬 又有人没跑测试就提交代码</aside><aside> 💬 project-config 有改动，麻烦 yarn setup 一下</aside></blockquote><p>相信使用 Hg 的同学们已经非常熟悉上面这几句话了，我们每次在提交或者拉取代码时总需要手动执行某些命令，实在繁琐。</p><p>但现在已经 2022 年了，难道就没有更好的解决方法吗？</p><p>有的，我们知道，在 Git 有个东西叫做 hooks（钩子），可以在特定事件发生之前或之后执行特定动作。</p><p>同样的，Hg 也有 <a href="https://www.mercurial-scm.org/wiki/hook">hooks</a>，不过并不像 Git 一样生态蓬勃发展，也没有太多现有的开源工具可供大家使用。</p><p>本文就来介绍一下我们从 0 到 1 的 Hg hooks 实践过程，同时也希望能够起到抛砖引玉的作用。</p><h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在没有引入 Hg hooks 之前，我们常常会面对几种情况：</p><ol><li>有同学在提交代码时忘记执行 <code>yarn lint</code>、<code>yarn test</code></li><li>修改了 <code>project-config</code> 的常量，却忘记通知大家，或者有人错过了这条信息。</li></ol><p>这都有可能会导致其他小伙伴拉取代码后，发现页面上的某个功能突然异常，花费一段时间排查才发现原来是没有执行 <code>yarn setup</code>。</p><p>可能有部分同学会想到，那我自定义一个命令在提交或者拉取代码时自动做这件事不就好了吗？</p><p>比如这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn lint &amp;&amp; hg commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hg pull --update &amp;&amp; yarn setup</span><br></pre></td></tr></table></figure><p>这样也不是不行，但是会存在一些问题：</p><ol><li>由于每个人的拉取代码的命令不一样，如果项目开发流程发生变化，则每个人都需要同步修改</li><li>有些同学习惯使用图形化界面，比如 SourceTree、vscode-hg 等，则无法自定义操作命令</li></ol><p>因此，我们另辟蹊径，寻找更好的解决方案。</p><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>我们最主要想解决的问题就是：</p><ol><li>在提交代码前自动执行 <code>yarn lint</code>、<code>yarn test</code>，不通过则直接终止提交。</li><li>在拉取代码后，检测到如果 project-config 目录发生改动，则自动执行 <code>yarn setup</code>。</li><li>还有更多：<ol><li>检查 commit message 规范</li><li>统一代码的格式化风格</li></ol></li></ol><p>这些都可以通过 Hg hooks 解决，所以开始之前，我们先对 Hg hooks 做一个简单的认识。</p><h3 id="Hg-hooks-介绍"><a href="#Hg-hooks-介绍" class="headerlink" title="Hg hooks 介绍"></a>Hg hooks 介绍</h3><p>Hg hooks 能做什么，这次再介绍一遍：<strong>它可以在特定事件发生之前或之后执行特定动作。</strong></p><p>特定事件，指的就是我们在对 Hg 仓库进行操作时的一些钩子，比如提交前（precommit）、提交后（commit），可以在这里查看全部 hooks 列表：<a href="https://www.mercurial-scm.org/repo/hg/help/hgrc">hooks</a>。</p><p>下面介绍一下如何使用 hook，我们可以通过以下两个文件进行配置：</p><ol><li><code>~/.hgrc</code>：全局的，将对所有 hg 仓库起作用。</li><li> 项目根目录的 <code>.hg/hgrc</code> ：仅对当前仓库起作用。</li></ol><p>比如我们想要实现一个简单的需求：在提交代码前进行 <code>yarn lint</code>。</p><p>首先编辑 <code>.hg/hgrc</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hooks</span>]</span><br><span class="line"><span class="string">precommit</span> <span class="string">=</span> <span class="string">./bin/hooks/precommit.sh</span> <span class="comment"># 这个路径是相对于项目根目录的</span></span><br></pre></td></tr></table></figure><p>然后编写脚本 <code>bin/hooks/precommit.sh</code>（也可以使用 python）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">yarn lint</span><br><span class="line"></span><br><span class="line"><span class="comment"># lint 没有通过直接退出</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这里需要特别指出，之所以需要重新声明 <code>PATH</code> 变量：</p><ol><li>hooks 脚本的运行环境取决于同学提交代码的地方，比如通过 SourceTree 提交，由于环境不一样，就可能会出现 <code>yarn: command not found</code> 的报错，参见：<a href="https://stackoverflow.com/questions/22883197/git-command-not-found-in-the-custom-action-for-sourcetree">‘Git Command Not found’ in the custom action for SourceTree - Stack Overflow</a>。</li><li>每个同学安装 hg 的方式可能不一样，有通过 brew、pip、甚至自己手动编译的，它们的可执行文件路径不一样。<ul><li>可以通过 <code>which hg</code> 查看这个命令的可执行文件路径。</li></ul></li></ol><p>这样，一个简单的 hook 就配置完成了，这时候提交代码就会触发 <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;ci: precommit hooks&quot;</span></span><br><span class="line"></span><br><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br></pre></td></tr></table></figure><p>当 hook 脚本的 exit code 不为 0 的时候，则会终止当前的 Hg 操作，对于某些具有事务性的 hook（e.g. pretxncommit），还会自动进行回滚。</p><p>可以通过以下链接对 Hg hooks 进行更深入地学习：</p><ul><li><a href="https://www.mercurial-scm.org/wiki/hookExamples">hookExamples</a></li><li><a href="https://www.mercurial-scm.org/wiki/Usefulhooks">Usefulhooks</a></li><li><a href="http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html">Chapter 10. Handling repository events with hooks (red-bean.com)</a></li></ul><h3 id="Hg-hooks-实践"><a href="#Hg-hooks-实践" class="headerlink" title="Hg hooks 实践"></a>Hg hooks 实践</h3><h4 id="提交代码前（precommit）"><a href="#提交代码前（precommit）" class="headerlink" title="提交代码前（precommit）"></a>提交代码前（precommit）</h4><p>这里需要用到的 hook 是 precommit，它的运行时机在提交之前，exit code 非 0 时将终止提交。</p><p> <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要 lint 的项目</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram&#x27;</span></span><br><span class="line">    <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    <span class="string">&#x27;core&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否修改该项目，无则跳过 lint</span></span><br><span class="line">    has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;app&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$app</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">    yarn &amp;&amp; yarn lint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lint 是否报错，是则直接退出脚本</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对当前修改或新增的文件批量进行 prettier 格式化</span></span><br><span class="line">hg status | grep -E <span class="string">&quot;^(M|A).*.(js|json|wxss)$&quot;</span> | sed <span class="string">&#x27;s|^M||g; s|^A||g&#x27;</span> | xargs ./node_modules/.bin/prettier --write &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>比较浅显易懂，由于是 Monorepo 架构，所以仅针对当前改动的子项目执行 <code>yarn lint</code> ，当 lint 不通过时终止提交；然后仅对当前变更的文件做 prettier 格式化，并且忽略这行命令的输出和错误。</p><p>ps：其实这里的 prettier 机制有点问题，原本的目的是仅格式化当前提交的文件，但 Hg 没有 staging area 的概念，故只能粗暴处理，如果有更好的解决方法欢迎指教。</p><ul><li>hg commit 可以只提交指定的部分文件，所以是有 changed files 和 commited files 两个概念，但是没有找到办法获取 commited files，参见：<a href="https://stackoverflow.com/questions/24565802/mercurial-pre-commit-hook-how-to-tell-apart-changed-and-committed-files">Mercurial pre-commit hook: How to tell apart changed and committed files - Stack Overflow</a></li><li>另一种思路：使用 pretxncommit 钩子，就可通过 $Hg_NODE 变量拿到当前 commit 的信息，但缺点是 pretxncommit 阶段将不能再对文件进行改动，则格式化后需要重新提交一遍。</li></ul><p>随着版本迭代，在 precommit 钩子中增加了检测 utils、test 目录改动则自动执行单元测试 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改以下文件需要执行单元测试</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram/utils miniprogram/test&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    dir=(<span class="variable">$app</span>)</span><br><span class="line">    pass=0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;dir[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 判断是否修改工具方法、测试用例，无则跳过</span></span><br><span class="line">        has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;d&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 同一个项目只执行一次</span></span><br><span class="line">        [ <span class="variable">$pass</span> -eq 1 ] &amp;&amp; <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$d</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line">        yarn &amp;&amp; yarn <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># test 是否报错，是则直接退出脚本</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        pass=1</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> -</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="拉取代码后（changegroup）"><a href="#拉取代码后（changegroup）" class="headerlink" title="拉取代码后（changegroup）"></a>拉取代码后（changegroup）</h4><p>主要想解决的问题是：当拉取代码后，检测到 project-config 目录发生变更，则执行 <code>yarn setup</code>。</p><p>首先要解决第一点，如何获取从远端拉取代码所改动的文件？有下面几种方法：</p><ol><li><p><a href="https://backend.bolt80.com/hgdoc/hg-incoming.html">hg incoming</a>：显示远端中的新 commit</p><ul><li>缺点：该方法只是显示新的 commit，后面仍需要再进行一次 pull 才能将新 commit 拉取下来，导致拉取代码时间翻倍。</li></ul></li><li><p><a href="https://backend.bolt80.com/hgdoc/hg-pull.html">hg pull</a>：在拉取代码之后、进行 update 或 rebase 之前，通过 <code>hg log</code> 对比本地 head 和 远端拉取下来的 head。</p></li><li><p>hooks：</p><ol><li>update：工作目录发生改变时，所以只要进行提交、储藏、切换分支都会触发，<strong>不考虑</strong>。</li><li>incoming：每一个新的 commit 被传入时都会触发一次，过于频繁，<strong>不考虑</strong>。</li><li>changegroup：在 push、pull、unbundle 时都会触发，但多个 commit 被传入也只会触发一次，<strong>可考虑</strong>。</li><li>还有一些不太满足的 hooks 不一一介绍了。</li></ol></li></ol><p>在一开始，我们曾尝试使用第二种方法解决该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    no_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改动文件</span></span><br><span class="line">    regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本次 pull 变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">    has_change=$(hg <span class="built_in">log</span> --verbose -r .:tip | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参考 hg update --rebase 的实现，先尝试 rebase，如果不需要 rebase，则直接 update</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/35327163/what-is-the-rebase-command-used-in-hg-pull-rebase</span></span><br><span class="line">    <span class="comment"># @link：https://www.mercurial-scm.org/repo/hg/file/tip/hgext/rebase.py#l2172</span></span><br><span class="line">    has_rebase=$(hg rebase -b . -d <span class="string">&#x27;last(branch(.))&#x27;</span> | grep <span class="string">&quot;nothing to rebase&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_rebase</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg update</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        yarn setup</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$no_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以很好地工作，它可以满足：</p><ul><li>拉取代码时自动储藏、恢复本地改动</li><li>当两端都同时修改 project-config 时，可以 update 或者 rebase 后再统一 <code>yarn setup</code></li></ul><p>后来发现使用 changegroup  hook 配合 <code>hg log</code> 一样可以解决问题，于是就有了 <code>changegroup.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改动文件</span></span><br><span class="line">regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本次变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line"><span class="comment"># @see：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">has_change=$(hg <span class="built_in">log</span> -v -r <span class="variable">$Hg_NODE</span>: | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> $(hg root) || <span class="built_in">exit</span> 1</span><br><span class="line">    yarn setup</span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p> 因此 <code>hgpl</code> 可以精简成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    has_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull --rebase</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-message-检查（pretxncommit）"><a href="#commit-message-检查（pretxncommit）" class="headerlink" title="commit message 检查（pretxncommit）"></a>commit message 检查（pretxncommit）</h4><p>使用 pretxncommit 钩子可对当前提交信息进行检查，如检查 commit message：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">shelve_user=<span class="string">&quot;shelve@localhost&quot;</span></span><br><span class="line"></span><br><span class="line">commit_user=$(hg tip --template &#123;user&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 hg shelve 也会触发 pretxncommit 钩子，所以要进行忽略</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$commit_user</span>&quot;</span> == <span class="string">&quot;<span class="variable">$shelve_user</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">commit_message=$(hg tip --template &#123;desc&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[msg] <span class="variable">$commit_message</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$commit_message</span>&quot;</span> | ./node_modules/.bin/commitlint</span><br></pre></td></tr></table></figure><h2 id="铁器时代？"><a href="#铁器时代？" class="headerlink" title="铁器时代？"></a>铁器时代？</h2><p>这个标题之所以打上一个问号，是因为该方案仍在 POC 阶段，尚未落地实施，但也可作为一个对未来的展望。</p><p>迄今为止，我们的 Hg hooks 已经能够满足大部分场景了，那还存在些什么问题呢？</p><p>相信不少同学已经发现这样操作会存在有一个很明显的问题，那就是：hooks 配置如何同步？</p><p>我们知道 <code>.hg</code> 目录是不会加入版本控制的，这是非常合理且必要的，因为 hooks 本身是一些权限极高的可执行脚本，所以出于安全考虑（你也不想你 clone 一个仓库后，它会自动执行某些你不想执行的命令），<strong>因此是不会有任何一个 VSC 会将 hooks 加入版本控制的。</strong></p><p>可是这就会导致：</p><ol><li>假如项目新增了一个 hook，需要通知项目成员同步修改本地的 hooks 配置。</li><li>新成员加入项目，需要手动配置 hooks。</li></ol><p>如果这个问题不能得到解决，那归根到底还是无法绕过通知项目成员手动操作的过程。</p><p>所幸，以上问题在 Git 中同样存在，并且已经有很多非常成熟的方案，如： <a href="https://github.com/typicode/husky">huksy</a>、<a href="https://pre-commit.com/">pre-commit</a> 。</p><p>那有没有人在 Hg 生态上解决这个问题呢？粗略找到了两个：</p><ol><li><a href="https://github.com/TobiasTimm/husky-hg">husky-hg</a></li><li><a href="https://github.com/theylom/tdog-husky-hg">tdog-husky-hg</a>（前者的 fork</li></ol><p>都是基于 husky <a href="https://github.com/tobiastimm/husky-hg/commit/fcd100f4f1a7bdf04c05f51ddd80af9f87687ddc#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519R2">v0.14.3</a> 改造的，最后提交时间都在三年前（2019），然而 husky 现在已经迭代到 <a href="https://github.com/typicode/husky/releases/tag/v7.0.4">v7</a> 版本了，这 3 年间经过无数迭代，使用方式和实现原理都发生翻天覆地的变化，于是我们决定基于 husky v7 自行改造。</p><p>但是在此之前，我们先了解一下 Git 如何配置 hooks：</p><ol><li>在以前的 Git 版本中，如果要配置一个 hooks 则需要在 <code>.git/hooks</code> 目录新增一个 hook 同名的可执行文件，并且出于前面说的安全考虑， <code>.git</code>  目录是不会被加入版本控制的，<strong>因此也存在上面所说的问题</strong>。</li><li>在 Git v2.9 以后，支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，项目成员只需要在第一次配置 core.hooksPath 即可，后续增删 hooks 都可直接使用。</li></ol><p>因为 Git 支持 core.hooksPath ，所以 husky 直接采用了新的实现原理重构：</p><ol><li><p>在 huksy v4 的时候，由于 Git hooks 目录无法被加入版本控制，它们是这样解决这个问题的：</p><ol><li>在初始化的时候就在 <code>.git/hooks</code> 目录预先创建所有的 hooks 可执行文件，然后在 hooks 文件中执行定义在 <code>package.json</code> 中的 hooks 命令。</li><li> 这样很显然可以解决 hooks 无法同步的问题，但是这个实现原理也被不少人诟病，见 <a href="https://github.com/typicode/husky/issues/260">#260</a> 。</li></ol></li><li><p>由于 Git v2.9 的升级，在 husky v7 中使用了新的实现方式：</p><ol><li>将 hooks 可执行文件存放在一个可以被进行版本控制的目录（默认是 <code>.husky</code>），然后初始化的时候只需要配置  core.hooksPath 即可。</li></ol></li></ol><p>显然，v7 的实现方式更加方便快捷了，除此之外，它们的使用方式也有很大的不同：</p><ol><li>在 v4 中，通过在 <code>package.json</code>  中配置 <code>husky</code> 字段来定义 hooks。</li><li>在 v7 中，<strong>它不再仅限于 Node.js 项目</strong>，可以直接通过 CLI 的方式进行配置，参见：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</li></ol><p>在深入了解背后的实现原理后，我们得出了结论：</p><ol><li>v4 版本的代码<strong>有较多历史包袱，不利于改造，故基于 v7 版本修改</strong>。</li><li>但 v7 版本的实现方式对 Hg 并不完全适用，所以需要继续沿用 v4 的部分实现方式，所以这样设计：<ol><li>将 hooks 脚本存放在可被版本控制的 <code>.husky</code> 目录</li><li>但不通过预注册所有的 hooks 的方式，而是采用按需配置，初始化时根据 <code>.husky</code> 的 hooks 可执行文件列表注入 hooks 配置。<ol><li>比如在 Node.js 项目中可以通过 npm 的 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#prepare-and-prepublish">prepare</a> 钩子来自动初始化。</li></ol></li></ol></li><li>因此，使用方式与 husky <a href="https://typicode.github.io/husky/">文档</a> 中基本一致。<ol><li><code>husky install</code>、<code>husky add .husky/pre-commit</code></li></ol></li></ol><p>以上的心路历程、改造进展可以通过这个 <a href="https://github.com/gd4Ark/husky/pull/1">PR</a> 查看，感兴趣的同学可自行尝试：</p><ol><li>clone 项目，安装依赖，执行 npm link。</li><li>参考  husky <a href="https://typicode.github.io/husky/">文档</a> 进行使用。</li></ol><h2 id="背后的一些二三事"><a href="#背后的一些二三事" class="headerlink" title="背后的一些二三事"></a>背后的一些二三事</h2><p>最后分享一些我们在实践 Hg hooks 时的小插曲。</p><h3 id="一个隐藏字符引发的前端事故"><a href="#一个隐藏字符引发的前端事故" class="headerlink" title="一个隐藏字符引发的前端事故"></a>一个隐藏字符引发的前端事故</h3><p>有一天下午，在群里收到这么一个反馈：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191549957.jpg"  alt="2471647676117_.pic" style="margin-left: 0;" /><p>点开大图一看，好家伙！赫然一个「口」字就这么明目张胆地贴在页面的左下角，看它「浓眉大眼」的。</p><p>到底是哪里出了问题呢？</p><p>仔细看清楚，才发现它其实不是一个「口」字，而是「□」，学名叫做 <a href="https://zh.wikipedia.org/zh-hans/%E8%99%9A%E7%BC%BA%E5%8F%B7">虚缺号</a>，通俗地讲就是一个特殊字符。</p><p>于是打开对应的代码文件，果然一个红底白色 BS 字符引入眼帘：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204042021847.png"></p><h4 id="这是-VSCode-的锅？"><a href="#这是-VSCode-的锅？" class="headerlink" title="这是 VSCode 的锅？"></a>这是 VSCode 的锅？</h4><p>在网上有一番搜寻后，发现早就已经有不少人遇到过这个问题：</p><ul><li><a href="https://github.com/wangduanduan/wangduanduan.github.io/issues/158">vscode控制字符引起的问题以及解决思路</a></li><li><a href="https://jiangxiaokun.com/css/2018/11/15/ghost_chars/">隐藏字符引发的血案</a></li></ul><p>看下他们提供的复现过程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191703719.gif" alt="hmmm"></p><p>直接说下这个 Bug 的结论：</p><ol><li>VSCode 开启 webview 的情况下，使用中文输入法时按下退格键，就会导致出现退格符。</li><li>VSCode 底层是 Electron，Electron 底层用的 chromium，这个 BUG 是 chromium 的。</li><li>该 BUG 已经在 VSCode v1.4.0 得到修复，参见这个 <a href="https://github.com/microsoft/vscode/issues/37114#issuecomment-544236959">issue</a>。</li></ol><p>但既然该问题在 2019 年已经修复，那为什么在 2022 年的今天还会出现这个退格符呢？</p><p>由于已经复现不了，根源追求也就只能不了了之，但影响又如此之大，所以我们应该怎么去规避它呢？</p><h4 id="规避方案"><a href="#规避方案" class="headerlink" title="规避方案"></a>规避方案</h4><h5 id="利用-VSCode-扩展自动删除"><a href="#利用-VSCode-扩展自动删除" class="headerlink" title="利用 VSCode 扩展自动删除"></a>利用 VSCode 扩展自动删除</h5><p>有一个 VSCode 扩展 <a href="https://github.com/satokaz/vscode-bs-ctrlchar-remover">Remove backspace control character</a> 专门用于解决此类问题，安装后我们只需要在 setting.json 添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[wxml]&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;satokaz.vscode-bs-ctrlchar-remover&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可在保存代码的时候自动移除这些特殊的隐藏字符。</p><p>实现方式主要是通过正则去匹配这类隐藏字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm</span><br></pre></td></tr></table></figure><p>在这里查看所有字符的介绍：<a href="https://www.techonthenet.com/unicode/chart.php">Unicode</a>，本文所出现的 BS 正是 [\u0008]，也就是退格符。</p><h5 id="提交代码前自动删除"><a href="#提交代码前自动删除" class="headerlink" title="提交代码前自动删除"></a>提交代码前自动删除</h5><p>更好的方式是：我们可以在 precommit 钩子自动做这件事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.wxml&quot;</span> -<span class="built_in">exec</span> perl -i -p -e <span class="string">&quot;s/[\x08]//g&quot;</span> &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行命令的 time total</span></span><br><span class="line">0.10s user 0.80s system 93% cpu 0.953 total</span><br></pre></td></tr></table></figure><h3 id="让-vscode-hg-提交代码时显示-ESLint-报错的规则"><a href="#让-vscode-hg-提交代码时显示-ESLint-报错的规则" class="headerlink" title="让 vscode-hg 提交代码时显示 ESLint 报错的规则"></a>让 vscode-hg 提交代码时显示 ESLint 报错的规则</h3><p>起因是某位同学反映在 vscode-hg 提交代码的时候，无法显示 ESLint 校验不通过的规则提示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203201415448.png" alt="image-20220320141520784"></p><p>通常我们提交代码时，如果 yarn lint 不通过，会输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br><span class="line"></span><br><span class="line">/Users/4ark/project/helper/404.js</span><br><span class="line">  9:7  error  <span class="string">&#x27;a&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"></span><br><span class="line">✖ 1 problem (1 error, 0 warnings)</span><br><span class="line"></span><br><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>而 vscode-hg 只输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>不过经测试在 VSCode 中进行 Git 代码提交时并不存在该问题，所以猜测是 vscode-hg 这个扩展的原因。</p><p>于是抱着怀疑的态度看一下源码，发现果然如此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hg.ts#L620</span></span><br><span class="line"><span class="keyword">if</span> (options.logErrors !== <span class="literal">false</span> &amp;&amp; result.stderr) &#123;</span><br><span class="line">    <span class="built_in">this</span>.log(<span class="string">`<span class="subst">$&#123;result.stderr&#125;</span>\n`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只输出了 stderr，但是 ESLint 的规则输出是 stdout。</p><p>于是我们为了更好地使用 Hg hooks，让它支持了输出 ESLint 规则，见 <a href="https://github.com/mrcrowl/vscode-hg/issues/185">#185</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们在实践 Hg hooks 过程的一些经历和心得，未必是最佳解决方案，正如文本开头所说，撰写本文的目的是希望能起到抛砖引玉的作用，与大家一起进一步的深入探讨。</p><p>对于本文的实践思路、代码实现有任何的意见和建议，都请不吝指教。</p><p>最后感谢大家的阅读。</p>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/vcs/">vcs</category>
      
      <category domain="https://4ark.me/tags/hg/">hg</category>
      
      
      <comments>https://4ark.me/post/hg-hooks.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第4期：独立思考</title>
      <link>https://4ark.me/post/weekly-04.html</link>
      <guid>https://4ark.me/post/weekly-04.html</guid>
      <pubDate>Sat, 12 Mar 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;本周做了啥&quot;&gt;&lt;a href=&quot;#本周做了啥&quot; class=&quot;headerlink&quot; title=&quot;本周做了啥&quot;&gt;&lt;/a&gt;本周做了啥&lt;/h2&gt;&lt;p&gt;给日常使用的 &lt;a href=&quot;https://github.com/mrcrowl/vscode-hg&quot;&gt;vsco</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="本周做了啥"><a href="#本周做了啥" class="headerlink" title="本周做了啥"></a>本周做了啥</h2><p>给日常使用的 <a href="https://github.com/mrcrowl/vscode-hg">vscode-hg</a> 扩展提了两个没什么技术含量的 PR，顺便蹭了一个 contributor：</p><ul><li><a href="https://github.com/mrcrowl/vscode-hg/pull/184">docs: typo lineAnnotationEnabled option</a></li><li><a href="https://github.com/mrcrowl/vscode-hg/pull/185">feat: output stdout</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="useMemo-和-useCallback-之间的深入比较"><a href="#useMemo-和-useCallback-之间的深入比较" class="headerlink" title="useMemo 和 useCallback 之间的深入比较"></a><a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">useMemo 和 useCallback 之间的深入比较</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">《A Deep Dive Comparison Between useMemo And useCallback》 | Technical Blog</a></em></p><ul><li>它们的目的：都是通过缓存提高性能，避免组件重复渲染</li><li>相似之处：<ul><li>用法一致：与所有 hooks 一样，只能在组件的顶层调用</li><li>接收的参数一致：第一个为函数，第二个为依赖项</li><li>功能一致：返回缓存过的值，检测到依赖性发生时重新计算并缓存</li></ul></li><li>区别：<ul><li>它们表面上没有真正的区别</li><li>它们的内部实现也基本一致</li><li>使用场景的区别：<code>useCallback</code> 缓存函数，而 <code>useMemo</code> 缓存其它类型</li><li>实现原理的区别：<code>useCallback</code> 是缓存函数本身，而 <code>useMemo</code> 是缓存函数的返回值。</li></ul></li></ul><p>以下是它们的实现方式：</p><ul><li>useCallback</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初级开发人员如何为新团队提供价值"><a href="#初级开发人员如何为新团队提供价值" class="headerlink" title="初级开发人员如何为新团队提供价值"></a><a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">初级开发人员如何为新团队提供价值</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">《How You As a Junior Developer Can Immediately Provide Value When Joining a Team》 | Technical Blog</a></em></p><ul><li><strong>初级开发人员并不意味着不能提供价值：</strong>相反，初级开发人员可以给团队带来很多东西。</li><li><strong>质疑现状：</strong>如果一个团队长期合作，人们会开始接受彼此的缺点，习惯于某种风格和工作方式，也就会陷入舒适区，这可能会使团队停滞不前。所以你需要保持批判性，寻找团队懒惰、坏习惯、效率低下或者可以改进的地方，并且付诸行动去改变现状。</li><li><strong>新鲜血液：</strong>任何一个项目组都不可能每时每刻使用最新的技术、工具，可能会使得团队成员没有动力跟上最先进的技术，陷入一种恶性循环之中。你作为一个团队的新成员，可能你反而会在当前领域了解更多最先进的技术和工具，从而打破团队的恶性循环。</li><li><strong>意识到团队沟通的问题：</strong>长期合作的团队可能面临习惯现有的沟通方式，会自动忽略对方的缺陷，导致缺乏真正的沟通。而你能够意识到这些问题，并帮助团队提高这方面的效率。</li><li><strong>挑战团队现有的知识</strong>：每个团队内部都有一些的解决方案或流程，并且习惯于此，而你可以提出更多潜在的替代方案，帮助团队寻找更优的解决方案。</li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>作为一名初级开发人员可能认为自己只能负责最简单的一部分业务，并没有意识到自己能给团队带来这么多价值，但其实你可以通过你作为一个新成员的位置，去发现你刚加入的团队一些不好的习惯，通过正确的心态和行动去改变现状。</p><h3 id="你的代码不必完美无缺"><a href="#你的代码不必完美无缺" class="headerlink" title="你的代码不必完美无缺"></a><a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">你的代码不必完美无缺</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">《Your Code Doesn’t Have to Be Perfect》 | Technical Blog</a></em></p><p>作者通过一段经历，讲述他在实现某个功能时，由于想要实现最佳的解决方案，一开始就花费了大量的时间去进行完美的设计、抽象和封装，结果一个星期的时间没有任何真正的业务产出。</p><p>以下是作者一些教训：</p><ul><li><strong>不要从开始就重构：</strong>不需要刚开始就寻找最优的实现方式，这会让你过早地陷入到某个细节当中，把大量的时间花费在无意义的抽象中。</li><li><strong>复制粘贴还不错：</strong>我们应该坚持 DRY（不要重复你自己），但这不应该是起点，而是最终目标。可以在刚开始时通过复制粘贴实现功能，但这不意味着它就是最终上线的代码，而是在这个功能工作之后，再通过重构来提高代码质量。</li><li><strong>真正的重构需要适当的知识：</strong>通过改进现有的代码会使你的重构过程更加高效，因为这时候你已经掌握了更多的信息，可以更好地了解哪些代码是有意义的抽象。</li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>每个开发者都经历过这个阶段，想要一开始就设计好所有的细节、编写最完美的代码，但这是不可能的，所有代码都是经过不断地重构。你的代码不必在一开始就完美无缺，在生产项目中更是如此，毕竟不存在没有 deadline 的项目，只要懂得这个道理，你的工作效率会大大提高。</p><h3 id="关于编写可读代码的最重要的事情"><a href="#关于编写可读代码的最重要的事情" class="headerlink" title="关于编写可读代码的最重要的事情"></a><a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">关于编写可读代码的最重要的事情</a></h3><p>原文地址：<a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">《The Most Important Thing I Learned About Writing Readable Code》</a></p><p>编写代码时最重要的是可读性，一段难以理解的代码，即使你已经知道它的目的，你也很难理解它。所以编写具有可读性的代码是非常必要的。</p><p>已经有非常多的经典书籍在探讨这个话题，例如：</p><ul><li>《代码大全》</li><li>《重构》</li><li>《代码整洁之道》</li></ul><p>本文作者之前也写过几篇关于代码可读性的文章，不过我认为大部分已经是老生常谈了：</p><ul><li><a href="https://blog.logrocket.com/write-more-readable-react-code/">《如何编写更具可读性的 React 代码》</a><ul><li><strong>代码长度：</strong>更短的代码通常更容易阅读，但有时候并非如此。所以要根据场景，代码并不是越短越好。</li><li><strong>代码分组：</strong>将特定上下文的代码组合在一起，使得阅读性更高。React 的自定义组件、Hook 就是做这件事情。</li><li><strong>复杂的 JavaScript 结构：</strong>不是所有人都完全熟悉 JavaScript 的语言特性，如果依赖某些特性的固定或隐式行为，会使某些对 JavaScript 不太熟悉的开发人员难以理解这些代码。作者还特地拿 <code>Array.reduce</code> 来举了个例子，认为使用 <code>Array.reduce</code> 虽然可以让代码更加紧凑，但内部需要跟踪太多细节，如果直接使用 <code>for-loop</code> 会使代码更具有可读性。</li><li><strong>条件运算符 &amp;&amp;：</strong>这种短路的隐式行为没有 if-else 的可读性高。</li><li><strong>一次处理多种情况：</strong>例如在同一个 <code>useEffect</code> 处理多个 deps，会使代码更加混乱。</li><li><strong>变量命名：</strong>计算机两大难题之一，这个命题有点大。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/6-concrete-tips-that-will-make-your-react-pull-requests-easier-to-review/">《6 个技巧使你的 PR 更容易被 Review》</a><ul><li><strong>PR 的用途</strong>：Why、How</li><li><strong>分享视觉变化的屏幕截图</strong>：根据代码变更很难想象视觉的变化，所以展示一个截图可以帮助 Reviewer 更快地知道界面变化。</li><li><strong>列出功能要求</strong>：列出你想要实现的功能预期，否则很难通过代码上下文去预测你的实现是否正确、或者还有更优的解决方案。</li><li><strong>列出新的依赖</strong>：如果新增了依赖，你是如何决定采用哪一个库的。</li><li><strong>避免复杂的代码实现</strong></li><li><strong>提供有关如何 Review 的其他说明</strong>：告诉 Reviewer 从哪里开始 Review。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/this-is-my-10-questions-react-code-reviewing-routine/">《帮助你对 React 代码进行 Review 的 10 个问题》</a><ul><li>代码是否正常工作？</li><li>我明白了发生了什么吗？</li><li>代码是否可读？</li><li>组件或 Hook 是否做得太多？</li><li>这必须是组件或者 Hook 吗？</li><li>这个 API 设计可以简化吗？</li><li>有测试吗？</li><li>测试有意义吗？</li><li>这个功能的辅助功能方面如何？</li><li>是否更新了相应的文档？</li></ul></li></ul><p>但作者认为有一件更重要的事情被忽略了，那就是：<strong>沟通。</strong></p><p>每个人对于「代码是否具有可读性」的理解都不一样，所以日常中经常会出现下面这种对话：</p><ul><li>“你觉得这段代码非常难以阅读，但我认为它很容易。”</li><li>“我不同意，我经常使用这种实现方式，但理解它并没有难度。”</li><li>“使用这种方式实现，而不是你提供的那种方式实现，意味着我们不需要担心 xxx，可以使代码更短。”</li></ul><p>这种回答并非完全没有道理的，但它们都有共同点：<strong>他们之所以不同意使用这种实现会使代码可读性更差，是因为他们觉得自己能够理解这样的代码。</strong></p><p>的确，他们确实非常熟悉这段代码是如何工作的，但他们搞错了一件事：<strong>他们认为我是因为理解不了这段代码，才觉得这段代码难以阅读。</strong></p><p>然而事实并非如此，因为问题的根本在于：<strong>代码的可读性与你无关，而是与其他人有关，准确地说，是与未来接手这段代码的人有关，甚至这个人很可能就是六个月后的自己。</strong></p><p>所以，你要为他们编写具有可读性的代码。</p><h4 id="个人思考-2"><a href="#个人思考-2" class="headerlink" title="个人思考"></a>个人思考</h4><p>首先我需要说明，我并不认同作者提到的「 <code>for-loop</code> 可读性比 <code>Array.reduce</code> 好」这个结论，我认为 <code>Array.reduce</code> 与 <code>forEach</code>、<code>map</code> 这些标准方法并无不同，不是 JavaScript 的糟粕，甚至是精华部分；另外 <code>Array.reduce</code>  真正需要考虑的细节也不多，只要熟悉递归思想，它其实很好理解。</p><p>除此之外的大部分观点我都是非常认同的，特别是本文讲到的「沟通」二字。我曾待过一个团队，当时合并代码前是需要两人交叉 Review 的，也遇到过几次关于「这样实现的可读性好不好」的问题展开讨论，基本都是各执一词，往往这种时候都需要一个第三者来进行判断，由这个人决定采用哪一种实现。</p><p>还记得有一次更离谱，某位同学酷爱使用位运算符，他对此给出的理由是：这样实现会使代码更快。</p><p>首先我并不认同这种说法，因为他没有给出专业的对比分析，即便这是真的，但在我们负责的这种 Web 项目中，这种速度的提升简直是可以忽略不计的，所以我就「可读性」本身这件事与他讨论，结果他开始和我解释这个位运算符是如何工作的，这位同学就犯了上面提到的问题，其实我不是不理解位运算符如何工作，我还曾写过一篇《<a href="https://4ark.me/post/learn-bitwise-operators.html">深入理解按位操作符</a>》的文章，我只是单纯认为不应该在项目中使用位运算符罢了。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.aisixiang.com/">爱思想</a>：华语圈内最具原创性和思想性的公益纯学术网站，有人文社科各领域、人品和作品均有一定高度的学者的大量访谈记录、论文等，可帮助你提高独立思考的能力。</li></ul><ul><li><a href="https://www.allhistory.com/">全历史</a>：在全历史 App 或网站里，你可以按照时间轴、关系图谱、时间地图查看各国，各个历史时期的历史相关内容。</li></ul><ul><li>在信息爆炸的今天，充斥着大量的虚假信息，这里推荐一些事实核查网站帮助你快速辨别信息真伪：<ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-04.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>周刊第3期：持续折腾</title>
      <link>https://4ark.me/post/weekly-03.html</link>
      <guid>https://4ark.me/post/weekly-03.html</guid>
      <pubDate>Sun, 06 Mar 2022 00:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;新文章&quot;&gt;&lt;a href=&quot;#新文章&quot; class=&quot;headerlink&quot; title=&quot;新文章&quot;&gt;&lt;/a&gt;新文章&lt;/h2&gt;&lt;p&gt;之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><p>之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。</p><ul><li>《<a href="https://4ark.me/post/git-tips.html">Git tips</a>》</li><li>《<a href="https://4ark.me/post/hg-tips.html">Hg tips</a>》</li></ul><h2 id="折腾-iTerm2-tmux"><a href="#折腾-iTerm2-tmux" class="headerlink" title="折腾 iTerm2 + tmux"></a>折腾 iTerm2 + tmux</h2><p>很早之前就安装了 tmux，但是苦于一直记不住命令，也就没有坚持用。</p><p>不过其实 iTerm2 已经整合了 tmux，可以将 tmux 的各种命令操作映射到 iTerm2 本身的快捷键操作中，这可以大大降低 tmux 的学习成本，于是花了点时间折腾、以及 iTerm2 的外观调整，整体效果是这样的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203050038886.png?imageMogr2/format/webp"></p><p>主要参考以下这两篇文章：</p><ul><li><a href="https://toutiao.io/posts/q86tnu/preview">iTerm2 整合 Tmux 利器</a></li><li><a href="https://haidong.dev/iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/">iTerm2 设置详解</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="解剖-Netflix"><a href="#解剖-Netflix" class="headerlink" title="解剖 Netflix"></a><a href="https://lanzhiheng.com/posts/no-rule-in-netflix">解剖 Netflix</a></h3><p><em>原文地址：<a href="https://lanzhiheng.com/posts/no-rule-in-netflix">《解剖 Netflix - 全美员工满意度最高的企业》 | Step By Step</a></em></p><p>这是本文作者从一本叫做《零规则》的书的笔记，主要讲述一家名为 Netflix 的科技公司的经营传奇。</p><p>这家公司是全美员工满意度最高的公司，而「零规则」这几个字，也正是 Netflix 的核心文化之一。</p><p>下面就来讲讲 Netflix 的不同之处：</p><ul><li><p>「零规则」并不是完全没有规则：「零规则」不代表 Netflix 是一家毫无规则的公司，它也有解雇员工的准则，而且可能比其他公司都要狠，甚至连 CEO 都能被解雇；它的零规则指的是它不会花时间制定考勤、打卡、费用报销、上班时长等细则，因为 Netflix 相信自己招聘的肯定是最出色的员工，否则，他们也无法在如此严苛的岗位筛选中存活下来。</p></li><li><p>行业的最高薪资：只招揽最优秀的人才，并且没有固定的涨薪幅度，而是鼓励员工出去面试，根据拿到的 offer 给予对应的涨幅。</p></li><li><p>同事不是家人：许多企业会宣称我们是一个大家庭、同事们都是家人。而 Netflix 认为同事是合作伙伴，而不是家人，因为如果在公司里大家都以家人相称反而会导致不能作出正确的决策。</p></li><li><p>以 Netflix 最大利益为考量：Netflix 采用树形的决策模式，底层员工不需要凡事去请示上司，因为自己才是决定这件事的最佳人选，Netflix 认为员工不会因为这个决定让自己蒙羞。</p></li><li><p>无休假规定也没有固定的工作时长：如果一个人用工作时长的一半就完成了他的工作，剩下的时间他选择阳光海滩。而另一个人每天加班加点，超时工作才能把事情做完，果断给第一个人加工资。</p></li><li><p>信息透明：没有「报喜不报忧」的潜规则，Netflix 认为自家员工都是成年人，有能力辨别什么能说什么不能说。</p></li></ul><h3 id="在生产环境中使你的-npm-i-速度提升-50"><a href="#在生产环境中使你的-npm-i-速度提升-50" class="headerlink" title="在生产环境中使你的 npm i 速度提升 50%"></a><a href="https://shanyue.tech/frontend-engineering/npm-install.html">在生产环境中使你的 npm i 速度提升 50%</a></h3><p><em>原文地址：<a href="https://shanyue.tech/frontend-engineering/npm-install.html">《在生产环境中使你的 npm i 速度提升 50%》 | 山月行</a></em></p><ul><li>选择时延低的 <code>registry</code>，需要企业技术基础建设支持</li><li><code>NODE_ENV=production</code>，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)</li><li><code>CI=true</code>，npm 会在此环境变量下自动优化</li><li>结合 CI 的缓存功能，充分利用 <code>npm cache</code></li><li>使用 <code>npm ci</code> 代替 <code>npm i</code>，既提升速度又保障应用安全性</li></ul><h3 id="浅析-Web-录屏技术方案与实现"><a href="#浅析-Web-录屏技术方案与实现" class="headerlink" title="浅析 Web 录屏技术方案与实现"></a><a href="https://www.zoo.team/article/webrtc-screen">浅析 Web 录屏技术方案与实现</a></h3><p><em>原文地址：<a href="https://www.zoo.team/article/webrtc-screen">《浅析 Web 录屏技术方案与实现》 | zoo</a></em></p><ul><li><p>有感录屏：</p><ul><li><p>有感录屏一般指通过获得用户的授权或者通知用户接下来的操作将会被录制成视频，并且在录制过程中，用户有权关闭中断录屏。即无论在录屏前还是录屏的过程中，用户都始终能够决定录屏能否进行。</p></li><li><p>实现方式：WebRTC。</p></li></ul></li><li><p>无感录屏</p><ul><li><p>无感录屏指在用户无感知的情况，对用户在页面上的操作进行录制。实现上与有感录制区别在于，无感录制通常是利用记录页面的 DOM 来进行录制。常见的有 canvas 截图绘制视频和 rrweb 录制等方案。</p></li><li><p>实现方式：</p><ol><li>canvas</li><li>rrweb</li></ol></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>rrweb 的话只是对 SPA 场景比较好，但对于 微前端/Iframe 场景，它基于 DOM 的回溯就会失效从而失去其录制功能，加上整个 rrweb 链路代码实现复杂度较高，个人认为能用 WebRTC 还是走 RTC 实现比较好。</p><h3 id="如何为你的问题获得有用的答案"><a href="#如何为你的问题获得有用的答案" class="headerlink" title="如何为你的问题获得有用的答案"></a><a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">如何为你的问题获得有用的答案</a></h3><p><em>原文地址：<a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">《How to get useful answers to your questions》 | Julia Evans</a></em></p><ol><li>问一个模糊或未明确指定的问题时，可能出现的问题：<ol><li>这个人首先解释一堆我已经知道的东西</li><li>这个人解释了一些我不知道的事情，但我认为这些事情与我的问题无关</li><li>这个人开始给出相关的解释，但使用我不理解的术语，所以我仍然最终感到困惑</li></ol></li><li>通过问「是否」的问题，可以更快地得到有用的信息。</li><li>如果别人做了一个漫长而无关紧要的解释，可以直接打断</li><li>不接受没有回答你的问题的答案</li></ol><h3 id="谈谈在SQL语句中的优化技巧"><a href="#谈谈在SQL语句中的优化技巧" class="headerlink" title="谈谈在SQL语句中的优化技巧"></a><a href="https://qq52o.me/696.html">谈谈在SQL语句中的优化技巧</a></h3><p><em>原文地址：<a href="https://qq52o.me/696.html">《谈谈在SQL语句中的优化技巧》 | qq52o</a></em></p><p>此文一共列了 30 个优化技巧，内容已经比较精炼了，这里我就不一一列出，有兴趣直接进原文阅读。</p><h3 id="求职时的常见错误"><a href="#求职时的常见错误" class="headerlink" title="求职时的常见错误"></a><a href="https://1byte.io/resume-mistakes/">求职时的常见错误</a></h3><p><em>原文地址：<a href="https://1byte.io/resume-mistakes/">《求职时的常见错误》 | 1 Byte</a></em></p><ul><li>细节：对待简历要认真，一个连简历都不重视细节的人，可想而知在工作中有多马虎。</li><li>精通：慎重「精通」二字，除非你有自信比面试官更熟悉它。</li><li>面试：遇到不会的难题，不要轻易放弃，面试官想要看到的是你如何解决问题。</li></ul><h3 id="如何在-Emacs-里做所有事"><a href="#如何在-Emacs-里做所有事" class="headerlink" title="如何在 Emacs 里做所有事"></a><a href="https://1byte.io/how-to-do-everything-in-emacs/">如何在 Emacs 里做所有事</a></h3><p><em>原文地址：<a href="https://1byte.io/how-to-do-everything-in-emacs/">《如何在 Emacs 里做所有事》| 1 Byte</a></em></p><p>Emacs 简直堪称是一个操作系统，之前有研究过使用 Emacs 下面的 Org-mode 插件来做我的内容管理系统，但是折腾了一下觉得太难上手了，于是转向使用 Notion。</p><p>而本文中的视频就展示了 Emacs 的 Org-mode 强大，有兴趣可以看看。</p><h3 id="小程序单元测试最佳实践"><a href="#小程序单元测试最佳实践" class="headerlink" title="小程序单元测试最佳实践"></a><a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">小程序单元测试最佳实践</a></h3><p><em>原文地址：<a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">《小程序单元测试最佳实践》 | wxsm’s pace</a></em></p><ul><li><p>启动很慢！至少需要 30 秒；因为每个不同的测试文件都需要单独启动并连接一遍实例。</p><ul><li>共享同一个全局实例（×），不起作用。</li><li>将所有测试用例放在单文件中共享实例（×），运行一次需要等到所有测试跑完才能看到结果。</li><li>不通过 launch，直接 connect 到现有窗口（√），只在第一次会比较慢。</li></ul></li><li><p>通过 navigateTo 这类方法跳转很慢：通过点击页面元素的方式触发会比较快。</p></li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>去年年初的时候也曾尝试过在项目中推动微信小程序的 E2E 自动化测试，当时把此文所提到的坑都踩过一遍、连最后选择的解决方案都是一样的。</p><p>之前也有在  Web 项目实践过的 E2E 测试（用的是 Cypress），体验比微信小程序的自动化测试好一万倍不止。不过回头想想，像微信小程序这样不伦不类的产物，本来就是恶心开发者的，还扯什么开发体验呢？</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://polypane.app/css-specificity-calculator">CSS Specificity Calculator</a>：CSS 选择器优先级计算，帮助你快速计算你的 CSS 选择器优先级。</p></li><li><p><a href="https://github.com/2nthony/blogkit">Blogkit</a>：一个朋友的开源项目，利用 Notion API 驱动，将 Notion 作为博客的后台数据库，目前已经支持分发到内置的静态网站以及语雀。</p><ul><li>btw，自从 Notion 开放 API 依赖，将 Notion 作为博客后台数据库的 idea 就层出不穷，并且已经有不少人付诸实践，比如这里还有一个：<a href="https://www.coryetzkorn.com/blog/how-the-notion-api-powers-my-blog">How the Notion API Powers My Blog</a>。 虽然我个人也很喜欢使用 Notion 作为我的资料库，但目前仍没有打算基于它来做博客。</li></ul></li><li><p><a href="https://coderwall.com/">Coderwall</a>：一个开发人员社区的开发和设计技巧、工具和项目，可以从上面学到很多技巧，包括但不限于：Shell、Git、JavaScript、CSS 等。</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://4ark.me/tags/weekly/">weekly</category>
      
      
      <comments>https://4ark.me/post/weekly-03.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
